<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-22T17:06:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YeongGi’s tech blog</title><subtitle>This is YeongGi&apos;s tech blog. I post IT related items.</subtitle><author><name>071yoon</name></author><entry><title type="html">함께 자라기</title><link href="http://localhost:4000/deep-thought/2022/04/22/grow-together.html" rel="alternate" type="text/html" title="함께 자라기" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T00:00:00+09:00</updated><id>http://localhost:4000/deep-thought/2022/04/22/grow-together</id><content type="html" xml:base="http://localhost:4000/deep-thought/2022/04/22/grow-together.html"><![CDATA[<h2 id="함께-자라기">함께 자라기</h2>

<h3 id="서론">서론</h3>

<p>우선 이전글에서 다뤘던 SW Maestro <code class="language-plaintext highlighter-rouge">소마</code> 라고 하는 정부지원사업에 붙게 되었다. 320명이나 되는 연수생들을 대충 확인해보았는데, 정말 다양한 사람들이 정말 많다는것을 느꼈다. 그리고 대부분이 전공생이 였다는게 정말 놀라웠다. 현재 진행중인 42 Seoul 인 경우에는 전공생보다는 부전공 혹은 아예 다른 전공에서 다른 일을 하다 프로그래머의 길로 빠지게 된 경우도 많이 보았는데 참 색달랐다.</p>

<p>그 후 멘토링을 몇번 받게 되었고, 운 좋게 마음에 드는 두분을 만나 팀 매칭까지 끝나게 되었다. 우리는 AI, 나 어플의 CRUD 시스템같은것 보다는 조금 더 혁신적이고, 재미있는 프로젝트를 하기로 했다. 아직 정확한 기획은 없지만 아마 메타버스 혹은 그 상위의 무엇인가가 될것 같다. 조합은 웹의 정석이라 불리는 2FE 1BE 로 진행이 될 것 같다.</p>

<p>그리고 우리의 목적은 사업적으로 엄청나게 뛰어난 창업을 하겠다! 혹은 이 세계에 도움이 되는 무언가를 만들어 내겠다! 이런것은 아니다. 좀 더 우리의 가치와 실력을 높일 수 있는 기회가 되었으면 좋겠다! 에 가깝다. 그래서 우리는 최대한 다양한 기술들을 배우고 협력하는 과정을 느껴보자! 가 주제가 되었다.</p>

<p>그렇게 우리의 목적에 맞춰 우선 정한것은</p>

<ol>
  <li>Jira 를 사용해보자</li>
  <li>애자일 방법론을 채용하자</li>
</ol>

<p>였다.</p>

<p>Jira 같은 경우에는, 차차 더 알아보며 Git Confluence 와 연동해서 사용 해 볼 예정이고 애자일 방법론에 대해서는 스프린트와 스크럼 정도밖에 몰랐던 나였기에 조금 더 공부를 해보고자 하였다.</p>

<p>그렇게 애자일이 무엇인가! 항상 근본적인것을 좋아하는 나는 애자일의 뜻부터 알아보았다.</p>

<blockquote>
  <p>애자일은 민첩성을 뜻하며 소포트웨어 기업들이 도입한 개념으로 급변하는 시장에서 기민한 대응을 하기 위해 빠르고 유연한 기업 환경(조직)을 만드는 것을 목적으로 한다.</p>
</blockquote>

<p>항상 말은 참 쉽지만, 실제로 이해하기는 정말 까다롭다. 그러던 중 팀원 중 한명이 <code class="language-plaintext highlighter-rouge">함께 자라기</code> 라는 좋은 애자일 방법론에 대한 책이 있다하여 읽어 보기로 하였다.</p>

<h3 id="자라기">자라기</h3>

<p>이 책을 읽다보면 정말 단순하지만 머리를 띵! 하게 만드는 부분들이 꽤나 있다. 우선 자라기에 대한 부분이 내 입장에서 제일 생각을 많이하게 만들었다.</p>

<h4 id="가치">가치</h4>

<p>다들 <code class="language-plaintext highlighter-rouge">1만시간의 법칙</code> 을 많이들 들어보았을 것이다. 정말 단순하게 어떠한 분야의 전문가가 되려면 <code class="language-plaintext highlighter-rouge">1만시간</code> 정도가 필요하다는 뜻이다. 하지만 이 말에는 큰 함정이 빠져있다. 이 <code class="language-plaintext highlighter-rouge">1만시간</code> 에는 단순히 내가 즐기거나, 어쩔 수 없이 하는것이 아니라 피드백을 받고 공부하거나 노력하는 과정이 포함되어야 된다는 것이다. 게임을 보더라도 내가 낮은 티어에서 게임을 몇천판을 하였지만, 아직도 낮은 티어일 수 있다. 책에서는 그 이유를 피드백 혹은 노력을 하지 않는것이라고 본다. 매 판마다 분석을 하고 취약점에 대하여 고치려는 노력을 한다면, 약점에 대해서는 반복적인 훈련을 한다면, 과연 실력이 낮은채로 가만히 있을까? 당연히 실력이 개선되는 미래가 펼쳐질 것이다.</p>

<h4 id="피드백">피드백</h4>

<p>자라기에 또 매우 중요한 부분이 있다. 바로 피드백이 빨라야 된다는 것이다. 만약 우리가 어떠한 액션을 취하였을 때, 그에대한 결과가 1년후에 온다면 어떨까? 아마 1년전에 어떤 액션을 취했는지 기억도 잘 나지않아, 피드백이 제대로 이루어지지 않을것이다. 액션 직후 피드백을 바로 받고 그것을 기록 후 다음에 볼때 진정한 피드백이 완성된다고 본다. 그리고 이것은 <code class="language-plaintext highlighter-rouge">1만시간의 법칙</code> 에도 포함이 된다. 빠르고 진정성있는 피드백이 나를 발전시키는 중요한 포인트라 할 수 있다.</p>

<h4 id="실수">실수</h4>

<p>이 책은 이상하리만치 실수에 관대하다. 오히려 실수를 권장하는 모습까지 보여준다. 이건 나의 입장에서는 정말 특이한 접근이였다. 프로그래밍을 하다보면 실수를 줄여가는 것이 전문가의 덕목이라고 생각했고, 실제로 내가 처음 프로그래밍을 하던것과 비교를 해보면 실수가 정말 상당히 줄었다. 하지만 여기서 말하는 실수는 실제로 컴파일 과정을 하고 서버 배포를 해보니 앗! 에러가 있네! 이런것이 아니다. 프로그래밍을 하다 작은 오타 혹은 변수 하나 잘못 넣은것도 실수라고 본다. 그리고 이러한 소소한 실수는 얼마든지 해도 되지만 이러한 실수를 한 후 어떤식으로 대처를 하는것인가에 대해 집중한다.</p>

<p>책에서는 실수에 대한 문화를 두가지로 나누는데 <code class="language-plaintext highlighter-rouge">실수 예방</code> 과 <code class="language-plaintext highlighter-rouge">실수 관리</code> 이다. 첫번째인 <code class="language-plaintext highlighter-rouge">실수 예방</code> 을 중점으로 두는 회사같은 경우, 실수를 하는 경로를 방지하며, 실수에 대하여 비난 및 처벌이 주가 되는 반면, <code class="language-plaintext highlighter-rouge">실수 관리</code> 를 중점으로 두는 회사는, 실수를 빨리 발견 및 해결 그리고 피드백 후 다음에는 어떤식으로 대처를 하자가 주가 된다.</p>

<h3 id="함께">함께</h3>

<h4 id="and-or">AND OR</h4>

<p>여기서 AND OR 연산자로 사람을 설명한다. 정말 공대스럽지 않을 수 없다. 하지만 또 정말 이것만큼 공대생들을 이해시켜주기 편한게 없다고 생각한다. 사람이 무엇인가를 배우거나 협력을 할 떄 AND 인지 OR 인지에 대하여 진지하게 설명한다.</p>

<p>우선 우리는 AND 보다 OR 적인 사람이 되어야 된다 설명한다. 분석을 하였을 떄, AND 성향이 있는 사람은 독립 개체로 본다. 통계적으로 보면 독립사건이 되는것이다. 예를 들어, 프로그래머가 작업을 마감일에 맞춰 끝낼 확률이 0.9라 보자. 그럼 프로그래머가 5명이 모두 마감일에 맞출 확률은 0.9일까? 이건 0.9 ^ 5 의 확률이 될 것이고, 이건 0.6 밖에 되지 않는다. 즉 통계의 오류가 발생한 것이다. 하지만 팀을 꾸려 5명이서 한 작업을 같이 끝내고, 다음으로 넘어가는 식으로 한다면? 그건 OR 연산으로 오히려 한 프로젝트당 잘 끝낼 확률이 0.9보다 높아지며 효율또한 증가할것이라는 분석이다. 물론 실제로는, BE FE 등 따로 작업을 하겠지만, 그럼에도 불구하고 정말 좋은 접근이라 생각한다.</p>

<p><code class="language-plaintext highlighter-rouge">당국자미 방관자청 (當局者迷 傍觀者淸)</code> 바둑을 구경하는 이가 더 수를 잘 본다 라는 뜻이다. 이건 단순히 바둑이 아닌 프로그래밍에도 통용이 된다 생각한다. 내가 페어프로그래밍을 할 때, 실제로 타이핑을 하는 사람은 타이핑하느라 정신이 없고, 설계한 대로 구현하고 있을때, 옆에서 보조하는 사람은, 코드를 보며 오류를 손쉽게 찾을 수 있으며, 설계에서 더 흐름을 보기 쉽다고 생각을 한다. 이러한 점에서 OR 적이며 앞에서 말한 실수의 관리에도 더욱 효율이 좋을것이다.</p>

<h3 id="애자일">애자일?</h3>

<p>사실 책은 애자일 방법론에 대하여 그렇게 중점적으로 설명해주지 않는다. 오히려 애자일이 디테일해질수록 애자일에 멀어진다고 설명한다. 애자일은 애초에 민첩하게 급변하는 시장에 맞춰 발전하는 형태이기에, 정적일수록 근본적으로 맞지않다고 판단하는 것이다.</p>

<p>그럼에도, 나는 조금 더 스크럼을 하는법 혹은 스프린트를 뛰는법에 대하여 알려줬으면 좋겠다고 생각을 했지만, 그런부분은 조금 아쉬웠다. 그럼에도, 애자일을 왜 사용해야 되는지는 정말 깔끔하게 설명을 해준 것 같다. 앞에서 언급한 가치, 피드백, 실수 등 애자일 방법론을 채택하면 모두 극복이 가능한 시나리오 이다. 매일매일 스크럼과 일주일 단위의 회고로 인하여 완벽한 피드백 시스템을 구축 할 수 있으며, 이러한 과정에서 가치를 높일 수 있다 생각한다.</p>]]></content><author><name>071yoon</name></author><category term="deep-thought" /><category term="deep-thought" /><category term="book" /><summary type="html"><![CDATA[함께 자라기]]></summary></entry><entry><title type="html">SW Maestro 지원 후기</title><link href="http://localhost:4000/retrospect/2022/03/03/sw-maestro.html" rel="alternate" type="text/html" title="SW Maestro 지원 후기" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/retrospect/2022/03/03/sw-maestro</id><content type="html" xml:base="http://localhost:4000/retrospect/2022/03/03/sw-maestro.html"><![CDATA[<h2 id="intro">Intro</h2>

<p>오늘 심층면접을 끝으로 길고 길었던 소프트웨어 마에스트로의 지원이 끝났다.</p>

<p>1월애 자소서를 쓰는것부터 시작해서 무려 두달이나 걸려서 오늘 최종 면접까지 가게 되었다. 끝나고 나니 아쉬운 부분도 있지만, 우선 정말 후련하고 후회는 없다.</p>

<h2 id="1-자소서-예의는-있지">1. 자소서 [예의는 있지?]</h2>

<p>자소서를 쓰는 단계였다. 하지만 인터넷 어디를 찾아봐도 자소서에서 떨어졌다는 이야기는 없다. 하지만 자소서는 면접질문에서 부메랑처럼 날아 올 수 있기에 최대한 사실대로 솔직하게 나의 정보를 어필하는것이 좋다고 판단했다. 그래서 꾸밈없이 정말 내가 개발하고 싶은 정보나 나의 철학을 정말 아낌없이 표현했다. 그리고 당연히 합격했다…</p>

<blockquote>
  <p>하지만 자소서의 내용은 평생 쓸 일이 없었는데… 읍읍..</p>
</blockquote>

<h2 id="2-1차-코딩테스트-너-코딩할-줄-아니">2. 1차 코딩테스트 [너 코딩할 줄 아니?]</h2>

<p>1차 코딩테스트는 사실 별거 없었다. 시간만 충분했다면 웹까지 8문제 전부 어렵지 않게 풀 수 있을 수준이였다. 물론 시간이 문제여서 알고리즘 6번째 문제는 풀지 못했지만, 그래도 나쁘지 않게 보았고, 끝나자 마자 “아..! 붙겠다..!” 라는 생각을 했다.</p>

<p>결과는 당연히 붙었다. 사실 byukim 님이랑 [42서울에서 만난 같이 소마를 지원하신 저의 영혼의 파트너] 한달넘게 코딩테스트를 준비했기에, 1차에서 떨어질 걱정은 하지 않았다. 다행히 byukim님 또한 잘 붙어서 2차까지 가게 되었다.</p>

<p>자세한 코딩테스트의 문제들은 보안상의 이유로 공개 할 수 없지만, 정말 백준 실버1 급의 문제들이 대거 나왔기 때문에, 평소에 알고리즘을 1회독이라도 했다면, 어렵지 않게 합격 할 수준이다.</p>

<h2 id="3-2차-코딩테스트-응-안풀면-그만이야">3. 2차 코딩테스트 [응~ 안풀면 그만이야~]</h2>

<p>42서울에서 느꼈지만, 나는 카더라 통신에 정말 약하다. 이번 역시 카더라 통신을 신뢰했지만 결과는 처참했다. 분명히, 2차에서는 1차 코테에 문제에서 업그레이드된 문제가 나온다고해서, 이분탐색과 다익스트라를 정말 달달 외우고 갔지만 한문제도 나오지 않았다… 그리고 정말 뜬금없이 유니온 파인드와 미친난이도의 구현문제가 나왔다.</p>

<blockquote>
  <p>백준 다이아분도 구현문제는 어려워서 못푸셨다고 한다</p>
</blockquote>

<p>구현문제같은 경우는 끝나고 찾아보니, 백준 테트리미노와 비슷했지만 DP를 활용해서 푸는 문제였다. 푼 사람말로는 무슨 4차원 DP(..?) 썼다고 들었는데 이걸 두시간안에 풀 수 있을 사람이 있을까..? 싶었다. 구현문제를 제외하고는 난이도는 평이했다. 하지만 SQL에서 실수하기 정말 쉬운 함정을 파뒀고 나를 포함한 많은 참가자들이 함정에 바로 푹 빠져버렸다. 이 문제에 대해서는 추후에 면접에서 나올 예정이다.. 그리고 웹은 생각보다 쉬웠지만, 알고리즘을 풀다가 못풀어 버렸다.</p>

<p>사실 비하인드 스토리긴 하지만, 나는 웹과 알고리즘 3번을 코딩테스트 당시에 엄청 고민했다. 둘 다 풀 수 있을 수준이라고 생각했고, 아무래도 알고리즘을 최근에 엄청 열심히 했기에 조금만 더 생각해보면 풀릴거라 생각했다. 그리고 비슷한 문제를 백준에서 풀었기에 더 자신감이 있었을지도 모르겠다. 하지만 구현을 하면 할수록 개미지옥에 빠지는 느낌이였고 결국 두마리 토끼 다 놓쳐버렸다… 그냥 웹이나 할걸..</p>

<p>그렇게 총 두문제 밖에 풀지 못했지만, 운이 좋은건지 문제가 전체적으로 어려웠던건지 2차 코딩테스트까지 합격하게 됐다. 그리고 포트폴리오 준비로 넘어갔다.</p>

<h2 id="4-포트폴리오-타임어택-on">4. 포트폴리오 [타임어택 ON]</h2>

<p>2차 합격은 화요일 오후쯤 나왔고, 금요일 4시까지 포트폴리오를 제출하라고 했다. 다행인것은 기본적인 템플릿을 제공해 주어 사실 채우라는것만 채우면 됐었다. 하지만 여기서 함정이 숨어 있었는데 바로..</p>

<blockquote>
  <p>3분안에 발표할 내용을 넣어주세요</p>
</blockquote>

<p>그렇게 채워서 나름대로 시간을 재고 발표를 해보니 시간은 이미 4분이 훌쩍 넘어가 있었다. 그래서 열심히 채웠던 내용을 빼고 또 빼고 해서 3분을 채워서 제출했다. 지금와서 드는 생각이지만, 어차피 발표할 때 빼고 발표하면 되니까 맘껏 꾹꾹 눌러 담을 걸 그랬다.</p>

<p>나는 내가 정말 개발에 열정이 있고, 배포도 해봤고 협업도 잘했다..! 라고 표현하기 위해서 프로젝트 하나와, 내가 아직 제대로 개발한지는 1년밖에 되지 않았지만 그래도 정말 열심히 살았다는 증거를 보여주기 위해 자기소개 두개를 넣어서 진행했다.</p>

<h2 id="5-면접-히히-죽어라">5. 면접 [히히 죽어라]</h2>

<p>진짜 피말려서 죽는 줄 알았다… ㅋㅋㅋㅋ 끝나고 같이 면접하신 분이랑 점심을 먹고 헤어졌는데 정말 둘이서 실소를 했다가 아쉬워했다가 미친사람들처럼 밥을 먹었다…</p>

<p>우선 3분 포트폴리오 발표부터 했는데, 이거부터 문제였다. 2번인 나는 1번 다음 발표여서 아..! 1번님 하는거보고 바로 전략을 세워야겠다..! 생각을 했는데 웬걸 1번님이 안오셔서 내가 1번이 되어버렸다.. 그래서 질문같은것도 내가 항상 1번으로 대답해야했다… ㅜㅜㅜㅜ 이렇게 운이 안좋을 수 있나…!!</p>

<p>사실 발표를 준비 할 때 제일 걱정됐던게 3분을 넘기면 무슨일이 일어날지였다. 그런데 발표를 시작하자마자, 관계자분이 오셔서 스탑와치를 탁 두고 가셨다. 뭔가 보고 있으니 이미 시간이 2:59… 2:58… 이렇게 가고 있었다. 그래서 아차! 싶어서 빠르게 발표를 시작했다.</p>

<p>발표연습을 꽤 했었기에 대충 3분 나오는것을 알고 있었지만, 면접관들 얼굴한번 화면한번 조작한번 하다보니 생각보다 시간적으로 오차가 생겼다. 그래서 딱 마지막으로 ‘저를 이러이러한 지원자로 기억해주셨으면 좋겠습니다~’ 라는 멘트를 하려고 했는데 3분이 딱 걸려버렸다. 처음에 무시하고 에이 5초정도는 봐주겠지 라고 생각했지만 타이머는 기계였다. 한치의 오차 없이 ‘띠…띠…띠…’ 소리가 면접실에 울렸고 나는 ‘넵 감사합니다’ 하고 끝이나버렸다… 그래도 거의 할말을 다 했기에 아쉬움은 없지만 그래도 마지막 멋진 멘트를 할 기회를 뺐겼다는것이 아쉬웠다.</p>

<p>면접을 진행하다 보니 면접관들은 프로그래밍의 신이기 때문에 함부로 까불면 안된다는것을 배웠다. 다행히 나는 그렇게 어려운 API 나 Open Source 를 쓴것도 아니고, 그냥 React 로 프로젝트를 만들어 봤고 내가 아는선에서 발표를 진행했기에 그렇게 공격(?) 받지는 않았다. 하지만 나를 제외하고 3명은 전부 AI 를 활용했다고 발표했기에 엄청난 공격을 받으셨다.</p>

<blockquote>
  <p>근데 공격 받은게 좋은건지 그냥 관심없어서 넘어간게 좋은건지는 모르겠다</p>
</blockquote>

<p>나는 최대한 나에게 질문오는 것을 열심히 대답했다고 생각은 하는데, 면접관들이 보기엔 어떻게 생각할지 모르겠다. 하지만 면접은 자신감이라고 했다. 나는 모르든 맞든 내 대답이 앞뒤가 맞는 안맞든 그냥 자신감있게 뱉고 봤다. 지금 생각해보니 정말 막 대답을 해서 면접관 분들이 알아 들으셨을지도 잘 모르겠다.. ㅜㅜ</p>

<p>그리고 꼬리질문은 정말 매서웠다. 내가 쓴 기술들을 정말로 알고 있는지 확인을 정말 많이하셨고, 나는 특별히 어려운 기술을 안써서 잘 넘어갔다고 생각한다. 그리고 개발론에대해서도 대뜸 물어보시는 면접관이 계셨는데, 한명만 제대로 답할 수 있었다…</p>

<h2 id="후기">후기</h2>

<p>그렇게 한시간의 5:5 면접을 끝내고 나의 소프트웨어 마에스트로 지원이 끝이났다. 솔직히 1월부터 현재까지 프로젝트 진행하랴, 알고리즘 준비하랴, 발표 및 면접 준비하랴 정말 열심히 살았다. 그렇게 좋아하는 게임도 단 한판도 못할정도로 바쁘게 살았고 농도가 짙은 방학을 보냈다고 생각한다. 솔직히 결과가 어떻게 될지는 예상하기 어렵다. 나의 열정과 잠재력은 충분히 보여줬다고 생각은 들지만, 면접관들이 보시기에 내 진심이 잘 통했는지 모르겠다. 나는 기술적인 스택이 부족한것을 알기에 애초에 중점을 팀워크를 잘하고 포텐셜이 충만한것으로 갔었는데, 내 전략이 잘 먹혔기를 기도할 뿐이다.</p>

<p>앞으로 1주반 후에 결과가 나올텐데, 다음글이 소프트웨어 마에스트로 관련 글이라면 아마 합격을 했을것이고, 아예 딴 글이거나 올라오지 않는다면 떨어졌을것이다.</p>

<p>이렇게 열심히 무언가를 위해서 준비한것은 정말 수능 이후로 처음인것 같았다. 열심히 준비한만큼 좋은 결과가 있기를 바라지만, 그렇지 않더라도 값진 경험을 했다고 생각하고 더 발전하는 계기가 되었다고 생각할것이다.</p>]]></content><author><name>071yoon</name></author><category term="retrospect" /><category term="me" /><category term="retrospect" /><summary type="html"><![CDATA[Intro]]></summary></entry><entry><title type="html">서버 맛보기</title><link href="http://localhost:4000/server/2022/02/23/server.html" rel="alternate" type="text/html" title="서버 맛보기" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/server/2022/02/23/server</id><content type="html" xml:base="http://localhost:4000/server/2022/02/23/server.html"><![CDATA[<h2 id="what-is-nodejs">What is Node.js</h2>

<p>Javscript는 알다시피 HTML 을 활용하기 위해서 만들어진 언어이며, 컴파일은 브라우저가 담당한다.</p>

<blockquote>
  <p>Chrome 은 V8, FireFox 는 SpiderMonkey ..</p>
</blockquote>

<p>그리고 Chrome V8 해석엔진이 워낙 좋아서, 해당 엔진을 사용하여 자체를 따로 출시하여 만든것이 Node.js 즉 크롬의 자바스크립트 엔진</p>

<p>자바스크립트를 브라우저 내에서 사용하는것이 아닌 다른 환경에서도 실행을 할 수 있게 도와주기 위한 도구, 즉 런타임 실행환경이라 볼 수 있다</p>

<p>이제 Node.js 덕분에 JavaScript를 프로그래밍 언어처럼 만들 수 도 있고, 서버도 쉽게 만들 수 있음!!</p>

<p>그리고 Node.js 의 가장 큰 장점은 Non-blocking I/O 를 활용한다는점!!</p>

<h2 id="nodejs의-특징">Node.js의 특징</h2>

<ol>
  <li>Event Driven</li>
  <li>Non-blocking I/O</li>
</ol>

<p>일반적인 서버와 Node.js Non-Blocking 의 특징을 알아보면 일반 서버라면, 요청을 처리하는 과정이 FIFO 으로 제일 먼저 들어온 요청부터 처리하지만, Node.js 라면 일단 I/O 를 다 받아보고 빨리 완료될 것 부터 확인을 해서 처리를 가능하게 해준다.</p>

<p>Node.js의 강점을 보여주는 부분</p>

<ol>
  <li>SNS</li>
  <li>Chatting</li>
  <li>WebServer</li>
</ol>

<p>으로 볼 수 있다.</p>

<p>즉 간단한 서비스나 프로토 타입을 만들기에 정말 좋지만, 처리속도가 타 서버들보다 떨어 질 수 있으며, Node.js의 특징인 Non-Blocking 처리방식 또한, 다른 언어에서도 구현 할 수 있다.</p>

<h2 id="rest-api">REST API</h2>

<h3 id="api">API</h3>

<p>API 란 무엇인가.</p>

<p>Application Programming Interface 라고 부르며, 간단한 통신 규약이라 볼 수 있다. 간단하게 말하면 다른 프로그램들 간에 소통을 할 수 있게 데이터를 가져오는 방법이다.</p>

<h3 id="rest-api-1">REST API</h3>

<p>Representational State Transfer</p>

<p>서버를 RESTFUL 하게 짠다는건 무엇일까??</p>

<p>HTTP 의 4가지 요청 (GET, POST, PUT, DELETE) 를 REST 원칙에 대하여 써보자!</p>

<blockquote>
  <p>대표적으로 6가지의 특징이 있다</p>
</blockquote>

<ol>
  <li>Uniform Interface
    <ol>
      <li>인터페이스는 일관성이 있어야 된다</li>
      <li>하나의 URL 로는 하나의 Data만 가져와야된다</li>
      <li>간결하고 예측가능해야된다</li>
      <li>URL 이름짓기 관습을 따라야한다</li>
    </ol>
  </li>
  <li>Client-Server 역할을 구분한다
    <ol>
      <li>URL 하나만 알면 서버에 있는 자료를 사용</li>
      <li>고객에게 서버의 역할을 맡기거나 DB 를 꺼내오게 하면 안된다</li>
    </ol>
  </li>
  <li>Stateless
    <ol>
      <li>요청들은 각각 독립적으로 처리되어야 한다</li>
      <li>요청1이 성공하면 요청2를 보내주고 하는 식의 요청은 안된다</li>
      <li>요청하나 만으로 자료를 가져올 수 있게 설정</li>
    </ol>
  </li>
  <li>Cacheable
    <ol>
      <li>요청을 통해 보내는 자료들은 캐싱이 되어야 한다</li>
    </ol>
  </li>
  <li>Layered System
    <ol>
      <li>요청을 처리하는곳, DB에 저장하는곳 이런 여러가지 단계를 거쳐 요청을 처리해도 된다</li>
      <li>여러개의 레이어를 거쳐 요청을 처리하게 만들자</li>
    </ol>
  </li>
  <li>Code on Demand
    <ol>
      <li>서버는 고객에게 실제 실행 가능한 코드를 전송 할 수 있다</li>
    </ol>
  </li>
</ol>

<p>다음에는 실제로 Node.js 와 Express 를 사용해 MongoDB 와 연동을 해보자</p>]]></content><author><name>071yoon</name></author><category term="server" /><category term="server" /><category term="TIL" /><summary type="html"><![CDATA[What is Node.js]]></summary></entry><entry><title type="html">몬티 홀 문제</title><link href="http://localhost:4000/deep-thought/2022/02/03/monty-hall.html" rel="alternate" type="text/html" title="몬티 홀 문제" /><published>2022-02-03T00:00:00+09:00</published><updated>2022-02-03T00:00:00+09:00</updated><id>http://localhost:4000/deep-thought/2022/02/03/monty-hall</id><content type="html" xml:base="http://localhost:4000/deep-thought/2022/02/03/monty-hall.html"><![CDATA[<h2 id="몬티-홀-문제">몬티 홀 문제</h2>

<hr />

<h3 id="문제-분석">문제 분석</h3>

<p>몬티 홀 문제는 영화 <code class="language-plaintext highlighter-rouge">21</code>에서 처음 공개된 아이디어이다. 잠깐 문제를 보고 가자면</p>

<blockquote>
  <p>Suppose you’re on a game show, and you’re given the choice of three doors. Behind one door is a car, behind the others, goats. You pick a door, say #1, and the host, who knows what’s behind the doors, opens another door, say #3, which has a goat. He says to you, “Do you want to pick door #2?” Is it to your advantage to switch your choice of doors?</p>
</blockquote>

<blockquote>
  <p>당신이 한 게임 쇼에 참여하여 세 문들 중 하나를 고를 기회를 가졌다고 생각해봐라. 한 문 뒤에는 자동차가 있으며, 다른 두 문 뒤에는 염소가 있다. 당신은 1번 문을 고르고, 문 뒤에 무엇이 있는지 아는 사회자는 염소가 있는 3번 문을 연다. 그는 당신에게 “2번 문을 고르고 싶습니까?”라고 묻는다. 당신의 선택을 바꾸는 것은 이득이 되는가?</p>
</blockquote>

<p>즉 간단히 말하면</p>

<ol>
  <li>문 3개가 있는데 한 문 뒤에는 자동차가 있고 나머지 두 문 뒤에는 염소가 있다. 참가자는 이 상황에서 문을 하나 선택하여 그 뒤에 있는 상품을 얻는다.</li>
  <li>참가자가 어떤 문을 선택하면 사회자는 나머지 두 문 중에 염소가 있는 문 한 개를 열어 참가자에게 그 문에 염소가 있다고 확인시켜준다.</li>
  <li>그 후 사회자는 참가자에게 선택한 문을 닫혀있는 다른 문으로 선택을 바꿀 기회를 준다.</li>
</ol>

<p>얼핏보기에는 정말 간단해 보이는 문제고 나도 처음 문제를 접했을 때는 엥?? 이게 왜 이렇게 핫한 주제일까 라는 생각까지 했다. 하지만 여기서 중요한 점은 <code class="language-plaintext highlighter-rouge">사회자는 어디에 스포츠카가 있는지 알고있다</code> 라는것이 조건부 확률의 전제로 들어간다는 것이다. 정말 단순해 보이는 문제인데, 어째서 이게 많은 수학자들에게 항의 메일이 오도록 했을까??</p>

<blockquote>
  <p>IQ 200 인 사람도 처음에 틀리고, 노벨상 수상자 까지 문제가 잘못됐다고 메일을 보냈다고 한다…!!</p>
</blockquote>

<h3 id="my-thoughts">My Thoughts</h3>

<hr />

<p>우선 정답은 바꾸었을 때의 확률이 2/3 이고, 바꾸지 않았을 때의 확률은 1/3이므로, 당연히 바꾸는 것이 확률적으로 맞다!!</p>

<p>이제, 나의 처음 접근을 한번 살펴보자. 아마 많은 사람들일 나처럼 생각했겠지만, 당연히 50프로라고 생각을 했다. 그리고 이건 부끄러운 생각이 절대 아니다. 직관적으로 생각을 해보면 그렇기 때문이다. 내가 우선 선택을 하였고, 사회자가 둘중 하나를 오픈을 해 주었다. 그 시점을 독립사건으로 본다고 하면, 나는 둘중 하나를 개봉하는것이기 때문에, 확률은 마치 반반처럼 보이지만, 그렇게 단순한 문제가 아니다. 왜냐하면 확률적으로 접근을 해야하기 때문이다.</p>

<p>만약 처음에 내가 선택을 하지 않고, 사회자가 둘중 하나를 열어 준 다음 내가 선택을 하면 독립사건이 되어 50% 확률이 되는것이 수학적으롤도 맞다. 하지만, 내가 처음에 선택을 하였기 때문에, 바꾸지 않고 우승할 확률은 무조건 1/3 확률이고, 바꾸었을 때의 확률은 2/3이 된다. 여기서 중요한점은</p>

<ol>
  <li>사회자는 어디에 자동차에 있는지 이미 알고있다</li>
  <li>내가 처음 선택을 하였다</li>
</ol>

<p>이렇게 두가지가 전제조건으로 나와있어야 조건부 확률로 성립을 한다는 것이다. 만약 사회자가 둘중 하나에 에라이~! 하고 아무거나 열어버린다면 자동차가 나올 수가 있고, 내가 처음 선택을 하지않았다면, 사회자가 어떤 문을 열어야 할 지 선택 할 지 모르기 때문에 전제가 틀려버린다. 아마 많은 사람들이 헷갈린 부분이 이러한 전제조건의 여부가 정확하게 확립되지 않아 헷갈린 것 같다. 하지만 이런식으로 이야기를 하여도 직관적으로 보기엔 정말 어렵다. 그러때는 역시 묻지마 코딩이 정답이다. C++ 로 코딩을 하면서 차근차근 왜 이러하게 나오지는 살펴보자</p>

<h3 id="몬티-홀-문제-시뮬레이션-via-c">몬티 홀 문제 시뮬레이션 via C++</h3>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

int main(){
	srand(time(NULL));

	int monty_sum = 0;
	int dont_change_sum = 0;
	int test_case = 0;
	char simul_on;
	cout &lt;&lt; "simulation counts : ";
	cin &gt;&gt; test_case;
	cout &lt;&lt; "check every simulations? (y/n) ";
	cin &gt;&gt; simul_on;
	for(int i = 0; i &lt; test_case; i++){
		int chosen_door = rand() % 3;
		int correct_door = rand() % 3;
		if (simul_on == 'y')
			cout &lt;&lt; "TEST CASE " &lt;&lt; i + 1 &lt;&lt; " Car is in " &lt;&lt; (char)(correct_door + 'A') &lt;&lt; " and my choice is " &lt;&lt; (char)(chosen_door + 'A') &lt;&lt; "\n";
		if (correct_door == chosen_door){
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall X and got correct\n";
			dont_change_sum += 1;
		}
		else{
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall X and got wrong\n";
		}
		if (correct_door == chosen_door){ // When you choose the coorect one at the first time -&gt; you will never be able to win
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall and got wrong\n";
			continue;
		}
		else if (correct_door != chosen_door){ // When you choose the wrong one at the first time -&gt; you will get it for sure when you change
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall and got right\n";
			monty_sum += 1;
		}
		// Since there is 1/3 possibility to win at the first time, possibility to get the prize is 2/3
	}
	cout &lt;&lt; "\nmonty possibility is : " &lt;&lt; ((double)monty_sum / (double)test_case) * (double)100 &lt;&lt; "%" &lt;&lt; "\ndon't change possibility is : " &lt;&lt; ((double)dont_change_sum / (double)test_case) * (double)100 &lt;&lt; "%" &lt;&lt; "\n";
}
</code></pre>

<p>최대한 간략하면서, 직관적으로 보이게 짜보려고 했는데, 잘 됐을 지 모르겠다.
테스트를 해본 결과 대략 10만번을 돌려보면, 66.95% 와 33.05% 가 나와 거의 2/3 과 1/3에 수렴하는것을 볼 수 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>simulation counts : 100000
check every simulations? <span class="o">(</span>y/n<span class="o">)</span> n

monty possibility is : 66.95%
don<span class="s1">'t change possibility is : 33.05%
</span></code></pre></div></div>

<p>여기서 시뮬레이션에 <code class="language-plaintext highlighter-rouge">y</code> 를 주면 실제 테스트케이스별로 확인도 할 수 있다.</p>

<p>코드를 한번 설계를 해보면 왜 그런지 확실하게 알 수 있는데 확실하게 정의를 할 수 있다. 내가 몬티 홀을 믿고 무조건 바꾼다고 가정을 해보자. 그럼 당연하게 두가지 상황이 나온다.</p>

<ol>
  <li>내가 맞음</li>
  <li>내가 틀림</li>
</ol>

<p>자동차를 개봉하기 전 확률상으로 보면 내가 맞을 확률은 1/3, 그리고 내가 틀릴 확률은 2/3 이다.</p>

<p>여기서 만약 바꾸지 않고 똥고집을 부려 유지를 한다면, 그대로 1/3 확률로 나올 것이다. 하지만 바꾼다면 내가 처음에 틀린 경우 즉 2번으로 시작해서 무조건 맞으므로 맞을 확률이 2/3이 된다.</p>

<p>이제 그럼 매우 간단한 로직으로 설명을 들 수 있다. 내가 몬티홀을 무조건 믿고 바꾼다고 생각을 해보자</p>

<ol>
  <li>내가 처음에 맞으면 무조건 틀림</li>
  <li>내가 처음에 틀리면 무조건 맞음</li>
</ol>

<p>이렇게 설명 할 수 있다. 왜냐면 내가 바꿈으로써 나는 2개의 문을 동시에 확인하는 셈이 되어 버리기 때문이다. 그래서 처음에 맞을 확률 1/3, 처음에 틀릴 확률이 2/3 이므로 시뮬레이션을 돌려도 동일하게 나오는 것이다.</p>

<p>사람의 말로만 들으면 충분히 헷갈릴 수 있다. 컴퓨터 공학도라면 직접 시뮬레이션을 돌려보며 생각을 해보는 것이 이해에 더 도움이 될거라 생각한다.</p>

<h3 id="후기">후기</h3>

<p>나무위키나 블로그들을 보면, 정말 많은 사람들이 다양한 이유로 다양한 설명들을 해놓은 것을 볼 수 있다. 그 중에, 수학적으로 접근을 하여 베이즈의 확률론으로 정리를 해놓은 사람, 혹은 경우의 수로 정리 한 사람, 문이 100개라고 가정을 하고 생각을 해보라는 사람.</p>

<blockquote>
  <p>잘 생각해보면 확률론으로 정리해놓은 것 빼고는 다 증명을 할 수 없는 말들이다</p>
</blockquote>

<p>하지만 이렇게 똑똑이들이 해놓은 증명을 보고도 이해가 잘 안된다면, 무작정 시뮬레이션을 해보고 코딩을 하며 문제를 더 완벽히 파악하고 큰 문제를 짧게 쪼개며 단순화 하는것이 더 도움이 될 수 있다는 생각이 든다.</p>]]></content><author><name>071yoon</name></author><category term="deep-thought" /><category term="deep-thought" /><category term="TIL" /><summary type="html"><![CDATA[몬티 홀 문제]]></summary></entry><entry><title type="html">리액트JS로 앱 만들기 1</title><link href="http://localhost:4000/react/2022/02/02/make-react-app-1.html" rel="alternate" type="text/html" title="리액트JS로 앱 만들기 1" /><published>2022-02-02T00:00:00+09:00</published><updated>2022-02-02T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/02/02/make-react-app-1</id><content type="html" xml:base="http://localhost:4000/react/2022/02/02/make-react-app-1.html"><![CDATA[<h2 id="react란-무엇인가">React란 무엇인가</h2>

<p>React는 간단하게 말해서, 웹의 <code class="language-plaintext highlighter-rouge">Framework</code>이다.</p>

<blockquote>
  <p>정확하게는 사용자 인터페이스를 만들기 위한 Javascript Library</p>
</blockquote>

<p>그리고 <code class="language-plaintext highlighter-rouge">React</code> 란 놈에게는 큰 장점이 있다.</p>

<ol>
  <li>선언형</li>
  <li>컴포넌트 기반</li>
</ol>

<p>이렇게 볼 수 있다.</p>

<h3 id="선언형">선언형</h3>

<hr />

<p>선언형은 React는 상호작용이 많은 UI를 만들 때 생기는 어려움을 줄여준다. 즉 애플리케이션의 각 상태에 대한 간단한 뷰만 설계를 한다면 알아서 React가 데이터가 변경됨에 따라 적절한 컴포넌트만 효율적으로 갱신하고 렌더링을 해준다. 즉 말 그대로 <code class="language-plaintext highlighter-rouge">React</code> 하게 해준다는 것이다.</p>

<p>간단하게 보면, <code class="language-plaintext highlighter-rouge">React</code> 파일에서</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
  <span class="dl">"</span><span class="s2">button</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="na">onClick</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">im clicked</span><span class="dl">"</span><span class="p">),</span>
  <span class="p">},</span>
  <span class="dl">"</span><span class="s2">Click me</span><span class="dl">"</span>
<span class="p">);</span>
</code></pre></div></div>

<p>이런식으로 HTML 으로 선언하지 않고도 단번에 생성과 동시에 옵션을 설정 할 수 있다.</p>

<h3 id="컴포넌트-기반">컴포넌트 기반</h3>

<hr />

<p>스스로 상태를 관리하는 캡슐화된 컴포넌트를 만들 수 있다.</p>

<p>여기서 상태를 관리한다는 말이 리액트에서는 꽤나 중요한 포인트라 할 수 있다. 우선 리액트 컴포넌트는 <code class="language-plaintext highlighter-rouge">render()</code> 함수를 이용하여, 데이터를 입력받아 화면에 표시할 내용을 리턴을 한다는 점에서 자바스크립트와 다르다. 그리고 이러한 컴포넌트는 <code class="language-plaintext highlighter-rouge">this.props</code>를 이용하여 입력 데이터를 다루고, <code class="language-plaintext highlighter-rouge">this.state</code>로 접근 할 수 있다. 그리고 상태 데이터가 바뀌면 <code class="language-plaintext highlighter-rouge">render()</code> 가 다시 호출되어 갱신이 되는 구조이다.</p>

<p>말로 들어서는 이해가 잘 되지 않고, 역시 예제를 보며 학습을 하는것이 필요할 것 같다.</p>

<p>또하나의 큰 장점을 <code class="language-plaintext highlighter-rouge">React Native</code> 로의 방향이 자유롭다는 것이다. <code class="language-plaintext highlighter-rouge">Native</code> 언어란, iOS app 에서 Swift 처럼 그 자체의 OS 를 활용하여 만드는 앱인데, 물론 제작을 하여도 진짜 Native 급으로 속도가 나오지는 않는다. 하지만, 그와 비슷한 속도를 낼 수 있고 문법 자체가 너무나도 비슷해서, 금방 금방 수정하여 웹뿐만이 아닌 페이스북 혹은 인스타그램 처럼 웹앱으로 변환이 가능하다.</p>

<h3 id="jsx-의-활용">JSX 의 활용</h3>

<p>JSX 가 나옴으로써, <code class="language-plaintext highlighter-rouge">React</code> 가 단순히 Javascript 처럼 활용하는것이 아니라, 마치 <code class="language-plaintext highlighter-rouge">HTML</code> 에서 사용한 것 처럼도 사용 할 수 있게 되었다. 이것또한 예제를 보고 확인해보자</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Title</span> <span class="o">=</span> <span class="p">(</span>
  <span class="p">&lt;</span><span class="nt">h3</span> <span class="na">id</span><span class="p">=</span><span class="s">"title"</span> <span class="na">onMouseEnter</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">mouse enter</span><span class="dl">"</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
    Hello I am a title
  <span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
<span class="p">);</span>
</code></pre></div></div>

<p>이런식으로 <code class="language-plaintext highlighter-rouge">CreateElement</code> 를 사용하는것이 아니라, 마치 <code class="language-plaintext highlighter-rouge">HTML</code> 에서 태그를 해서 만드는것인데, 동시에 자바스크립트를 활용하여 만들 수 있게 되었다. 하지만 코드를 잘 보면 <code class="language-plaintext highlighter-rouge">CreateElement</code> 를 아예 안쓰는 것은 아니고, 이런식으로 <code class="language-plaintext highlighter-rouge">HTML</code> 처럼 편하게 적어두면 <code class="language-plaintext highlighter-rouge">BABEL</code> 이란 컴파일러에서 내부적으로 <code class="language-plaintext highlighter-rouge">CreateElement</code> 형으로 변환을 하여 적어주는 것이다.</p>

<blockquote>
  <p>여기서 중요한점은 함수나 변수명을 할 때 대문자로 시작을 해야 실제 HTML 의 태그 <code class="language-plaintext highlighter-rouge">button</code> 같은것과 헷갈리지 않는다</p>
</blockquote>

<h3 id="state-란">State 란</h3>

<p>기본적으로 데이터가 저장되는 곳이라고 보면 쉽다.</p>

<p>간단한 클릭형 버튼을 만들어서 확인해보자</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span> <span class="p">=</span> <span class="s">"text/babel"</span><span class="p">&gt;</span>
	const root = document.getElementById("root");
	let counter = 0;
	function countUp()<span class="si">{</span>
		<span class="nx">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="si">}</span>
	function Container() <span class="si">{</span>
		<span class="k">return</span> <span class="p">(</span>
			<span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span> Total Clicks: <span class="si">{</span><span class="nx">counter</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">countUp</span><span class="si">}</span><span class="p">&gt;</span>Click me<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
			<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
		<span class="p">);</span>
	<span class="si">}</span>
	ReactDom.render(<span class="p">&lt;</span><span class="nc">Container</span> <span class="p">/&gt;</span>, root);
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>이렇게만 보면 좋은 코드같아 보인다. 하지만 여기는 맹점이 있는데, 바로 Rendering 을 한번밖에 하지 않아, 아무리 클릭을 눌러도 웹상에서는 안보이는다는 것이다. 그래서 <code class="language-plaintext highlighter-rouge">State</code> 가 필요하게 된다.</p>

<p>가장 손쉬운 방법은 countUp 함수가 할 때마다, <code class="language-plaintext highlighter-rouge">Render</code> 를 다시 불러주게 되면 해결 할 수 있다. 하지만 아무리봐도, 효율적인 부분이 아니다. 왜냐면 전부 다 렌더링을 하는것이 비효율적이고, 계속 렌더링을 해줘야되는것을 함수를 만들면서 생각을 하면서 설계를 해줘야 되기 떄문이다. 그럼 <code class="language-plaintext highlighter-rouge">그 변수</code>만 업데이트를 하려면 어떻게 해야될까?? 그게 바로 <code class="language-plaintext highlighter-rouge">React</code> 의 최대 장점이다. 즉 매우 <code class="language-plaintext highlighter-rouge">Interactive</code> 하고 <code class="language-plaintext highlighter-rouge">Effective</code> 한 프로그램이 만들어 지는것이다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span> <span class="p">=</span> <span class="s">"text/babel"</span><span class="p">&gt;</span>
	const root = document.getElementById("root");
	function Container() <span class="si">{</span>
		<span class="kd">let</span> <span class="p">[</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">modifier</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="c1">//counter = data[0], modifier = data[1]</span>
		<span class="kd">const</span> <span class="nx">onClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
			<span class="nx">modifier</span><span class="p">(</span><span class="nx">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="c1">//OR modifier((current) =&gt; current + 1);</span>
		<span class="p">};</span>
		<span class="k">return</span> <span class="p">(</span>
			<span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span> Total Clicks: <span class="si">{</span><span class="nx">counter</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">onClick</span><span class="si">}</span><span class="p">&gt;</span>Click me<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
			<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
		<span class="p">);</span>
	<span class="si">}</span>
	ReactDom.render(<span class="p">&lt;</span><span class="nc">Container</span> <span class="p">/&gt;</span>, root);
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>이렇게 설정하면, 클릭이 일어날 때 마다, modifier에서 counter + 1 로 해준 값이 반환되며, <code class="language-plaintext highlighter-rouge">modify</code> 가 일어날 때 마다, 딱 그 부분만 렌더링을 해주는 것이다.</p>

<h3 id="props">Props</h3>

<p>Props 란 부모 컴포넌트로부터 자식 컴포넌트로에게 데이터를 보낼 수 있게 해주는 방법이다.</p>

<blockquote>
  <p>Ex) 버튼의 스타일을 하나하나 다 바꿔주지 말고, 어차피 공통으로 갈거면 그러한 템플릿을 저장해 두었다가 사용하면 더 편하지 않겠냐 라는 것..!!</p>
</blockquote>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Btn</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">reutnr</span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">button</span>
      <span class="na">styles</span><span class="p">=</span>
    <span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">text</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Btn</span> <span class="na">text</span><span class="p">=</span><span class="s">"Save changes"</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">Btn</span> <span class="na">text</span><span class="p">=</span><span class="s">"Continue"</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 사용 할 수 있다.</p>

<h3 id="react-memo">React Memo</h3>

<p>위 예제를 보면 버튼이 <code class="language-plaintext highlighter-rouge">Save Changes</code> 와 <code class="language-plaintext highlighter-rouge">Continue</code> 두개가 생성되었다. 하지만 만약, <code class="language-plaintext highlighter-rouge">State</code>를 활용하여, 첫 버튼만 렌더를 해주려고 해도, 두 버튼 다 렌더링이되는 불상사가 발생한다. 이러한 사태를 어떻게 막을 수 있을까?? 리액트 메모를 활용하여 막을 수 있다.</p>

<blockquote>
  <p>const MemorizedBtn = React.memo(Btn);</p>
</blockquote>

<p>라고 활용하고나서, 그 후 Btn이 아니라 MemorizedBtn 으로 호출하면 렌더링을 한번만 해도 될 수 있게 된다!!</p>]]></content><author><name>071yoon</name></author><category term="react" /><category term="react" /><category term="javascript" /><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[React란 무엇인가]]></summary></entry><entry><title type="html">The mind behind linux</title><link href="http://localhost:4000/deep-thought/2022/01/26/deep-thoughts-1.html" rel="alternate" type="text/html" title="The mind behind linux" /><published>2022-01-26T00:00:00+09:00</published><updated>2022-01-26T00:00:00+09:00</updated><id>http://localhost:4000/deep-thought/2022/01/26/deep-thoughts-1</id><content type="html" xml:base="http://localhost:4000/deep-thought/2022/01/26/deep-thoughts-1.html"><![CDATA[<h2 id="talk-is-cheap-show-me-the-code">Talk is cheap. Show me the code.</h2>

<p><code class="language-plaintext highlighter-rouge">Linus</code>의 전설적인 명언이다. 컴퓨터 공학도라면 한번쯤은 들어봤을 이름 <code class="language-plaintext highlighter-rouge">리누스 토르발스</code>. 내가 이 이름을 처음 들었던 것은 <code class="language-plaintext highlighter-rouge">System Programming</code> 과목에서 <code class="language-plaintext highlighter-rouge">Linux</code> 를 처음 배울 때 였다. 처음 <code class="language-plaintext highlighter-rouge">Linux</code>를 접했을 때는, 엥?? 이게 뭐지?? 싶을정도로 기괴했고, <code class="language-plaintext highlighter-rouge">CLI</code> 를 처음 접했던 나는 정말 적응하기가 힘들었다. 하지만 사용하면 사용 할 수록, 그가 왜 이러한 운영체제를 만들었고, 어떤생각을 하고있는지 이해를 하기 시작했고, 사람에대한 관심이 생겨 찾아보다 <code class="language-plaintext highlighter-rouge">Ted talk</code> 에서 이야기 한 것을 보게되었고, 그에따른 이야기를 조금 해보려고 한다.</p>

<h2 id="who-is-linus">Who is Linus?</h2>

<p>리누스가 뭐하는 사람인가. 이름에서 알 수 있다시피 <code class="language-plaintext highlighter-rouge">Linux</code> 를 만든사람이다.</p>

<blockquote>
  <p>대학교때 교수님이 만든 OS를 다듬다 만들었다고 한다… ㄷㄷ</p>
</blockquote>

<p>그리고 무려 <code class="language-plaintext highlighter-rouge">Git</code> 을 만든 사람이다..!! 즉 오픈소스의 창시자라고 할 수 있는 사람이다. 아마 컴퓨터 공학도가 아니라면 체감이 안되겠지만, 이 사람이 없었더라면 다시말해서 <code class="language-plaintext highlighter-rouge">Linux</code> 와 <code class="language-plaintext highlighter-rouge">Git</code> 이 없었더라면 아마 현재는 우리가 살고있는 현재와 많이 다를 것이다. 일단 <code class="language-plaintext highlighter-rouge">Linux</code> 기반의 소프트웨어가 존재하지 않는다는점 -&gt; 우리의 일반적인 휴대폰이나 태블릿 기타등등 얼마나 퇴화했을지 모르는것이고, 오픈소스가 없었다면 개발자들이 아직도 책으로 공부하며 <code class="language-plaintext highlighter-rouge">Peer evluation</code>, 혹은 <code class="language-plaintext highlighter-rouge">code review</code> 없이 개발을 했을지도 모른다. 하지만 깃의 개발을 통해 우리가 좀 더 쉽게 누구나 어떤 코드에 접근 할 수 있게 되었다. 그리고 이러한 개발을 한 그의 사상은 역시나 남들과 다른데 한번 들어보자.</p>

<h2 id="ted-talk">Ted Talk</h2>

<p>21분짜리 Ted Talk를 듣고있으면, 상당히 딴소리도 많이 한다. 자신의 근무환경이 어떻고, 부실하며, 개그도 치고 자신의 신념에 대해서도 말한다.</p>

<blockquote>
  <p>고양이 그르릉 소리를 들어야돼서 컴퓨터가 팬 소음이 심하면 안된다고 한다… ㅋㅋ</p>
</blockquote>

<p>조금 더 본론으로 들어가, 자신이 어떻게 깃허브를 만들게 되었는지 설명하는 부분이 나온다. 애초에 리눅스가 협업을 해서 만든 프로젝트가 아니라고 설명하고, 거의 프로젝트가 완성이 되었을 때, 남들에게 보여주고 comment 를 받기 위해 만들었다고 한다. 처음에는 물론 <code class="language-plaintext highlighter-rouge">아 이게 상업적 용도로 쓰이면 어떡하지?</code> 라는 생각도 했다고 한다. 그럼에도 남들이 사용을 해보고, 누구나 <code class="language-plaintext highlighter-rouge">PR</code> 을 넣어서 수정을 할 수 있다는 장점이 더 크다고 판단해 만들었다고 한다. 그리고 여기서 리누스의 개그가 나오는데, 사실 깃은 사람들과 소통을 하기 위해서 만든게 아니라 소통을 피하기 위해 만들었다고 한다. 잉?? 이게 무슨 말일까.. 리누스의 명언을 보면 이해가 된다</p>

<p><code class="language-plaintext highlighter-rouge">Talk is cheap. Show me the code.</code></p>

<p>실제로 리누스가 깃을 만들 때, 21살이여서 사람 만나는거를 별로 안좋아 했다고 한다. MBTI는 I로 시작하는게 분명하다. 그래서 자랑을 하거나 리뷰를 받을 때도, 실제로 만나는것 보다, 사람이 사용해보고 코드로 review 를 해줄 수 있는 방법을 고안하다 나온 방법인 것 같다. 정말 컴퓨터 공학과인 사람이 생각할 만한 이유이고, 나도 너무나도 공감이 된다. 즉 본인이 깃허브를 만든 이유는 오직 리눅스를 만들다 우연히 만든거라고 했다.</p>

<blockquote>
  <p>근데 우연히 만든게 모든 세상 개발자의 중심지가 될줄이야..</p>
</blockquote>

<p>그리고 리누스의 어린시절 이야기도 잠깐 언급된다. 자신은 코딩을 10살 때 부터 했고, 똑똑한 편은 아니였다. 똑똑하다기 보다는 자신에게 생긴 일에 고집이 쎄고 자부심이 강했으며, 한번 시작한 일을 끝날 때 까지 놓지 않는 성격이라고 했다. 하지만 제 3자인 내가 보았을 때 리누스는 성공하는 개발자의 덕목을 모두 가지고 있는 것 처럼 보였다. 우선, 한번 일을 시작하면 고집마냥 틀어박혀서 끝날 때 까지 나오지 않는것, 그리고 호기심이 생기면 어떻게 해서든 해결을 하려고 하는것. 그리고 말만 그렇게 하였지, 개발에 대한 재능도 엄청나다고 생각한다. 어떤 재능없는 사람이 21살에 자신만의 OS 를 개발 할 수 있겠는가.</p>

<p>그리고 특히 더 대단한 것은, 보통 일반인으 개발자의 수명이 30중반 까지라고 한다. 그 이후가 되면, 머리도 굳고 힘에 부쳐 많이들 힘들어 한다고 한다. 그래서 보통 그 이후 SI 직군이나 소프트웨어 공학쪽으로 더 빠진다고 한다. 하지만 리누스의 개인 깃허브를 보면, 아직까지도 거의 매일매일 리눅스에대한 개발을 하고있다. 여전히 많은 사람들이 PR을 남겨주고, 매일매일 확인하며 그에 상응하는 대응을 해준다. 이정도의 부와 명예를 가지고 있다면, 충분히 다른 일을 찾아 나설 수 도 있지만, 본인이 이러한 개발을 좋아하고 보다 완벽한 것을 추구하기 떄문이라고 보인다.</p>

<p><code class="language-plaintext highlighter-rouge">Ted Talk</code> 중간에 코드를 잠깐 보여주고 어떤것이 좋은 코드인가에 대한 설명을 잠깐 한 적이 있다. 우선 코드를 한번 확인해 보자</p>

<pre><code class="language-C">remove_list_entry(enrty) {
	prev = NULL;
	walk = head;

	//Walk the list

	while (walk != entry) {
		prev = walk;
		walk = walk-&gt;next;
	}

	//Remove the entry by updating head or previous entry

	if (!prev)
		head = entry-&gt;next;
	else
		prev-&gt;next = entry-&gt;next;
}
</code></pre>

<pre><code class="language-C">remove_list_entry(entry) {
	//The "indirect" pointer points to the
	//address of the thing we'll update

	indirect = &amp;head;

	//Walk the list, looking for the thing that
	//points to the entry we want to remove

	while((*indirect) != entry)
		indirect = &amp;(*indirect)-&gt;next;

	//and remove
	*indrect = entry-&gt;next;
}
</code></pre>

<p>하단에 있는 코드는 실제로 리눅스에 있는 링크드 리스트에서 한 리스트를 삭제를 하는 과정을 보여주는 코드이다. 어떻게 보면 두 코드가 동일해 보이고, 실제로 동작을 하는 모습은 동일하다. 그리고 보통 우리는 첫번째 방법으로 코딩을 많이 한다. 포인터를 쓰는것이 아니라, 노드 두개를 가지고 하나씩 옮겨가며 삭제할 곳 까지 찾아간 다음 삭제하고 연결을 해주는 과정이다. 실제로 내가 보기에도 첫번째가 좀 더 보기가 쉽고, 직관적이라 생각을 했다.</p>

<blockquote>
  <p>내가 아직 코딩을 못해서 그런걸지도 모르지만, 아직도 포인터와 주소값을 왔다갔다하면 헷갈린다</p>
</blockquote>

<p>하지만 리누스는 오히려 두번째가 더 좋은 코드라고 설명을 한다. 애초에 <code class="language-plaintext highlighter-rouge">if</code>를 쓰지 않고도 할 수 있고, 예외처리가 아예 필요가 없어지는 경우라고 한다. 내가 한국어로 표현을 잘 못해 직접 내용을 인용해 오겠다.</p>

<p><code class="language-plaintext highlighter-rouge">that sometimes you can see a problem in a different way, and rewrite it so that a special case goes away and becomes the normal case. And that's the good code</code></p>

<p>즉 한 문제에 대해서 갇혀있는 생각만 하지말고, 다양한 생각과 다양한 시각으로 보면 더 간편하고 직관적이며, 효율이 좋은 코드가 나올 수 있다는 것이다.
항상 생각을 하고 행동을 하라는 의미로 받아들이고 싶다.</p>

<p>오늘은 컴퓨터공학의 정말 중요한 인물인 리누스 토르발스에 대해서 알아보았는데, 정말 배울점이 많고, 신념이 뚜렷한 사람 같아서 정말 보기 좋다. 이 테드영상 이후로도 몇가지의 영상을 찾아보았는데, 정말 자부심이 강하고 멋진 사람이라고 생각한다. 나도 언젠가 이렇게 자신의 신념을 가지고 행동 할 수 있으며, 그에 따른 무게의 책임질 수 있는 사람이 되고싶다.</p>]]></content><author><name>071yoon</name></author><category term="deep-thought" /><category term="deep thought" /><category term="linux" /><category term="philosophy" /><summary type="html"><![CDATA[Talk is cheap. Show me the code.]]></summary></entry><entry><title type="html">SQL 예제를 풀어보자</title><link href="http://localhost:4000/sql/2022/01/24/sql-practice.html" rel="alternate" type="text/html" title="SQL 예제를 풀어보자" /><published>2022-01-24T00:00:00+09:00</published><updated>2022-01-24T00:00:00+09:00</updated><id>http://localhost:4000/sql/2022/01/24/sql-practice</id><content type="html" xml:base="http://localhost:4000/sql/2022/01/24/sql-practice.html"><![CDATA[<h2 id="why-sql">Why SQL?</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">SQL</code>은 내가 데이터베이스 강의를 들을 때 잠깐 만져보고 처음 본 <code class="language-plaintext highlighter-rouge">Query</code> 언어이다. 그 당시에 효율이 정몰 좋고 데이터베이스 관리를 위해서 꼭 사용해야 하는 언어라고 배웠고, 실제로 <code class="language-plaintext highlighter-rouge">MariaDB</code> 를 활용한 웹을 만들어 보면서 왜 사용해야되는지 배워보았다. 그리고 <code class="language-plaintext highlighter-rouge">SQl</code> 을 펼쳐보지도 않은지 거의 두 세달 이 되어서, S/W Maestro 관련 글을 보던 중 코딩테스트에 <code class="language-plaintext highlighter-rouge">SQL</code>이 나온다는 소식을 들었다… ㅜㅜ 그래서 어쩔 수 없이 <code class="language-plaintext highlighter-rouge">SQL</code> 문제들을 살펴보던 중 프로그래머스에 <code class="language-plaintext highlighter-rouge">SQL</code> 문제들이 올라와 있는걸 보았고, 기본기를 다지는데 훌륭하다고 하여서 한번 풀어보기로 했다.</p>

<blockquote>
  <p>그리고 어차피 한번 리마인드 할 때 됐다!!</p>
</blockquote>

<p>문제풀기를 진행하며 까다로웠던 부분들을 다시 보자</p>

<h2 id="select">SELECT</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">SELECT</code>는 <code class="language-plaintext highlighter-rouge">SQL</code>을 처음 배우면 나오는 문법이다. 그냥 찾아주는거고 여기서 뭐 어려운 것은 없다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_ID</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
<span class="k">WHERE</span> <span class="n">ANIMAL_ID</span> <span class="o">&gt;</span> <span class="mi">100</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="nb">DATETIME</span> <span class="k">ASC</span> <span class="o">#</span><span class="k">DESC</span>
<span class="n">LMIIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>이런식으로, 찾는다 -&gt; 어디서? -&gt; 어떻게? 이런식으로 주면 된다</p>

<h2 id="count">COUNT</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">COUNT(*)</code> 로 무엇의 개수를 셀 지 정할 수 있다.
중요한점은 <code class="language-plaintext highlighter-rouge">GROUP BY</code> 로 어떤것의 개수를 어떤 그룹으로 쪼개서 계산할 지 할 수 있고, 같은것을 세기가 싫다면 <code class="language-plaintext highlighter-rouge">COUNT(DISTINCT NAME)</code> 이런식으로 할 수 도 있다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">HOUR</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span> <span class="k">as</span> <span class="n">HOUR</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span> <span class="k">as</span> <span class="k">COUNT</span>
<span class="k">FROM</span> <span class="n">ANIMAL_OUTS</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">HOUR</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span> <span class="k">HAVING</span> <span class="n">HOUR</span> <span class="o">&gt;=</span> <span class="mi">9</span> <span class="k">AND</span> <span class="n">HOUR</span> <span class="o">&lt;=</span> <span class="mi">19</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">HOUR</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span>
</code></pre></div></div>

<p>09:00부터 19:59까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문</p>

<h2 id="is-null">IS NULL</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">NULL</code> 문은 특징이 있다. 우선 단독으로 <code class="language-plaintext highlighter-rouge">Something = 'NULL'</code> 이런식으로 사용 할 수 없고, <code class="language-plaintext highlighter-rouge">Something is NULL</code> 이런식으로 사용해야 알아듣는다. 생각해보면 당연한 것</p>

<p>그리고 만약 <code class="language-plaintext highlighter-rouge">NULL</code> 이면 이러한 구문을 넣어라 이런것도 가능하다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_TYPE</span><span class="p">,</span> <span class="n">IFNULL</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="nv">"No name"</span><span class="p">)</span> <span class="k">as</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">SEX_UPON_INTAKE</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
</code></pre></div></div>

<p>이렇게 하면 만약 <code class="language-plaintext highlighter-rouge">Name</code> 에 <code class="language-plaintext highlighter-rouge">NULL</code> 이라면 <code class="language-plaintext highlighter-rouge">No name</code> 이 들어가게 된다.</p>

<h2 id="join">JOIN</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">SQL</code>의 꽃이라고 할 수 있는 <code class="language-plaintext highlighter-rouge">JOIN</code> 문이다. 간단하게 말하면 두 테이블을 합쳐주는 것인데, 합치는 과정에서 어떤식으로 문제를 찾을 지 정할 수 있는 방법이 무궁무진하기 떄문에, 만약 제대로 알고 가지 못한다면 어려워 질 수 있다. 실제로 내가 공부를 할 때는 <code class="language-plaintext highlighter-rouge">Natural JOIN</code> 으로 다 풀었었는데, 문제에서는 다 특이한 방법으로 값들을 찾으라 해서 조금 까다로웠다.</p>

<p><code class="language-plaintext highlighter-rouge">OUTS</code> 에는 있지만 <code class="language-plaintext highlighter-rouge">INS</code> 에는 없는 데이터 출력</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">NAME</span>
<span class="k">FROM</span>
    <span class="n">ANIMAL_INS</span> <span class="k">AS</span> <span class="n">INS</span>
<span class="k">RIGHT</span> <span class="k">JOIN</span>
    <span class="n">ANIMAL_OUTS</span> <span class="k">AS</span> <span class="n">OUTS</span>
<span class="k">ON</span>
    <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="o">=</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span>
<span class="k">WHERE</span>
    <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>보호소에서 중성화 즉 Intact -&gt; Neutered or Sapyed가 된 경우 찾기</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_TYPE</span><span class="p">,</span> <span class="n">INS</span><span class="p">.</span><span class="n">NAME</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span> <span class="n">INS</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">ANIMAL_OUTS</span> <span class="n">OUTS</span>
<span class="k">ON</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="o">=</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span>
<span class="k">WHERE</span> <span class="n">INS</span><span class="p">.</span><span class="n">SEX_UPON_INTAKE</span> <span class="k">LIKE</span> <span class="s1">'Intact%'</span> <span class="k">AND</span> <span class="p">(</span><span class="n">OUTS</span><span class="p">.</span><span class="n">SEX_UPON_OUTCOME</span> <span class="k">LIKE</span> <span class="s1">'Neutered%'</span> <span class="k">OR</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">SEX_UPON_OUTCOME</span> <span class="k">LIKE</span> <span class="s1">'Spayed%'</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ANIMAL_ID</span>
</code></pre></div></div>

<h2 id="string-date">STRING, DATE</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">CASE</code> 를 나눠서 만약 1번이면 <code class="language-plaintext highlighter-rouge">X</code> 2번이면 <code class="language-plaintext highlighter-rouge">O</code> 를 출력하는 테이블을 만들 수 있다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span>
<span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">SEX_UPON_INTAKE</span> <span class="k">LIKE</span> <span class="s1">'Neutered%'</span> <span class="k">OR</span> <span class="n">SEX_UPON_INTAKE</span> <span class="k">LIKE</span> <span class="s1">'Spayed%'</span> <span class="k">THEN</span> <span class="s1">'O'</span> <span class="k">ELSE</span> <span class="s1">'X'</span> <span class="k">END</span> <span class="k">AS</span> <span class="s1">'중성화'</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ANIMAL_ID</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DATE</code> 를 뺼 때, 두가지 경우가 있는데 <code class="language-plaintext highlighter-rouge">DATEDIFF</code> 함수를 사용해서, 실제로 차이가 얼마나 나는지 원하는 데이터 타입으로 찾을 수 있고 아니면 그냥 변수마냥 빼도 알아서 게산을 해준다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">INS</span><span class="p">.</span><span class="n">NAME</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span> <span class="n">INS</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">ANIMAL_OUTS</span> <span class="n">OUTS</span>
<span class="k">ON</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="o">=</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">OUTS</span><span class="p">.</span><span class="nb">DATETIME</span> <span class="o">-</span> <span class="n">INS</span><span class="p">.</span><span class="nb">DATETIME</span> <span class="k">DESC</span>
<span class="k">LIMIT</span> <span class="mi">2</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DATE</code> 에는 내장 함수들이 많은데, 그 중에 <code class="language-plaintext highlighter-rouge">DATE_FORMAT</code> 을 통해 내가 원하는 형식을 지정 해 줄 수 도 있다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">DATE_FORMAT</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">,</span> <span class="s1">'%Y-%m-%d'</span><span class="p">)</span> <span class="k">as</span> <span class="s1">'날짜'</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ANIMAL_ID</span>
</code></pre></div></div>

<p>이렇게 하면 내가 원하는 YEAR-MONTH-DAY 형식으로 출력이 된다.</p>

<blockquote>
  <p>{Y,y} {M,m} {D,d} 모두 형식이 다르다. [문자열 vs 숫자]</p>
</blockquote>]]></content><author><name>071yoon</name></author><category term="sql" /><category term="sql" /><category term="qeury" /><summary type="html"><![CDATA[Why SQL?]]></summary></entry><entry><title type="html">바닐라JS로 앱 만들기 2</title><link href="http://localhost:4000/javascript/2022/01/22/javascript-coding-2.html" rel="alternate" type="text/html" title="바닐라JS로 앱 만들기 2" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/22/javascript-coding-2</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/22/javascript-coding-2.html"><![CDATA[<h2 id="자바스크립트를-browser로-로딩하기">자바스크립트를 Browser로 로딩하기</h2>

<hr />

<h3 id="document-object"><code class="language-plaintext highlighter-rouge">document</code> Object</h3>

<p><code class="language-plaintext highlighter-rouge">console</code>에 <code class="language-plaintext highlighter-rouge">document</code>를 쓰면, 이미 정의되어 있는 함수인걸 알 수 있다.
그럼 html 에서 <code class="language-plaintext highlighter-rouge">block</code>으로 지정한 부분을 자바스크립트에서 바로 가져올 수 있다.</p>

<blockquote>
  <p>ex) <code class="language-plaintext highlighter-rouge">document.title</code> -&gt; 내가 지정한 HTML 의 title</p>
</blockquote>

<p>즉 이렇게 하면 HTML 의 코드를 자바스크립트의 관점에서 볼 수 있게된다</p>

<p>그럼 다른 block 에서 <code class="language-plaintext highlighter-rouge">id</code>로 가져오려면 어떻게 해야될까??</p>

<p>HTML 에서 <code class="language-plaintext highlighter-rouge">&lt;h1 id="name"&gt;Name&lt;/h1&gt;</code> 이런식의 블럭이 있다면 간단하게 <code class="language-plaintext highlighter-rouge">document.getElementById("name")</code> 이런식으로 호출 할 수 있다.</p>

<blockquote>
  <p>주의할점! <code class="language-plaintext highlighter-rouge">getElementById</code> 는 특정항목 하나만 가져오기 때문에 변수 하나에 저장되지만, <code class="language-plaintext highlighter-rouge">getElementByClass</code> 혹은 <code class="language-plaintext highlighter-rouge">getElementByTag</code> 는 여러 값들을 가져오기 때문에 배열로 할당되어 저장된다</p>
</blockquote>

<p>하지만 가장 많이 사용하는 것은 <code class="language-plaintext highlighter-rouge">querySelector</code>라고 한다. 하나만 가져오고 가져오는것 중 하나를 CSS형태로 선택 할 수 있어서 가장 깔끔하고 보기 편하다고 한다. 그리고 만약 겹친다면 첫번 째 나오는 element 만 가져온다!!</p>

<ul>
  <li>
    <p>배열로 가져오려면 <code class="language-plaintext highlighter-rouge">quertySelectorAll</code>을 사용하면된다.</p>

    <p><code class="language-plaintext highlighter-rouge">document.querySelector('.class_name block')</code></p>

    <p><code class="language-plaintext highlighter-rouge">docuemnt.querySelector('.class_name block:first-child)</code> 도 가능하다</p>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">document.querySelector("#id")</code> 는 <code class="language-plaintext highlighter-rouge">document.getElementById("hello")</code> 와 동일하다</p>
</blockquote>

<p>그럼 이렇게 호출된 <code class="language-plaintext highlighter-rouge">name</code> 은 <code class="language-plaintext highlighter-rouge">name.innerText()</code> 함수를 통해 안에 있는 내용을 변경 할 수 있게 해준다.</p>

<h3 id="events">Events</h3>

<p><code class="language-plaintext highlighter-rouge">variable.addEventListener("event", function);</code> 으로 선언을 해주면, 어떠한 event 를 할 때마다 function을 실행 해 줄것이다. event의 예로는 click, hover 기타등등이 있다. <code class="language-plaintext highlighter-rouge">console.dir</code> 으로 어떠한 함수들이 있는지 확인 할 수 있다.</p>

<blockquote>
  <p>function을 호출할 떄 함수의 이름만 호출함에 주의! function()이렇게 아예 실행하도록 주지않고, 이름만 넘겨줘서 Event가 발생 시 function 을 실행하도록 한다</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">HTMLHeadingElement</code> 에 들어가서 어떠한 API 들을 사용 할 수 있는지 확인을 해봐도 된다.</p>

<p>혹은 <code class="language-plaintext highlighter-rouge">variable.on'event' = function</code> 이런식으로 선언을 해도 같은식으로 동작하게 만들 수 있다</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">Event</code>의 특징으로 또 강력한 것은 <code class="language-plaintext highlighter-rouge">Window</code> 객체에서 불러 올 수 있다는 것이다. <code class="language-plaintext highlighter-rouge">Window</code>는 현재 실행을 하는 그 화면을 말하는 것이고, 그 화면에서 정말 많은것을 구현 할 수 있다. 예를들어 <code class="language-plaintext highlighter-rouge">resize</code> 로 윈도우 크기를 조절하고 있을때의 이벤트, 혹은 <code class="language-plaintext highlighter-rouge">copy</code>, <code class="language-plaintext highlighter-rouge">offline</code> 등등 정말 많은 이벤트들이 구현되어 있고, 우리는 사용만 하면 된다!!</p>

<p>내가 만약 <code class="language-plaintext highlighter-rouge">class</code> 를 받아와서 사용중에 있는데, 현재 내가 사용하고 있는 클래스는 폰트지정 클래스이고, 색변환 클래스를 추가하고 싶으면 어떻게 사용해야 될까??</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleCheck</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">clickedClass</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">clicked</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">clickedClass</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">clickedClass</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">clickedClass</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 사용할 수 있다. 그럼 원래 있던 클래스 <code class="language-plaintext highlighter-rouge">class = "test"</code> 라 두면 추가되면 <code class="language-plaintext highlighter-rouge">class = "test clicked"</code> 이렇게 되고 remove시 <code class="language-plaintext highlighter-rouge">class = "test"</code> 이렇게 돌아갈 것이다. 이런식으로 클래스의 중첩이 가능하다!!</p>

<p>이걸 편하게 해주는것이 <code class="language-plaintext highlighter-rouge">toggle function</code> 은 어떤 역할이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleCheck</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">toggle</span><span class="p">(</span><span class="dl">"</span><span class="s2">clicked</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 한번에 해결 할 수 있다.</p>

<p>즉 toggle 은 이미 있는지 확인을 해서, 있다면 삭제하고 없다면 생성해주는 불을 키고 끄는것과 비슷한 행동을 해주는 함수라 할 수 있다.</p>

<p>다음 포스트부터는 실제로 코드를 작성해서 VanillaJS 앱을 만들어보겠다</p>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[자바스크립트를 Browser로 로딩하기]]></summary></entry><entry><title type="html">바닐라JS로 앱 만들기 1</title><link href="http://localhost:4000/javascript/2022/01/22/javascript-coding-1.html" rel="alternate" type="text/html" title="바닐라JS로 앱 만들기 1" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/22/javascript-coding-1</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/22/javascript-coding-1.html"><![CDATA[<h2 id="자바스크립트-실습">자바스크립트 실습</h2>

<hr />

<p>자바스크립트의 이론적인 부분에 대해서는 공부를 대충 해봤지만, 실생활에 어떤식으로 사용할 지, 혹은 어떤식으로 프로젝트를 진행할 지에 대해서 너무 무지했기 떄문에, 처음에는 강의에 의존을 해보기로 결정했다. 여러 자바스크립트 강의를 찾던 도중, <code class="language-plaintext highlighter-rouge">노마드코더</code>가 자바스크립트를 처음 접하기 좋다는 소식을 들어 이 사이트에서, 바닐라JS로 크롬 앱 만들기 강의를 시작해보기로 결정했다.</p>

<h3 id="why-javscript">Why Javscript?</h3>

<hr />

<p>왜 우리는 자바스크립트를 사용할까??</p>

<p>사실 자바스크립트는 그렇게 좋은 언어는 아니다. <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">var</code> 등등 (요새는 <code class="language-plaintext highlighter-rouge">var</code>를 안쓴다고 하긴 하더라) 데이터 타입을 명시해주는것 부터, 문법등을 보면 그렇게 멋진 언어는 아니다. 개인적으로 C언어가 완벽에 가까운 언어라고 생각을 하는데 (개발자의 역량에 따라 시간을 투자하면 원하는만큼 다 구현이 가능하니까) 왜 자바스크립트를 사용할까?? 사실 어쩔 수 없다는게 맞는 표현이다. 문제는 처음부터 웹을 만들 떄 자바스크립트를 사용했다는 것…! 애초부터 급조한 언어였기 때문에, 문제가 많았다.</p>

<blockquote>
  <p>실제로 10일만에 만든 언어라고 한다!</p>
</blockquote>

<p>하지만 이미 많은 사람들이 웹에서 자바스크립트를 사용하였기에, 갑자기 언어를 바꿔버리면 웹에 마비가 올 수 있다는 생각에 그냥 해당 자바스크립트를 두고 패치를 계속 진행을 하며, 현재의 자바스크립트까지 왔다고 한다. 즉 자바스크립트는 현재 웹에서 <code class="language-plaintext highlighter-rouge">대체불가언어</code> 라고 해도 과언이 아닐정도로 모든 웹에서 사용중이며, 우리가 배워야 하는 이유이다. 너무 싫어서 사용하기 싫다고 하더라도 웹쪽으로 커리어를 생각중이라면 어쩔 수 없이 배워야 하는 언어..? 정말 애증의 언어가 아닐 수 없다. 물론 요즘은 그런점들을 보완하며, 같이 상용이 가능한 <code class="language-plaintext highlighter-rouge">typescript</code>의 존재로 이러한 원성들을 조금이나마 잠재워 주고 있는듯 보인다.</p>

<h3 id="project의-시작">Project의 시작</h3>

<hr />

<p>옛날에 웹디자인을 공부 할 때, 해봤지만 너무 옛날이라 기억도 안나고 역시 정리를 안해두니 찾아보기가 힘들어 이번에는 조금 정리를 하면서 진행을 해보려고 한다.</p>

<p>우선 웹을 배우려면 <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">Javascript</code> 이 3개의 연관성에 대해서 조금이나마 알고 가야한다. <code class="language-plaintext highlighter-rouge">CSS</code> 와 <code class="language-plaintext highlighter-rouge">Javascript</code> 는 일반적으로 혼자 작동할 수 없는 언어이다. 즉 <code class="language-plaintext highlighter-rouge">HTML의 의존성을 가진 파일들</code> 이라고 할 수 있다. 아무리 이쁜 디자인을 <code class="language-plaintext highlighter-rouge">CSS</code> 에서 진행을 하고 얼마나 멋진 함수들을 <code class="language-plaintext highlighter-rouge">Javscript</code> 에서 구현을 했다 한들, 실제 보여지지않으면 의미가 없고, 이러한것들을 가시적으로 보여주면서 동작하게하는 것이 <code class="language-plaintext highlighter-rouge">HTML</code>이라고 보면 되겠다. 어떻게 연결하는지 기본적인 HTML을 보며 살펴보자</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"style.css"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>momentum<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"script.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>이런식으로 <code class="language-plaintext highlighter-rouge">stylesheet</code>를 <code class="language-plaintext highlighter-rouge">style.css</code>로 두고 <code class="language-plaintext highlighter-rouge">script</code>를 <code class="language-plaintext highlighter-rouge">script.js</code> 로 두어 링크를 했다고 보면 되겠다.</p>

<blockquote>
  <p>주의할점! <code class="language-plaintext highlighter-rouge">script.js</code> 는 <code class="language-plaintext highlighter-rouge">body</code>의 끝에 주로 둔다. WHY? 왜냐하면 보통 사이즈가 큰 파일들은 <code class="language-plaintext highlighter-rouge">script.js</code>에 들어가 있고, 인터넷 속도가 느려서 자바스크립트파일을 다운받는데 오래 걸린다면, 그 전에 화면에 출력할 것을 먼저 다운받지 못해 빈 화면을 출력하고, 자바스크립트를 다운 다 받은 후 출력을 하기때문. 즉 유저의 편의를 좀 봐주자</p>
</blockquote>

<h3 id="data-types">Data Types</h3>

<hr />

<p>일단 자바스크립트는 <code class="language-plaintext highlighter-rouge">syntax</code>가 세개밖에 없다. <code class="language-plaintext highlighter-rouge">const, let, var</code> 심지어 <code class="language-plaintext highlighter-rouge">var</code> 는 잘 쓰지 않으므로 <code class="language-plaintext highlighter-rouge">const</code> 와 <code class="language-plaintext highlighter-rouge">let</code> 두개가 있다고 해도 무방하다.</p>

<blockquote>
  <p>심지어 파이썬은 저것조차 안써도 된다</p>
</blockquote>

<p>그럼 데이터타입을 알아서 정해준다는 것이다. 그럼 문제가 무엇이냐?? 언제 정수에서 문자형으로 바뀌는것이고, 문자열로 바뀌는지 프로그램이 정해주기 때문에 정할 수 없다는 것이다. 그래서 새로운 <code class="language-plaintext highlighter-rouge">typescript</code> 라고 자바스크립트에서 <code class="language-plaintext highlighter-rouge">type</code> 형식을 지정해주는 변형된 언어가 탄생을 했다.</p>

<p>그럼 요새 사용은 안하는 <code class="language-plaintext highlighter-rouge">var</code> 형식은 언제 사용하는것일까? 사실 사용을 잘 안한다. <code class="language-plaintext highlighter-rouge">var</code> 는 처음에 만들어진 변수 선언 type 이고, 어디서나 재정의가 가능하다는 장점이 있지만, 사실이건 매우 위험하고 차라리 다른 변수명을 선언하는게 훨씬 낫다. 그래서 요새는 <code class="language-plaintext highlighter-rouge">let</code> 과 <code class="language-plaintext highlighter-rouge">const</code>로 대체해서 사용한다.</p>

<p>자바스크립트에서 특이한것이 있는데, <code class="language-plaintext highlighter-rouge">null</code> 과 <code class="language-plaintext highlighter-rouge">undefined</code> 가 두개나 존재한다는 것이다. <code class="language-plaintext highlighter-rouge">null</code>은 내가 지정을 해 줘서 비어있을 때 <code class="language-plaintext highlighter-rouge">null</code> 인것이고, <code class="language-plaintext highlighter-rouge">undefined</code>는 내가 만약 <code class="language-plaintext highlighter-rouge">let variable;</code> 을 해주고 지정을 안해주면 <code class="language-plaintext highlighter-rouge">undefined</code> 라고 나오게 된다.</p>

<blockquote>
  <p>즉 null 은 비어있는것이고, undefined는 변수이지만 값이 없는것</p>
</blockquote>

<p>그리고 자바스크립트 배열에는 C 혹은 C++ 과 다른 특이점이 있다. 나의 테스트케이스를 보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">test</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">test</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="dl">"</span><span class="s2">c</span><span class="dl">"</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">test</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">test</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">test2</span><span class="dl">"</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">test</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="k">typeof</span> <span class="nx">test</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>특이한 점 1 : 배열의 type 은 각 항목마다 다르다</p>
</blockquote>

<blockquote>
  <p>특이한 점 2 : 만약에 7번을 만들면 자동으로 배열의 크기가 8로 늘어나고, 5 6 7 번은 undefined로 정의된다</p>
</blockquote>

<h3 id="비교연산자">비교연산자</h3>

<hr />

<p>타 언어들을 보면 비교연산자로 <code class="language-plaintext highlighter-rouge">==</code> 밖에 쓰지 않는데, 자바스크립트는 특이하게 <code class="language-plaintext highlighter-rouge">===</code> 를 주로 사용한다. 그렇다고해서 <code class="language-plaintext highlighter-rouge">==</code> 가 없다는 것은 아니다. 차이점은 <code class="language-plaintext highlighter-rouge">==</code> 은 값만 비교하는 것이고 <code class="language-plaintext highlighter-rouge">===</code> 는 <code class="language-plaintext highlighter-rouge">type</code> 까지 묶어서 비교를 한다는 점이다. 즉 <code class="language-plaintext highlighter-rouge">5 == '5'</code> 는 참이지만 <code class="language-plaintext highlighter-rouge">5 === '5'</code> 는 거짓이라는 것.</p>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[자바스크립트 실습]]></summary></entry><entry><title type="html">자바스크립트 객체 프로퍼티 설정</title><link href="http://localhost:4000/javascript/2022/01/20/javascript-property.html" rel="alternate" type="text/html" title="자바스크립트 객체 프로퍼티 설정" /><published>2022-01-20T00:00:00+09:00</published><updated>2022-01-20T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/20/javascript-property</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/20/javascript-property.html"><![CDATA[<h1 id="객체-프로퍼티">객체 프로퍼티</h1>

<p>프로퍼티란 단순히 <code class="language-plaintext highlighter-rouge">key-value</code> 가 아닌 더 유연한 자료구조로 사용 될 수 있으며, <code class="language-plaintext highlighter-rouge">getter</code>와 <code class="language-plaintext highlighter-rouge">setter</code> 등에 대해서 학습해보자</p>

<h2 id="프로퍼티-플래그와-생성자">프로퍼티 플래그와 생성자</h2>

<p>객체 프로퍼티는 값과 플래그라는 속성을 가진다</p>
<ul>
  <li>writable - true 라면 수정이 가능하다</li>
  <li>enumerable - true 라면 반복문으로 나열 할 수 있다</li>
  <li>configurable - true 라면 삭제나 플래그 수정이 가능하다</li>
</ul>

<p>평범한 방식으로 설계를 한다면, 프로퍼티는 모두 <code class="language-plaintext highlighter-rouge">true</code>이며, 언제든 수정 될 수 있다</p>

<p><code class="language-plaintext highlighter-rouge">let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);</code></p>

<p>여기서</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">obj</code> 란 정보를 얻고자 하는 객체</li>
  <li><code class="language-plaintext highlighter-rouge">propertyName</code> 이란 정보를 얻고자 하는 객체 내 프로퍼티
를 말한다</li>
</ul>

<p>예시</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">alert</span><span class="p">(</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">);</span>
<span class="cm">/* property descriptor:
{
  "value": "Yoon",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
*/</span>
</code></pre></div></div>

<p>이 상태에서 <code class="language-plaintext highlighter-rouge">Object.defineProperty</code>로 플래그를 변경 할 수 있다</p>

<h2 id="getter-와-setter">getter 와 setter</h2>

<p>객체의 프로퍼티를 나누는 두 분류로 볼 수 있다.</p>
<ol>
  <li>데이터 프로퍼티 -&gt; 현재까지 모두 사용한 프로퍼티</li>
  <li>접근자 프로퍼티 -&gt; 새로운 종류로, 함수의 값을 획득하고 설정하는 역할을 담당한다</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nx">propName</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// getter, obj.propName실행시</span>
  <span class="p">},</span>

  <span class="kd">set</span> <span class="nx">propName</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// setter, obj.propName = value실행시</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>그럼 이걸 어떤식으로 활용 할 수 있을까??</p>

<p><code class="language-plaintext highlighter-rouge">getter</code>와 <code class="language-plaintext highlighter-rouge">setter</code>를 실제 프로퍼티 값을 감싸는 래퍼로 사용하여, 프로퍼티 값을 통제하는 방법이 있다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nx">name</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="kd">set</span> <span class="nx">name</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Too Short</span><span class="dl">"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Yoon</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span> <span class="c1">// 너무 짧은 이름을 할당하려 함</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">user</code>의 이름이 <code class="language-plaintext highlighter-rouge">_name</code>에 저장되어, 프로퍼티에 접근하는것이 <code class="language-plaintext highlighter-rouge">getter</code> 와 <code class="language-plaintext highlighter-rouge">setter</code>로 이루어진다.</p>

<blockquote>
  <p>솔직히 왜 사용하는지 이해는 되지 않지만, 그냥 이런게 있구나~ 하고 넘어가고 이후에 다시 확인해보기로 하자</p>
</blockquote>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="typescript" /><category term="TIL" /><category term="property" /><summary type="html"><![CDATA[객체 프로퍼티]]></summary></entry></feed>