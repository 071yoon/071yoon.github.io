<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-06-04T22:07:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YeongGi’s tech blog</title><subtitle>This is YeongGi's tech blog. I post IT related items.</subtitle><author><name>071yoon</name></author><entry><title type="html">CSS의 역사</title><link href="http://localhost:4000/css/2022/05/31/css-history.html" rel="alternate" type="text/html" title="CSS의 역사" /><published>2022-05-31T00:00:00+09:00</published><updated>2022-05-31T00:00:00+09:00</updated><id>http://localhost:4000/css/2022/05/31/css-history</id><content type="html" xml:base="http://localhost:4000/css/2022/05/31/css-history.html"><![CDATA[<center>CSS 트렌드</center>

<p><img src="https://user-images.githubusercontent.com/66371206/171093573-f5758d9a-6ff3-44e8-aa86-8c52ad983c93.png" alt="image" /></p>

<center>(출처: oliverturner's twitter)</center>

<h2 id="traditional-css">Traditional CSS</h2>

<p>가장 전통적인 CSS 방식에는 크게 3가지 방식이 존재한다.</p>

<ul>
  <li><a href="#inline-css">Inline CSS</a></li>
  <li><a href="#internal-css">Internal CSS</a></li>
  <li><a href="#external-css">External CSS</a></li>
</ul>

<h3 id="inline-css">Inline CSS</h3>

<blockquote>
  <p>일반적으로 간단하게 태그안에 style을 적용하는 방법</p>
</blockquote>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1</span> <span class="na">style=</span><span class="s">"color:white;padding:30px;"</span><span class="nt">&gt;</span>Inline CSS<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;p</span> <span class="na">style=</span><span class="s">"color:white;"</span><span class="nt">&gt;</span>HTML 안에서 직접 스타일 적용.<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<h4 id="inline-css-장점">Inline CSS 장점</h4>

<ul>
  <li>HTML 페이지에 쉽고 빠르게 CSS 룰을 삽입할 수 있다.
    <ul>
      <li>변경에 대한 미리보기, 그리고 빠르게 고칠 수 있는 성능에 유용하다.</li>
    </ul>
  </li>
  <li>별도의 문서로 외부 스타일을 만들거나 업로드 할 필요가 없다.</li>
</ul>

<h4 id="inline-css-단점">Inline CSS 단점</h4>

<ul>
  <li>CSS룰을 모든 HTML 엘리먼트에 추가하는 것은 시간 낭비이며 HTML 구조를 복잡하게 만든다.</li>
  <li>여러 엘리먼트에 스타일을 적용하는 것은 웹페이지 사이즈가 커지고 다운로드 시간이 걸리게 된다.</li>
</ul>

<h3 id="internal-css">Internal CSS</h3>

<blockquote>
  <p>CSS Object Model처럼 사용하는 방법.</p>
</blockquote>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;style </span><span class="na">type=</span><span class="s">"text/css"</span><span class="nt">&gt;</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nt">h1</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
    <span class="nl">padding</span><span class="p">:</span> <span class="m">60px</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nt">&lt;/style&gt;</span>
</code></pre></div></div>

<h4 id="internal-css-장점">Internal CSS 장점</h4>

<ul>
  <li>스타일시트에 클래스와 ID 선택자를 사용할 수 있다.</li>
  <li>동일한 HTML 파일 내에서만 코드를 추가하여 여러 파일을 업로드할 필요가 없다.</li>
</ul>

<h4 id="internal-css-단점">Internal CSS 단점</h4>

<ul>
  <li>HTML 문서에 코드를 추가하는 것은 페이지의 사이즈와 로딩 시간을 증가시킬 수 있다.</li>
</ul>

<h3 id="external-css">External CSS</h3>

<blockquote>
  <p>외부에 .css 파일을 따로 빼서 만드는 방법.</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* external.css */</span>
<span class="nc">.xleftcol</span> <span class="p">{</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">33%</span><span class="p">;</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#809900</span><span class="p">;</span>
<span class="p">}</span>
<span class="nc">.xmiddlecol</span> <span class="p">{</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">34%</span><span class="p">;</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#eff2df</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- head --&gt;</span>
<span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">href=</span><span class="s">"external.css"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h4 id="external-css의-장점">External CSS의 장점</h4>

<ul>
  <li>CSS 코드가 별도의 문서로 있기 때문에 HTML 파일 구조가 깔끔해지고, 사이즈가 작아진다.</li>
  <li>여러 페이지들에 같은 .css 파일을 사용할 수 있다.</li>
</ul>

<h4 id="external-css의-단점">External CSS의 단점</h4>

<ul>
  <li>외부 CSS 파일이 로드되기 전까지 페이지가 올바르게 표시되지 않는다.</li>
  <li>여러 CSS 파일을 업로드 하거나 연결하면 사이트 다운로드 시간이 증가할 수 있다.</li>
</ul>

<h2 id="sassscss">SASS/SCSS</h2>

<blockquote>
  <p>SCSS와 SASS는 CSS를 편리하게 이용할 수 있도록 도와주며 추가 기능도 있는 확장판이다</p>
</blockquote>

<p>간단하게 css 스타일의 코드 차이를 보며 이해해보자</p>

<h3 id="일반적인-css">일반적인 CSS</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.list</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">li</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
  <span class="nl">background</span><span class="p">:</span> <span class="sx">url("./image.jpg")</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">li</span><span class="nd">:last-child</span> <span class="p">{</span>
  <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-10px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="scss">SCSS</h3>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.list</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
  <span class="nt">li</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
    <span class="nl">background</span><span class="p">:</span> <span class="sx">url("./image.jpg")</span><span class="p">;</span>
    <span class="k">&amp;</span><span class="nd">:last-child</span> <span class="p">{</span>
      <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-10px</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sass">SASS</h3>

<div class="language-sass highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.list</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100px</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span>
  <span class="nt">li</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span>
    <span class="nl">background</span><span class="p">:</span> <span class="sx">url("./image.jpg")</span>
    <span class="k">&amp;</span><span class="nd">:last-child</span>
      <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-10px</span>
</code></pre></div></div>

<h3 id="왜-쓰는가">왜 쓰는가</h3>

<blockquote>
  <p>CSS가 복잡한 언어는 아니지만 작업이 크고 고도화 될수록 불편하다!</p>
</blockquote>

<p>SCSS나 SASS는 선택자를 많이 남발하거나 프로젝트가 커지면서 점점 복잡해지게 되는데, 이러한 부분에서 가독성과 재사용성을 높여주며 유지보수를 쉽게 만들어준다. 여기서 도움을 주는 도구는 다음과 같다.</p>

<ul>
  <li>변수의 사용</li>
  <li>조건문과 반복문</li>
  <li>Import</li>
  <li>Nesting</li>
  <li>Mixin</li>
  <li>Extend/Inheritance</li>
</ul>

<h3 id="scss-vs-sass">SCSS vs SASS</h3>

<p>SCSS = (Sassy CSS) -&gt; 지리는 CSS</p>

<p>SASS = (Syntactically Awesome Style Sheets) -&gt; 문법적으로 엄청난 CSS</p>

<blockquote>
  <p>SASS는 들여쓰기 기반, SCSS는 {} 기반</p>
</blockquote>

<p>일반적으로 SCSS가 더 넓은 범용성과 CSS의 호환성 등의 장점으로 SCSS를 사용하기를 권장하고 있다!</p>

<h2 id="bem">BEM</h2>

<blockquote>
  <p>Blcok, Element, Modifier</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.header__navigation--navi-text</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>여기서 header는 <code class="language-plaintext highlighter-rouge">Block</code>, naviagtion은 <code class="language-plaintext highlighter-rouge">Element</code>, navi-text는 <code class="language-plaintext highlighter-rouge">Modifier가</code> 된다.</p>

<p>BEM은 기본적으로 ID를 사용하지 않으며, class만을 사용하며, 이름을 연결할 때는 block-name과 같이 하이픈 하나만 써서 연결한다.</p>

<h3 id="block">Block</h3>

<blockquote>
  <p>재사용 가능한 기능적으로 독립적인 페이지 컴포넌트</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/66371206/171098198-40127e9b-c070-4c13-8a33-4198472d5d28.png" alt="9977B24F5C7BF67802" /></p>

<p>즉 위 사진처럼 떼어내서, 재사용이 가능한 컴포넌트를 부른다. 어디에서나 종속되지 않고, 독립적으로 사용할 수 있으며 특징으로는 블럭은 블럭으로 감쌀 수 있다는 점이 있다.</p>

<h3 id="element">Element</h3>

<blockquote>
  <p>블럭을 구성하는 단위</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/66371206/171098520-fe2f8dac-867e-45e3-85d3-9979e60e5647.png" alt="993FCF4A5C7BF68F27" /></p>

<p>자신이 속한 블럭 내에서만 의미를 가지기 때문에 블럭 안에서 떼어다 다른 데 쓸 수 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">form</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">search-form</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">input</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">search-form__input</span><span class="dl">"</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="nx">button</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">search-form__button</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">Search</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span></code></pre></div></div>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">.search-form</code>은 블럭이고, <code class="language-plaintext highlighter-rouge">.search-form__input</code>과 <code class="language-plaintext highlighter-rouge">.search-form__button</code>은 엘리먼트이다.
저 search-form이란 블럭은 떼어내서 마음껏 붙여도 된다.
하지만 내부의 input과 button은 검색을 위한 인풋창이자 버튼이기 때문에, search-form 안에서만 존재 의미가 있는 엘리먼트이다.</p>

<h3 id="modifier">Modifier</h3>

<blockquote>
  <p>블럭이나 엘리먼트의 속성을 담당</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/66371206/171098735-bb4930fb-7ee3-4bfd-82e5-de42bd017a50.png" alt="992F5E4A5C7BF68F33" /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">ul</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">li</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab__item tab__item--focused</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">탭</span> <span class="mi">1</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">li</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab__item</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">탭</span> <span class="mi">2</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">li</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab__item</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">탭</span> <span class="mi">3</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span></code></pre></div></div>

<p>위 코드에서 –focused가 수식어에 해당한다. 저렇게 작성된 걸 불리언(boolean) 타입이라고 하는데, 그 값이 true라고 가정하고 사용하며, <code class="language-plaintext highlighter-rouge">key-value</code>로도 사용할 수 있다.</p>

<h2 id="css-module">CSS Module</h2>

<blockquote>
  <p>리액트 프로젝트에서 컴포넌트를 스타일링 할 때 CSS Module 이라는 기술을 사용하면, CSS 클래스가 중첩되는 것을 완벽히 방지할 수 있다.</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*box.css*/</span>
<span class="nc">.Box</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="no">black</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">2rem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//box.js</span>
<span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">styles</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Box.module.css</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Box</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">Box</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">Box</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Box</span><span class="p">;</span>
</code></pre></div></div>

<p>그럼 다른 css 파일에서 동일한 css className을 만들어야 된다는 부담감에 필요없이 만들 수 있다.</p>

<h2 id="css-in-js">CSS in JS</h2>

<blockquote>
  <p>마지막으로 CSS in JS에서 제일 유명한 styled components 를 보며 알아보자</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Box4.js</span>
<span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">styled</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">styled-components</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Box</span><span class="p">({</span> <span class="nx">size</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isBig</span> <span class="o">=</span> <span class="nx">size</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">big</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">label</span> <span class="o">=</span> <span class="nx">isBig</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">큰 박스</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">작은 박스</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">BoxCommon</span> <span class="nx">isBig</span><span class="o">=</span><span class="p">{</span><span class="nx">isBig</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">label</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/BoxCommon&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">BoxCommon</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="s2">`
  width: </span><span class="p">${(</span><span class="nx">props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">isBig</span> <span class="p">?</span> <span class="mi">200</span> <span class="p">:</span> <span class="mi">100</span><span class="p">)}</span><span class="s2">px;
  height: 50px;
  background-color: #aaaaaa;
`</span><span class="p">;</span>
</code></pre></div></div>

<p>다음과 같이 진행했던 CSS를 module 처럼 뺄 필요도 없이, 한 페이지에서 관리할 수 있다. 즉 CSS코드를 자바스크립트 파일안에서 하므로, 내부응집도가 올라가고, 동적으로 CSS를 변경하기도 쉽다.</p>

<p>출처</p>

<p><a href="https://latte-is-horse.tistory.com/38">https://latte-is-horse.tistory.com/38</a></p>

<p><a href="https://velog.io/@jch9537/CSS-SCSS-SASS">https://velog.io/@jch9537/CSS-SCSS-SASS</a></p>

<p><a href="https://nykim.work/15">https://nykim.work/15</a></p>

<p><a href="https://react.vlpt.us/styling/02-css-module.html">https://react.vlpt.us/styling/02-css-module.html</a></p>]]></content><author><name>071yoon</name></author><category term="CSS" /><category term="CSS" /><category term="SASS" /><category term="SCSS" /><category term="styled-components" /><category term="CSS-Moduler" /><summary type="html"><![CDATA[CSS 트렌드]]></summary></entry><entry><title type="html">Jira와 깃허브 연동</title><link href="http://localhost:4000/jira/2022/05/30/jira-github-%EC%97%B0%EB%8F%99.html" rel="alternate" type="text/html" title="Jira와 깃허브 연동" /><published>2022-05-30T00:00:00+09:00</published><updated>2022-05-30T00:00:00+09:00</updated><id>http://localhost:4000/jira/2022/05/30/jira-github-%EC%97%B0%EB%8F%99</id><content type="html" xml:base="http://localhost:4000/jira/2022/05/30/jira-github-%EC%97%B0%EB%8F%99.html"><![CDATA[<h2 id="jira와-깃허브-연동하기">Jira와 깃허브 연동하기</h2>

<h3 id="1-깃허브앱-등록">1. 깃허브앱 등록</h3>

<p>Jira와 연동을 하려면 우선 깃허브앱을 등록을 해야된다.
<img width="428" alt="image" src="https://user-images.githubusercontent.com/66371206/170931557-3de22400-fb72-4f72-9c0a-55c9d665ef1e.png" /></p>

<p>등록에 가서 평점이 조금 낮지만 공식 앱인 <code class="language-plaintext highlighter-rouge">Github for Jira</code>를 설치한다.</p>

<p><img width="823" alt="image" src="https://user-images.githubusercontent.com/66371206/170931899-d48cf6c9-57e0-47e7-891d-ce68ac0dc18d.png" /></p>

<p>그 후 Authorize를 하고 원하는 Organization 혹은 Repository를 등록하며 진행한다</p>

<p><img width="574" alt="image" src="https://user-images.githubusercontent.com/66371206/170932096-0d8481f1-b06c-449a-b66d-5a1d1cf658c8.png" /></p>

<p>다음과 같이 해당 깃허브 Repository에 Jira 앱이 설치되어 있고, 마찬가지로 Jira에도 앱 추가가 되어있으면 준비가 되었다.</p>

<p><img width="1156" alt="image" src="https://user-images.githubusercontent.com/66371206/170932363-abe6fda2-4380-4e63-a9d7-01e893ec950d.png" /></p>

<p><img width="1362" alt="image" src="https://user-images.githubusercontent.com/66371206/170932432-2458d419-37dd-479a-9cdb-fc594ce2b415.png" /></p>

<h3 id="2-이슈-만들기">2. 이슈 만들기</h3>

<p>우선 이슈를 만들려면 스프린트부터 작성을 해야된다. 해당 지라앱에서 새로운 에픽을 만들어보자.</p>

<p><img width="410" alt="image" src="https://user-images.githubusercontent.com/66371206/170931358-38c9357e-4599-4387-acb9-fc7569394184.png" /></p>

<p>스프린트를 만들었다면, 좌측에 백로그에서 해당 스프린트에 대한 이슈를 만들 수 있다.</p>

<p><img width="1165" alt="image" src="https://user-images.githubusercontent.com/66371206/170932860-c7c291ae-877a-4a49-86ca-fc6eee95eb64.png" /></p>

<p>간단하게 이슈를 하나 만든 후 스프린트 시작을 누르면 시작할 수 있고, 방금 만든 이슈에 대한 내용은 스프린트 페이지에서 하위 이슈로 확인 할 수 있다.</p>

<p><img width="1174" alt="image" src="https://user-images.githubusercontent.com/66371206/170933380-46979990-b58c-4bf9-b028-68f2912af333.png" /></p>

<h3 id="3-브랜치-및-커밋-작성">3. 브랜치 및 커밋 작성</h3>

<p>방금 만든 이슈에 대해서 커밋 만들기, 혹은 브랜치 만들기를 보면 다음과 같이 키를 알려준다.</p>

<p><img width="411" alt="image" src="https://user-images.githubusercontent.com/66371206/170933552-1f99d427-18ef-4178-8bd4-a61e736f4780.png" /></p>

<p><img width="428" alt="image" src="https://user-images.githubusercontent.com/66371206/170933605-1b00262d-cbae-43b1-869f-3a1bafa70660.png" /></p>

<p>여기서 해당하는 키를 가지고 브랜치를 만들고, 커밋을 하면 자동으로 jira 가 해당하는 커밋을 track 해서 연동을 해준다.</p>

<p>그렇게 해서 완성된 이슈를 보면 다음과 같다.</p>

<p>만들기 위해 커밋을 4번, 풀 리퀘스트를 진행 후 merge를 한 이슈이다.</p>

<p><img width="1169" alt="image" src="https://user-images.githubusercontent.com/66371206/170933764-2d136f8b-36d1-4246-bd46-90dd5682e870.png" /></p>

<p>해당하는 FIRE-44에 대한 커밋을 깃허브에서 보면 다음과 같이 설정되어있다.</p>

<p><img width="1264" alt="image" src="https://user-images.githubusercontent.com/66371206/170933985-8987738a-f687-49a1-af61-dfd22402a387.png" /></p>

<p>깃허브와 Jira 연동 끗!!</p>]]></content><author><name>071yoon</name></author><category term="Jira" /><category term="Jira" /><category term="Agile" /><category term="Github" /><category term="study" /><summary type="html"><![CDATA[Jira와 깃허브 연동하기]]></summary></entry><entry><title type="html">NEXT-API</title><link href="http://localhost:4000/next.js/2022/05/15/next-api.html" rel="alternate" type="text/html" title="NEXT-API" /><published>2022-05-15T00:00:00+09:00</published><updated>2022-05-15T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/15/next-api</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/15/next-api.html"><![CDATA[<h2 id="api-routes">API Routes</h2>

<h3 id="intro">Intro</h3>

<p><code class="language-plaintext highlighter-rouge">pages/api</code> 안에 있는 어떤 파일이든 전부 <code class="language-plaintext highlighter-rouge">/api/*/</code>로 접근 할 수 있으며, <code class="language-plaintext highlighter-rouge">page</code> 대신 API 최종점으로 여겨진다. 이 API들은 전부 server-side 전용이며, Client-side의 번들 사이즈를 증가시키지는 않는다.</p>

<p>예를들어, 다음과 같이 <code class="language-plaintext highlighter-rouge">pages/api/users.js</code>가 리턴하는 <code class="language-plaintext highlighter-rouge">json</code>같응ㄴ 경우는 status 200으로 소통한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">YeongGi Yoon</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이러한 API route가 작동하려면, 함수를 default 로 export 해야하며, 다음과 같은 인자들을 받는다</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">req</code>: http.IncomingMessage의 객체 중 하나 + pre-built middleware</li>
  <li><code class="language-plaintext highlighter-rouge">res</code>: http.ServerResponse의 객체 중 하나 + helper functions</li>
</ul>

<p>다양한 HTTP API route를 처리하기 위해, request handler에 다음과 같이 <code class="language-plaintext highlighter-rouge">req.method</code>를 활용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">method</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">POST) {
		//POST에 해당하는 req
	}
	else {
		//그 외
	}
}
</span></code></pre></div></div>

<h4 id="use-cases">Use Cases</h4>

<p>새로운 프로젝트들을 위해서, 모든 API 와 API route를 만들 수 있다. 만약 존재하는 API가 있따면, API Route를 통한 forward call을 하지 않아도 된다. 다양한 API Route의 활용법은 다음과 같다.</p>

<ul>
  <li>외부 서비스의 URL를 마스킹 하는것 (<code class="language-plaintext highlighter-rouge">https://company.com/secret-url</code> 대신 <code class="language-plaintext highlighter-rouge">/api/secret</code>을 사용하게 하는 것)</li>
  <li>서버에서 환경변수를 사용하여 더욱 안전하게 외부 서비스를 접근하는 법</li>
</ul>

<h4 id="caveats">Caveats</h4>

<p>API Routes는 <code class="language-plaintext highlighter-rouge">CORS header</code>를 특정화하지 않는다. 즉, 일반적으로 같은 근간이라 할 수 있다. 이와같은 행동은 <code class="language-plaintext highlighter-rouge">CORS middleware</code>에서 정의 할 수 있다.
API Route는 <code class="language-plaintext highlighter-rouge">next export</code>와 같이 사용될 수 없다.</p>

<h3 id="dynamic-api-routes">Dynamic API Routes</h3>

<p>API Route같은 경우에 <code class="language-plaintext highlighter-rouge">Dynamic Routes</code>를 바로 지원하며, 즉 <code class="language-plaintext highlighter-rouge">pages</code> 안에 파일 이름 규칙이 있다면 가져 올 수 있다. 예를들어 <code class="language-plaintext highlighter-rouge">pages/api/post/[pid].js</code> 와 같은 API Route가 존재한다면 코드로는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">pid</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">;</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">`Post: </span><span class="p">${</span><span class="nx">pid</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 되면, <code class="language-plaintext highlighter-rouge">/api/post/abc</code>에 해당하는 request가 <code class="language-plaintext highlighter-rouge">Post: abc</code>에서 응답을 받을 수 있다.</p>

<p>RESTful한 방식으로 routes를 만들면 다음과 같다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GET api/posts</code> : 모든 포스트에 대한 list를 가져온다</li>
  <li><code class="language-plaintext highlighter-rouge">GET api/posts/12345</code> : 12345에 대한 포스트 정보만 가져온다</li>
</ul>

<p>그럼 모델을 두가지 분류로 나눌 수 있다.</p>

<ol>
  <li>1번 옵션
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/api/posts.js</code></li>
      <li><code class="language-plaintext highlighter-rouge">/api/posts/[postId].js</code></li>
    </ul>
  </li>
  <li>2번 옵션
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/api/posts/index.js</code></li>
      <li><code class="language-plaintext highlighter-rouge">/api/posts/[postId].js</code></li>
    </ul>
  </li>
</ol>

<p>두가지 다 동일하지만, 세번째 옵션 <code class="language-plaintext highlighter-rouge">/api/posts/[postId].js</code> 같은 경우에는 Dynamic Routes가 <code class="language-plaintext highlighter-rouge">undefined</code>한 상태가 없기에 유효하지 않다.</p>

<h4 id="catch-all-api-routes">Catch all API routes</h4>

<p>API Route는 <code class="language-plaintext highlighter-rouge">...</code>을 추가하여 모든 루트를 추가할 수 있다. 예를 들어 <code class="language-plaintext highlighter-rouge">pages/api/post/[...slug].js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/a</code>와 매칭되며, <code class="language-plaintext highlighter-rouge">/api/post/a/b</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a/b/c</code> 모두 매칭이 된다. 이렇게 매칭된 인자들은 query parameter로 넘겨지며, 항상 배열이 된다. 즉 <code class="language-plaintext highlighter-rouge">/api/post/a</code>라는 루트는 <code class="language-plaintext highlighter-rouge">{ "slug": ["a"]}</code> 라는 <code class="language-plaintext highlighter-rouge">query object</code>를 가지게 된다. 만약 <code class="language-plaintext highlighter-rouge">/api/post/a/b</code> 라면 <code class="language-plaintext highlighter-rouge">{ "slug": ["a", "b"]}</code> 처럼 가지게 된다.</p>

<p>종합하여 보면 <code class="language-plaintext highlighter-rouge">pages/api/post/[...slug].js</code> 라는 API Route 는 다음과 같이 생겼다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">slug</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">;</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">`Post: </span><span class="p">${</span><span class="nx">slug</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2">, </span><span class="dl">"</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그럼 <code class="language-plaintext highlighter-rouge">/api/post/a/b/c</code> 라는 request는 <code class="language-plaintext highlighter-rouge">Post: a, b, c</code>로 응답을 받게된다.</p>

<h4 id="optional-catch-all-api-routes">Optional catch all API routes</h4>

<p>이중괄후를 사용하여 모든 루트를 찾는 방법또한 사용 할 수 있다. <code class="language-plaintext highlighter-rouge">[[...slug]]</code> 처럼 사용하면 되며 <code class="language-plaintext highlighter-rouge">pages/api/post[[...slug]].js</code> 가 <code class="language-plaintext highlighter-rouge">/api/post</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a/b</code> 모두 매칭 된다고 볼 수 있다.</p>

<h4 id="caveats-1">Caveats</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pages/api/post/create.js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/create</code> 과 매칭된다.</li>
  <li><code class="language-plaintext highlighter-rouge">pages/api/post/[pid].js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/1</code>, 와 <code class="language-plaintext highlighter-rouge">/api/post/abc,</code> 과 매칭되며 <code class="language-plaintext highlighter-rouge">/api/post/create</code> 과는 매칭되지 않는다.</li>
  <li><code class="language-plaintext highlighter-rouge">pages/api/post/[...slug].js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/1/2</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a/b/c</code>와 매칭되며 <code class="language-plaintext highlighter-rouge">/api/post/create</code> 나 <code class="language-plaintext highlighter-rouge">/api/post/abc</code>와는 매칭되지 않는다.</li>
</ul>

<h3 id="api-middlewares">API Middlewares</h3>

<h3 id="response-helpers">Response Helpers</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[API Routes]]></summary></entry><entry><title type="html">NEXT-Others-2</title><link href="http://localhost:4000/next.js/2022/05/08/next-others-2.html" rel="alternate" type="text/html" title="NEXT-Others-2" /><published>2022-05-08T00:00:00+09:00</published><updated>2022-05-08T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/08/next-others-2</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/08/next-others-2.html"><![CDATA[<h2 id="environment-variables">Environment Variables</h2>

<h3 id="loading-environment-variables">Loading Environment Variables</h3>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 우선 내부적으로 <code class="language-plaintext highlighter-rouge">.env.local</code> 과 <code class="language-plaintext highlighter-rouge">process.env</code> 같은 환경변수를 제공해준다. 예를들어 <code class="language-plaintext highlighter-rouge">.env.local</code> 같은 경우에는 다음과 같이 사용한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB_HOST</span><span class="o">=</span>localhost
<span class="nv">DB_USER</span><span class="o">=</span>myuser
<span class="nv">DB_PASS</span><span class="o">=</span>mypassword
</code></pre></div></div>

<p>해당 환경변수들은 Node.js에서 자동으로 <code class="language-plaintext highlighter-rouge">Next.js</code>의 데이터를 가져오는 방식으로 사용하게 된다. 예를들어 해당 환경변수를 가지고 ` getStaticProps`를 사용하는 방식을 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">myDB</span><span class="p">.</span><span class="nx">connect</span><span class="p">({</span>
    <span class="na">host</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_HOST</span><span class="p">,</span>
    <span class="na">username</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_USER</span><span class="p">,</span>
    <span class="na">password</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_PASS</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>서버가 민감한 정보들을 안전하게 다루기 위해 Next.js는 <code class="language-plaintext highlighter-rouge">process.env.*</code> 파일을 빌드 시간에 맞는 경로로 전달한다. 즉 <code class="language-plaintext highlighter-rouge">process.env</code>는 자바스크립트에서의 표준이 아니며, object destructuring을 사용할 수 없다는 뜻이다. 즉 환경 변수는 <code class="language-plaintext highlighter-rouge">const { PUBLISHABLE_KEY } = process.env</code> 처럼 사용하는 것이 아닌 <code class="language-plaintext highlighter-rouge">process.env.PUBLISHABLE_KEY</code> 처럼 사용해야 된다.</td>
    </tr>
  </tbody>
</table>

<p>또한 Next.js는 (<code class="language-plaintext highlighter-rouge">$VAR</code>) 과 같은 변수들은 자동적으로 <code class="language-plaintext highlighter-rouge">.env*</code> 파일에서 연장하여 사용한다. 변수를 사용한 방법은 다음과 같다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># .env</span>
<span class="nv">HOSTNAME</span><span class="o">=</span>localhost
<span class="nv">PORT</span><span class="o">=</span>8080
<span class="nv">HOST</span><span class="o">=</span>http://<span class="nv">$HOSTNAME</span>:<span class="nv">$PORT</span>
</code></pre></div></div>

<p>만약 <code class="language-plaintext highlighter-rouge">$</code> 를 그대로 쓰고싶다면 <code class="language-plaintext highlighter-rouge">\$</code> 과 같이 백슬래쉬를 넣어 사용해야된다.</p>

<h3 id="exposing-environment-variables-to-the-browser">Exposing Environment Variables to the Browser</h3>

<p>일반적인 환경변수들은 <code class="language-plaintext highlighter-rouge">Node.js</code> 환경에서만 사용가능하므로, 브라우저에 유출이 되진 않는다. 만약 브라우저에서 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC</code> 으로 시작하는 변수를 외부로 유출시키고 싶다면, 다음과 같이 사용하면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NEXT_PUBLIC_ANALYTICS_ID</span><span class="o">=</span>abcdefghijk
</code></pre></div></div>

<p>이렇게 사용하게 되면, <code class="language-plaintext highlighter-rouge">process.env.NEXT_PUBLIC_ANALYTICS_ID</code>가 로드되어, Node.js 환경으로 자동으로 들어가 코드 어디에서도 사용 할 수 있게 된다. 즉 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_</code>과 같은 접두사를 사용하게 된다면, 자바스크립트가 브라우저에게 바로 값을 넘겨주게 된다. 이러한 인라인은 빌드시간에 일어나며, 다음과 같은 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_</code>의 환경변수들은 프로젝트가 빌드가 끝난 후 사용된다. 코드에서 사용되는 예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/index.js</span>
<span class="k">import</span> <span class="nx">setupAnalyticsService</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../lib/my-analytics-service</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// NEXT_PUBLIC_ANALYTICS_ID can be used here as it's prefixed by NEXT_PUBLIC_</span>
<span class="nx">setupAnalyticsService</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NEXT_PUBLIC_ANALYTICS_ID</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">HomePage</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">World</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">HomePage</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="default-envrionment-variables">Default Envrionment Variables</h3>

<p>일반적으로는 하나의 <code class="language-plaintext highlighter-rouge">.env.local</code>파일만이 필요하다. 하지만 가끔 <code class="language-plaintext highlighter-rouge">development</code>나 <code class="language-plaintext highlighter-rouge">production</code>에 따라 다른 환경 변수들을 사용 할 수 있다. 그래서 <code class="language-plaintext highlighter-rouge">Next.js</code> 는 <code class="language-plaintext highlighter-rouge">.env</code>, <code class="language-plaintext highlighter-rouge">.env.development</code>, <code class="language-plaintext highlighter-rouge">.env.production</code>과 같은 환경변수 또한 지원하며 <code class="language-plaintext highlighter-rouge">.env.local</code>을 항상 표준으로 둔다.</p>

<table>
  <tbody>
    <tr>
      <td>주의사항으로는 <code class="language-plaintext highlighter-rouge">.env</code>, <code class="language-plaintext highlighter-rouge">.env.development</code>, <code class="language-plaintext highlighter-rouge">.env.production</code> 과 같은 파일들은 <code class="language-plaintext highlighter-rouge">.env*.local</code>에 정의되어 있어야 하고 <code class="language-plaintext highlighter-rouge">.gitignore</code>에 포함시켜 안전하게 보관해야된다.</td>
    </tr>
  </tbody>
</table>

<h3 id="test-envrionment-variables">Test Envrionment Variables</h3>

<p><code class="language-plaintext highlighter-rouge">development</code>와 <code class="language-plaintext highlighter-rouge">production</code> 환경변수외로, <code class="language-plaintext highlighter-rouge">text</code>라는 세번째 옵션이 또 존재한다. 앞선 방법들과 마찬가지로 <code class="language-plaintext highlighter-rouge">.env.teest</code>에서 <code class="language-plaintext highlighter-rouge">testing</code> 환경을 구축하여 사용 할 수 있다.</p>

<p>이러한 방법은 <code class="language-plaintext highlighter-rouge">jest</code>나 <code class="language-plaintext highlighter-rouge">cypress</code>와 같은 테스팅 툴을 사용할 때 유용하게 사용 할 수 있다. 이러한 테스트 방식은 <code class="language-plaintext highlighter-rouge">NODE_ENV</code>가 <code class="language-plaintext highlighter-rouge">test</code>로 되어있다면, 테스트의 표준 환경을 사용 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">test</code> 가 <code class="language-plaintext highlighter-rouge">development</code> 와 <code class="language-plaintext highlighter-rouge">production</code> 와 다른점이 있다면, 테스트 환경은 <code class="language-plaintext highlighter-rouge">.env.local</code>에 로딩이 안된다는 것이다. 이러한 방식으로 실행되어야 매번 같은 환경을 사용할 수 있기 때문이다.</p>

<p>unit test 를 하는 동안에는 <code class="language-plaintext highlighter-rouge">@next/env</code> 패키지를 사용하여 <code class="language-plaintext highlighter-rouge">loadEnvConfig</code>를 해야함에 주의한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The below can be used in a Jest global setup file or similar for your testing set-up</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">loadEnvConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@next/env</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">projectDir</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">cwd</span><span class="p">();</span>
  <span class="nx">loadEnvConfig</span><span class="p">(</span><span class="nx">projectDir</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>env의 우선순위는 다음과 같다.</p>

<h4 id="node_envproduction">NODE_ENV=production</h4>

<ol>
  <li>.env.production.local</li>
  <li>.env.local</li>
  <li>.env.production</li>
  <li>.env</li>
</ol>

<h4 id="node_envdevelopment">NODE_ENV=development</h4>

<ol>
  <li>.env.development.local</li>
  <li>.env.local</li>
  <li>.env.development</li>
  <li>.env</li>
</ol>

<h4 id="node_envtest">NODE_ENV=test</h4>

<ol>
  <li>.env.test.local</li>
  <li>.env.test</li>
  <li>.env</li>
</ol>

<h2 id="supported-browsers-and-features">Supported Browsers and Features</h2>

<h2 id="script-component">Script Component</h2>

<p>Image를 NEXT 에서 제공했던것 처럼, Script같은 경우에도 따로 지정해주는걸 사용하는것이 효율과 성능면에서 더 좋다. 해당 Script 컴포넌트는 <code class="language-plaintext highlighter-rouge">next/script</code>에서 가져올 수 있으며 기본적인 HTML <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>의 연장선이다. 해당 <script></script>는 <code class="language-plaintext highlighter-rouge">next/head</code> 밖에서 개발자들에게 로딩하는 우선순위를 지정할 수 있게 해주어 로딩 효율을 높여준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Script</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/script</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://www.google-analytics.com/analytics.js</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="overview">Overview</h3>

<p>웹사이트는 가끔 통계, 광고, 위젯등을 사용할 때 써드파티의 스크립트를 사이트에서 사용하게 된다. 하지만 이러한 스크립트를 가져오는것이 보통 유저와 개발 입장에서 둘 다 문제를 일으키게 된다.</p>

<ul>
  <li>어떠한 써드파티의 스크립트 같은경우 너무 무거워서 로딩효율이 안좋고, UX 관점에서 되게 안좋을 수 있다. 특히나, render-block 혹은 딜레이가 생길 수 있다.</li>
  <li>개발자들은 어떠한 써드파티의 스크립트를 어디에 두어야 효율적인 로딩이 될지 고민하게 된다.</li>
</ul>

<p>이러한 문제들을 Next 에서 제공하는 <code class="language-plaintext highlighter-rouge">Script</code>를 사용하여 해결 할 수 있다.</p>

<h3 id="usage">Usage</h3>

<p>이러한 <code class="language-plaintext highlighter-rouge">Script</code>를 사용시에, <code class="language-plaintext highlighter-rouge">strategy</code>란 속성을 두어서 관리를 할 수 있다. 간단한 예제를 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://connect.facebook.net/en_US/sdk.js</span><span class="dl">"</span> <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">lazyOnload</span><span class="dl">"</span> <span class="o">/&gt;</span>
</code></pre></div></div>

<p>속성들을 보면 다음과 같다.</p>

<ul>
  <li><a href="#beforeinteractive">beforeInteractive</a></li>
  <li><a href="#afterinteractive">afterInteractive</a></li>
  <li><a href="#lazyonload">lazyOnload</a></li>
  <li><a href="#worker">worker</a></li>
</ul>

<h4 id="beforeinteractive">beforeInteractive</h4>

<p><code class="language-plaintext highlighter-rouge">beforeInteractive</code>속성이 있는 스크립트 같은 경우에는 최초의 HTML에 들어가, 서버가 바로 실행하여 self-bundle된 Javascript가 실행되기 전에 돌아간다. 이러한 방법은 페이지가 상호작용을 하기도전에, fetch하여 실행을 해야될 경우 주로 사용된다. 이러한 방법은 메인 페이지인 <code class="language-plaintext highlighter-rouge">_document.js</code>에서 동작하며, 보통 모든 사이트에서 로딩이 필요한 script인 경우에 들어가서 실행된다.</p>

<p>이러한 <code class="language-plaintext highlighter-rouge">beforeInteractive</code>한 방법이 사용되는 이유는, 오직 <code class="language-plaintext highlighter-rouge">_document.js</code>에서만 동작하게 하여 스티리밍과 Suspense functionality를 지원하기 위함이다. 즉 <code class="language-plaintext highlighter-rouge">_document.js</code> 의 밖에서는 <code class="language-plaintext highlighter-rouge">beforeInteractive</code>의 방식이 우선순위를 잘 두어 실행된다는 보장을 할 수 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In _document.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Html</span><span class="p">,</span> <span class="nx">Head</span><span class="p">,</span> <span class="nx">Main</span><span class="p">,</span> <span class="nx">NextScript</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/document</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Script</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/script</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Document</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Head</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">Script</span>
          <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js</span><span class="dl">"</span>
          <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">beforeInteractive</span><span class="dl">"</span>
        <span class="o">&gt;&lt;</span><span class="sr">/Script</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>보통 이러한 속성을 띄는 예는 다음과 같다.</p>

<ul>
  <li>Bot detectors</li>
  <li>Cookie consent managers</li>
</ul>

<h4 id="afterinteractive">afterInteractive</h4>

<p><code class="language-plaintext highlighter-rouge">afterInteractive</code> 방법을 쓰는 Script같은 경우에는 클라이언트 딴에서 삽입되어, Next.js가 hydration 작업을 마친 후에 동작한다. 이러한 방식은 제일빨리 실행될 필요가 없으며 우선순위가 낮을 때 사용하게 된다.</p>

<p>이러한 방식의 스크립트는 다음과 같은 상황에 많이 사용된다.</p>

<ul>
  <li>Tag managers</li>
  <li>Analytics</li>
</ul>

<h4 id="lazyonload">lazyOnload</h4>

<p><code class="language-plaintext highlighter-rouge">lazyOnload</code>의 속성을 띄는 Script 같은 경우에는, 모든 리소스들이 로딩된 후 <code class="language-plaintext highlighter-rouge">idle</code> 한 시간에 fetch되어 정보를 가져올 떄 사용된다. 이러한 방식은 background 나 낮은 우선순위를 가진 스크립트들이 주로 사용된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://connect.facebook.net/en_US/sdk.js</span><span class="dl">"</span> <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">lazyOnload</span><span class="dl">"</span> <span class="o">/&gt;</span>
</code></pre></div></div>

<p>이러한 방식을 사용하는 스크립트는 주로 다음과 같다.</p>

<ul>
  <li>Chat support plugins</li>
  <li>Social media widgets</li>
</ul>

<h4 id="worker">worker</h4>

<p>해당 속성 같은 경우에는, 메일 쓰레드를 정해주어 효율을 높여주는 방식이지만, 아직 테스트 환경이라 안전하지 않다.</p>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Environment Variables]]></summary></entry><entry><title type="html">NEXT-Others-1</title><link href="http://localhost:4000/next.js/2022/05/05/next-others-1.html" rel="alternate" type="text/html" title="NEXT-Others-1" /><published>2022-05-05T00:00:00+09:00</published><updated>2022-05-05T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/05/next-others-1</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/05/next-others-1.html"><![CDATA[<h2 id="static-file-serving">Static File Serving</h2>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 파일을 <code class="language-plaintext highlighter-rouge">public</code>에서 이미지처럼 정적으로 활용 할 수 있다. <code class="language-plaintext highlighter-rouge">public</code>은 root 안에 있어야 하며, <code class="language-plaintext highlighter-rouge">public</code> 안에서는 <code class="language-plaintext highlighter-rouge">/</code>로 시작하는 base URL을 따라가야된다.</p>

<p><code class="language-plaintext highlighter-rouge">public/me.png</code>를 삽입하는 과정은 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Avatar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Image</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span> <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">me</span><span class="dl">"</span> <span class="nx">width</span><span class="o">=</span><span class="dl">"</span><span class="s2">64</span><span class="dl">"</span> <span class="nx">height</span><span class="o">=</span><span class="dl">"</span><span class="s2">64</span><span class="dl">"</span> <span class="o">/&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Avatar</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">next/img</code>의 대한 내용은 <a href="2022-05-04-next-optimization.md">NextOptimization</a> 를 참고.</p>

<p>이러한 폴더는 <code class="language-plaintext highlighter-rouge">robots.txt</code> 혹은 <code class="language-plaintext highlighter-rouge">favicon.ico</code> 에서도 사용이 될 수 있으며, Google Site Verification 등에도 활용될 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>주의사항! <code class="language-plaintext highlighter-rouge">public</code>이란 명명은 다른곳에서 사용하면 안된다. 해당 폴더는 정적인 asset만 포함되어야 된다!</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>주의사항2! 마찬가지로 정적 파일을 <code class="language-plaintext highlighter-rouge">pages/</code>라는 폴더 안에 넣게되면 에러가 난다!</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>주의사항3! <code class="language-plaintext highlighter-rouge">public</code> 폴더 안에 들어간 assets 들 만이 빌드 타임에서 Next.js로 넘겨진다. 런타임중에서는 추가가 되어도 활용되지 않으므로, <code class="language-plaintext highlighter-rouge">AWS S3</code>과 같은 third party를 사용하는 것이 좋다.</td>
    </tr>
  </tbody>
</table>

<h2 id="fast-refresh">Fast Refresh</h2>

<p>Fast Refresh는 React component에 편집을 한 즉시 피드백을 주는 기능이다. 이러한 기능은 Next.jsdml 9.4 이상에서 자동으로 작동하며, 켜져있다면 component 의 상태정보를 잃지 않고 바로 확인을 할 수 있다.</p>

<h3 id="how-it-works">How It Works</h3>

<ul>
  <li>
    <p>만약 <code class="language-plaintext highlighter-rouge">React component</code>만 export하는 환경이라면, Fast Refresh는 오직 그 한 파일만 업데이트를 하며, 컴포넌트를 다시 렌더링 해준다. 해당 파일 안에서는 style, logic, handler, effects 등 아무거나 편집을 해도 된다!</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">React component</code>가 아닌 파일을 편집한다면, Fast Refresh는 두 파일 모두와 import 된 다른 파일들을 재실행 할 것이다. 예를들어, <code class="language-plaintext highlighter-rouge">Button.tsx</code>와 <code class="language-plaintext highlighter-rouge">Modal.tsx</code>가 <code class="language-plaintext highlighter-rouge">theme.tsx</code>를 import 한다면, <code class="language-plaintext highlighter-rouge">theme.tsx</code>를 편집하게 되면, 두 컴포넌트 다 업데이트가 된다.</p>
  </li>
  <li>
    <p>만약 React 구조에서 벗어난 import 파일을 편집하게 된다면, Fast Refresh는 full reload를 어쩔 수 없이 하게된다. 예를들어, 만약 상수 component를 export 하지만, non-React utility file이 import 되어 있다면 파일의 위치를 바꾸어야된다.</p>
  </li>
</ul>

<h3 id="error-resillience">Error Resillience</h3>

<h4 id="syntax-errors">Syntax Errors</h4>

<p>만약 개발중에 syntax error가 나온다면, 수정 후 파일을 저장하면 바로 적용이 된다. 오류는 자동으로 없어지고, 앱을 재로딩할 필요도 없다.</p>

<table>
  <tbody>
    <tr>
      <td>컴포넌트의 상태정보 또한 잃지 않는다.</td>
    </tr>
  </tbody>
</table>

<h4 id="runtime-errors">Runtime Errors</h4>

<p>만약 런타임 에러가 나는 코드를 짜버렸다면, contextual overlay가 나온다. 에러를 고치면 바로 overlay가 없어지면서 앱이 재로딩이 된다.</p>

<p>컴포넌트의 상태정보는 렌더링을 하지 않았을 시 저장된다. 만약 렌더링 중에 에러가 나왔다면, 리액트는 업데이트된 코드로 재구동 한다.</p>

<p>만약 앱에 <code class="language-plaintext highlighter-rouge">error boundaries</code>가 설정 되어있다면, 렌더링 에러 이후 렌더링하려고 바로 재시도를 한다. 즉 <code class="language-plaintext highlighter-rouge">error boundary</code>가 설정되어 있다면, 루트의 앱 상탲정보를 항상 재설정 해주는 수고를 겪지 않아도 된다. 하지만, <code class="language-plaintext highlighter-rouge">error boundary</code>가 너무 세분화되면 안된다. 보통 React production에 많이 사용되고, 의도적으로 사용되어야 한다.</p>

<h3 id="limitations">Limitations</h3>

<p>Fast Refresh는 컴포넌트를 수정시에도 local React state를 유지하려고 노력한다.</p>

<table>
  <tbody>
    <tr>
      <td>안전하다고 판단될떄만 사용해야됨!</td>
    </tr>
  </tbody>
</table>

<p>local state가 자주 재설정 되는 이유는 다음과 같다.</p>

<ul>
  <li>
    <p>Local State는 클래스 컴포넌트에서 예약되어지지 않는다.</p>
  </li>
  <li>
    <p>편집하려는 파일이 다른 export된 리액트 컴포넌트를 사용하고 있을 수 도 있다.</p>
  </li>
  <li>
    <p>파일이 <code class="language-plaintext highlighter-rouge">HOC</code>같은 상위의 컴포넌트를 export 할 수 있다. 만약 리턴된 형태가 class라면 상태는 리셋된다.</p>
  </li>
  <li>
    <p>익명 화살표함수는 Fast Refresh를 local component state에 저장하지 않는다. 더 큰 코드인 경우에는 <code class="language-plaintext highlighter-rouge">name-default-component</code>를 사용 할 수 있다.</p>
  </li>
</ul>

<h3 id="tips">Tips</h3>

<p>Fast Refresh는 React local state를 함수 컴포넌트로 예약한다</p>

<table>
  <tbody>
    <tr>
      <td>만약 강제로 상태를 초기화하고 싶을 수가 있다. <code class="language-plaintext highlighter-rouge">// @refresh reset</code>과 같이 초기화 할 수 있다.</td>
    </tr>
  </tbody>
</table>

<h3 id="fast-refresh-and-hooks">Fast Refresh and Hooks</h3>

<p>가능하다면 Fast Refresh는 수정중에 컴포넌트에 상태 정보를 저장한다. 특히 <code class="language-plaintext highlighter-rouge">useState</code> 와 <code class="language-plaintext highlighter-rouge">useRef</code> 같은 경우에, 인자나 Hook call을 하지 않는 이상 이전값을 저장하고 있다.</p>

<p><code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useMemo</code>, <code class="language-plaintext highlighter-rouge">useCallback</code> 같은 의존성이 있는 Hook 같은 경우에는, Fast Refresh중에 항상 update 된다. 이러한 의존성들은 Fast Refresh가 일어나고 있는중에 무시된다. 예를들어, <code class="language-plaintext highlighter-rouge">useMemo(() =&gt; x * 2, [x])</code> 가 <code class="language-plaintext highlighter-rouge">useMemo(() =&gt; x * 10, [x])</code> 로 변환다면, x가 변하지 않았음에도 불구하고 재실행 된다.</p>

<p>위와 같은 방법은 예상치못한 결과를 낳을 수 있다. 예를들어 <code class="language-plaintext highlighter-rouge">uesEffect</code>가 빈 배열을 줄 수 도 있다. 하지만, 이런 탄력적인 코드를 사용하는것은 좋은 연습이 된다.</p>

<h2 id="typescript">TypeScript</h2>

<h3 id="typescript로-npx-설정하는법">TypeScript로 npx 설정하는법</h3>

<p>새로 설정하는것이라면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx create-next-app@latest <span class="nt">--ts</span>
<span class="c"># or</span>
yarn create next-app <span class="nt">--typescript</span>
<span class="c"># or</span>
pnpm create next-app <span class="nt">--</span> <span class="nt">--ts</span>
</code></pre></div></div>

<p>이미 있는 프로젝트에 삽입한다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">touch </span>tsconfig.json
</code></pre></div></div>

<h3 id="static-generation--server-side-rendering">Static Generation &amp; Server-side Rendering</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">GetStaticProps</span><span class="p">,</span> <span class="nx">GetStaticPaths</span><span class="p">,</span> <span class="nx">GetServerSideProps</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStaticProps</span><span class="p">:</span> <span class="nx">GetStaticProps</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStaticPaths</span><span class="p">:</span> <span class="nx">GetStaticPaths</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getServerSideProps</span><span class="p">:</span> <span class="nx">GetServerSideProps</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="api-routing">API Routing</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">NextApiResponse</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">(</span><span class="nx">req</span><span class="p">:</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">NextApiResponse</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John Doe</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>혹은</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">NextApiResponse</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">(</span><span class="nx">req</span><span class="p">:</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">NextApiResponse</span><span class="o">&lt;</span><span class="nx">Data</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John Doe</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>와 같이 사용 할 수 있다.</p>

<h3 id="custom-app">Custom <code class="language-plaintext highlighter-rouge">App</code></h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">AppProps</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/app</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">}:</span> <span class="nx">AppProps</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="ignoring-typescript-errors">Ignoring TypeScript Errors</h3>

<p>Next.js는 TypeScript 에러가 존재 할 시 build 에서 오류를 낸다.</p>

<p>만약 이러한 오류에도 불구하고 사용을 하고 싶다면 다음과 같이 사용하면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">next.config.js</code>에서 <code class="language-plaintext highlighter-rouge">ignoreBuildErrors</code>를 켜주면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//next.config.js</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">typescript</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// !! WARN !!</span>
    <span class="c1">// Dangerously allow production builds to successfully complete even if</span>
    <span class="c1">// your project has type errors.</span>
    <span class="c1">// !! WARN !!</span>
    <span class="na">ignoreBuildErrors</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Static File Serving]]></summary></entry><entry><title type="html">NEXT-Optimization</title><link href="http://localhost:4000/next.js/2022/05/04/next-optimization.html" rel="alternate" type="text/html" title="NEXT-Optimization" /><published>2022-05-04T00:00:00+09:00</published><updated>2022-05-04T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/04/next-optimization</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/04/next-optimization.html"><![CDATA[<h2 id="image-component-and-image-optimization">Image Component and Image Optimization</h2>

<p><code class="language-plaintext highlighter-rouge">next/image</code> 에서의 Next의 이미지 컴포넌트는 HTML에서 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 의 연장선이라 볼 수 있다. 더 좋은 Web 환경을 위해 더 좋은 효율과 압축성을 보여준다. 이러한 효율성은 웹사이트 사용에 있어 UX 적으로 도움이 된다.</p>

<blockquote>
  <p>SEO 측면에서도 도움이 된다</p>
</blockquote>

<p>이러한 효율성은 크게 4가지로</p>

<ol>
  <li>
    <p>Improve Perforamce : 모든 장치마다 최신 이미지 포맷을 사용하여 정확한 사이즈를 전달한다</p>
  </li>
  <li>
    <p>Visual Stability : CLS(Cumulative Layout Shift)를 방지한다</p>
  </li>
</ol>

<blockquote>
  <p>CLS란 누적 레이아웃 변경으로, 웹페이지를 보는 사용자에게 예상치 못한 화면 변환이 나타나는 빈도 수</p>
</blockquote>

<ol>
  <li>
    <p>Faster Page Loads : 이미지가 <code class="language-plaintext highlighter-rouge">viewport</code>에 접근 시 로딩되어, 빠르고, 로딩 전 blur-up placeholder 를 설정 할 수 있다.</p>
  </li>
  <li>
    <p>Asset Flexibility : 다른 서버에 이미지가 있는 경우에도, 원하는대로 이미지 리사이징이 자유롭다</p>
  </li>
</ol>

<h3 id="local-images">Local Images</h3>

<p>이미지의 예제는 다음과 같다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">profilePic</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../public/me.png</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="p">{</span><span class="nx">profilePic</span><span class="p">}</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="c1">// width={500} automatically provided</span>
        <span class="c1">// height={500} automatically provided</span>
        <span class="c1">// blurDataURL="data:..." automatically provided</span>
        <span class="c1">// placeholder="blur" // Optional blur-up while loading</span>
      <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">import</code> 하는 과정이 정적이 되어야 build 과정에서 분석이 되기에 <code class="language-plaintext highlighter-rouge">await import()</code> 혹은 <code class="language-plaintext highlighter-rouge">require()</code>같은 동적인 행동은 지원하지 않는다.</p>

<table>
  <tbody>
    <tr>
      <td>width 와 height 가 자동으로 고정 된 이유는 CLS를 방지하기 위함이다</td>
    </tr>
  </tbody>
</table>

<h3 id="remote-images">Remote Images</h3>

<p>외부에 있는 이미지를 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">src</code>로 위치를 잘 가져와야한다. Next.js같은 경우 build 과정에서 외부로 접근 할 권한이 없으므로 아까 전과는 달리 <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, <code class="language-plaintext highlighter-rouge">blurDataURL</code> 을 넣어 줘야한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="nx">width</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">height</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
      <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="domains">Domains</h3>

<p>가끔 외부의 이미지를 사용하면서도 Next.js의 최적화 기법을 사용하고 싶을 수 있다. <code class="language-plaintext highlighter-rouge">loader</code>를 기본으로 두고, <code class="language-plaintext highlighter-rouge">src</code>에 절대경로 URL을 넣어 사용 할 수 있다.</p>

<p>어플을 외부로부터 보호하기 위해 아래와 같이 <code class="language-plaintext highlighter-rouge">next.config.js</code>파일을 사용하여 외부 도메인으로 바로 접근하는것을 막을 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="k">export</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">images</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">domains</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">071yoon.github.io</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">github.com/071yoon</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="loaders">Loaders</h3>

<p>앞서 <a href="#remote-images">Remote Images</a> 에서처럼 URL의 부분만 쓰는 경우 (<code class="language-plaintext highlighter-rouge">'/me.png'</code>) 는 <code class="language-plaintext highlighter-rouge">next/image</code> 의 loader의 구조상 가능한 부분이다.</p>

<p><code class="language-plaintext highlighter-rouge">Loader</code>는 이미지의 URL을 만들어 주는 기능을 한다. 제공된 <code class="language-plaintext highlighter-rouge">src</code>에 root domain 까지 추가 후 image를 다른 사이즈로 여러 URL을 만들어 연결 요청을 보낸다. 이러한 URL들은 srcset을 만들어내고, 방문자는 각자 <code class="language-plaintext highlighter-rouge">viewport</code>에 맞는 사이즈의 이미지를 볼 수 있게 된다.</p>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>의 default loader는 <code class="language-plaintext highlighter-rouge">built-in Image Optimization API</code>를 사용했고, 웹의 어디에서나 이미지를 최적화 할 수 있었고, 바로 Next.js의 웹 서버에 보냈다. 만약 이미지를 CDN 이나 이미지 서버에 바로 보내고 싶다면, <code class="language-plaintext highlighter-rouge">built-in loader</code>를 사용하거나, 자바스크립트에서 따로 추가를 해야된다.</p>

<p>이러한 로더는 Application Level 에서 이미지당 하나씩 정의가 된다.</p>

<h3 id="priority">Priority</h3>

<p>이미지에 <code class="language-plaintext highlighter-rouge">priority</code>란 속성을 넣어 매 페이지마다 LCP element를 가지게 할 수 있다. 즉 Next.js가 이미지 로딩의 우선순위를 둘 수 있다.</p>

<blockquote>
  <p>LCP : Largest Contentful Paint로 페이지의 메인 컨텐츠가 로드되었을 가능성이 있을 때 페이지 로드 타임라인에 해당 시점을 표시하여 사용자가 감지하는 로드 속도를 측정할 수 있는 메트릭스 -&gt; LCP가 빠르다 = 해당 페이지를 사용할 수 있다</p>
</blockquote>

<p>LCP element는 보통 viewport 에서 가장 큰 이미지거나 텍스트로 본다. <code class="language-plaintext highlighter-rouge">next dev</code> 실행시에, <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> 에 <code class="language-plaintext highlighter-rouge">priority</code>가 설정되어 있지 않다면, Next는 자체적으로 경고창을 띄운다. 예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="nx">width</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">height</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">priority</span>
      <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="image-sizing">Image Sizing</h2>

<p>이미지가 성능에 영향을 미치는 경우는 보통 <code class="language-plaintext highlighter-rouge">layout shift</code>가 일어났을 때 이다. 이러한 <code class="language-plaintext highlighter-rouge">layout shift</code>는 이미지가 로딩되면서 다른 요소들을 밀치고 삽입되는 경우이다. 이런 문제는 Client 입장에서 매우 불편하고 <code class="language-plaintext highlighter-rouge">CLS</code>를 일으킨다. 이러한 문제를 해결하는법은 언제나 이미지의 사이즈를 조정하는것이다. 그럼으로써 브라우저딴에서 항상 로딩되기 전에 이미지의 자리를 예약 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">next/image</code>가 항상 좋은 성능을 위해 디자인 되었으므로, <code class="language-plaintext highlighter-rouge">layout shift</code> 현상은 일어나서는 안된다. 즉 아래 세가지 규칙중 하나를 사용해야 된다.</p>

<ol>
  <li>
    <p>static import를 사용</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">width</code> 와 <code class="language-plaintext highlighter-rouge">height</code> 요소를 사용</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout="fill"</code>을 사용</p>
  </li>
</ol>

<p>3번 같은 경우 내 이미지의 사이즈를 모를 때 사용한다. parent element 사이즈만큼 image가 사이즈될 수 있게 설정하게 된다. 그럼 <code class="language-plaintext highlighter-rouge">objectFit property</code> 를 <code class="language-plaintext highlighter-rouge">fill</code>, <code class="language-plaintext highlighter-rouge">contain</code>, <code class="language-plaintext highlighter-rouge">cover</code>, <code class="language-plaintext highlighter-rouge">objectPosition property</code>와 함께 사용하여 얼마나 이미지가 차지해야되는지 알 수 있다.</p>

<p>만약 내가 아는 소스에서 이미지를 가져오는 것이라면, image의 pipeline을 일반화 하는것이 좋다.</p>

<p>만약 API call 을 사용하여 이미지를 가져온다면, API call 을 중간에 수정하여 URL과 함께 이미지의 크기를 리턴하는것이 가능하다.</p>

<p>만약 위 3가지의 방법을 사용하지 않는다면 <code class="language-plaintext highlighter-rouge">next/image</code>는 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>와 차이가 없다.</p>

<h2 id="styling">Styling</h2>

<p>Styling 같은 경우에 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>와 크게 다를것 없지만, 주의사항이 몇가지 존재한다.</p>

<ol>
  <li>
    <p>올바른 layout mode 설정하기</p>
  </li>
  <li>
    <p>이미지를 className으로 지정하기 (DOM 구조에 맞추지 말것)</p>
  </li>
</ol>

<p>보통 layout에서 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 는 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>에 둘러싸여 있다. 이러한 추가적인 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>은 layout shift를 만드는 주된 원인이다. 즉 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>에 <code class="language-plaintext highlighter-rouge">className</code>을 붙여 CSS Module을 사용하는것이 일반적이다. 혹은, <code class="language-plaintext highlighter-rouge">className</code>을 사용하여 <code class="language-plaintext highlighter-rouge">global stylesheet</code>를 사용할 수 도 있다.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout='fill'</code>을 한다면 <code class="language-plaintext highlighter-rouge">position:relative</code> 도 함께 사용해야된다</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout='responsive'</code>를 사용할 시 <code class="language-plaintext highlighter-rouge">display:block</code>을 같이 사용할 것</p>
  </li>
</ol>

<h2 id="font-optimization">Font Optimization</h2>

<p>버전 <code class="language-plaintext highlighter-rouge">10.2</code> 부터 Next.js 는 built-in web font optimization 을 지원하게 되었다.</p>

<p>일반적으로 Next.js는 자동으로 CSS를 빌드타임에 넣어, 추가적인 반복작업을 피한다. 이렇게 함으로써 FCP 와 LCP에 도움이 된다.</p>

<table>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FCP(First Contentful Paint)</code>란 페이지가 로드되기 시작한 시점부터 컨텐츠의 일부가 화면에 렌더링 될 때까지의 시간 <code class="language-plaintext highlighter-rouge">LCP(Largest Contentful Paint)</code>란 페이지가 로드되기 시작한 시점부터 뷰포트 내부의 가장 큰 이미지 또는 텍스트의 렌더링까지 걸리는 시간</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before</span>
<span class="o">&lt;</span><span class="nx">link</span>
  <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span>
  <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">stylesheet</span><span class="dl">"</span>
<span class="o">/&gt;</span>

<span class="c1">// After</span>
<span class="o">&lt;</span><span class="nx">link</span> <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">preconnect</span><span class="dl">"</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.gstatic.com</span><span class="dl">"</span> <span class="nx">crossorigin</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">style</span> <span class="nx">data</span><span class="o">-</span><span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="p">@</span><span class="nd">font</span><span class="o">-</span><span class="nx">face</span><span class="p">{</span><span class="nx">font</span><span class="o">-</span><span class="nx">family</span><span class="p">:</span><span class="dl">'</span><span class="s1">Inter</span><span class="dl">'</span><span class="p">;</span><span class="nx">font</span><span class="o">-</span><span class="nx">style</span><span class="p">:</span><span class="nx">normal</span><span class="p">...</span>
<span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span></code></pre></div></div>

<h3 id="usage">Usage</h3>

<p>Webfont 를 Next.js에 넣으려면 <code class="language-plaintext highlighter-rouge">Document</code>안에 폰트를 삽입하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/_document.js</span>

<span class="k">import</span> <span class="nx">Document</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Html</span><span class="p">,</span> <span class="nx">Head</span><span class="p">,</span> <span class="nx">Main</span><span class="p">,</span> <span class="nx">NextScript</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/document</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">MyDocument</span> <span class="kd">extends</span> <span class="nx">Document</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Head</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">link</span>
            <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span>
            <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">stylesheet</span><span class="dl">"</span>
          <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="sr">/Head</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">MyDocument</span><span class="p">;</span>
</code></pre></div></div>

<p>특이한점은 해당 폰트는 특정한 페이지에만 사용되므로 <code class="language-plaintext highlighter-rouge">next/head</code>를 사용하지 않는다는 점이다. 현재 Automatic Webfont Optimization 은 Google Fonts에 의해 지원된다.</p>

<h3 id="disabling-optimization">Disabling Optimization</h3>

<p>Font Optimization 을 끄는 방식은 아래와 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// next.config.js</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimizeFonts</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Image Component and Image Optimization]]></summary></entry><entry><title type="html">NEXT-Layouts</title><link href="http://localhost:4000/next.js/2022/04/28/next-layouts.html" rel="alternate" type="text/html" title="NEXT-Layouts" /><published>2022-04-28T00:00:00+09:00</published><updated>2022-04-28T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/28/next-layouts</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/28/next-layouts.html"><![CDATA[<h2 id="layouts">Layouts</h2>

<p>React는 페이지를 컴포넌트로 나누는것이 가능하다. 이러한 컴포넌트들은 페이지간에 재사용이 가능하고, 예를 들어, 모든 페이지마다 같은 네비게이션바를 사용한다.</p>

<h3 id="single-shared-layout-with-custom-app">Single Shared Layout with Custom App</h3>

<p>만약 전체 어플에 대하여 하나의 레이아웃만 사용한다면, Custom App 을 만들어, 해당 레이아웃으로 둘러 쌀 수 있다. 해당 컴포넌트가 모든 페이지마다 재사용되므로, 이러한 컴포넌트의 상태정보는 계속 유지된다.</p>

<table>
  <tbody>
    <tr>
      <td>예를 들어, input value가 들어와도 고정된다</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Layout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/layout</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="per-page-layout">Per-Page Layout</h3>

<p>만약 여러 레이아웃이 필요한 경우에, <code class="language-plaintext highlighter-rouge">getLayout</code> 이라는 property를 사용 할 수 있다. 컴포넌트안에 getLayout을 사용해서, 표현할지 안할지로 정해서 사용 가능하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Layout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/layout</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">NestedLayout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/nested-layout</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Page</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="cm">/** Your content */</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">Page</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">getLayout</span><span class="p">(</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">NestedLayout</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">page</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/NestedLayout</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이렇게 선언 후 실제로 사용할 때는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Use the layout defined at the page level, if available</span>
  <span class="kd">const</span> <span class="nx">getLayout</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">||</span> <span class="p">((</span><span class="nx">page</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">page</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">getLayout</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<p>타입스크립트를 이용하면 Props의 type에 주의해야된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">}:</span> <span class="nx">AppPropsWithLayout</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Use the layout defined at the page level, if available</span>
  <span class="kd">const</span> <span class="nx">getLayout</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">??</span> <span class="p">((</span><span class="nx">page</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">page</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">getLayout</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="data-fetching">Data Fetching</h3>

<p>레이아웃안에, Client-Side에서 <code class="language-plaintext highlighter-rouge">useEffect</code>로 데이터를 가져올 수 도 있고, 라이브러리를 활용하여 <code class="language-plaintext highlighter-rouge">SWR</code>(React Query와 유사)로 가져올 수 도 있다. 하지만, Page가 아니기에, <code class="language-plaintext highlighter-rouge">getStaticProps</code>나 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>를 사용 할 수는 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">swr</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Navbar</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./navbar</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Footer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./footer</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Layout</span><span class="p">({</span> <span class="nx">children</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/navigation</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Failed</span> <span class="nx">to</span> <span class="nx">load</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">Navbar</span> <span class="nx">links</span><span class="o">=</span><span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">links</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">main</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/main</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Layouts]]></summary></entry><entry><title type="html">NEXT-Built-In CSS</title><link href="http://localhost:4000/next.js/2022/04/27/next-built-in-css.html" rel="alternate" type="text/html" title="NEXT-Built-In CSS" /><published>2022-04-27T00:00:00+09:00</published><updated>2022-04-27T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/27/next-built-in-css</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/27/next-built-in-css.html"><![CDATA[<h2 id="global-stylesheet">Global Stylesheet</h2>

<p>프로젝트에 <code class="language-plaintext highlighter-rouge">stylesheet</code>를 추가하려면, <code class="language-plaintext highlighter-rouge">pages/_app.js</code> 라는 CSS 파일을 import 해야된다.</p>

<p>우선 다음과 같이 <code class="language-plaintext highlighter-rouge">style.css</code>를 만들었다 보면</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">body</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="nb">sans-serif</span><span class="p">;</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">20px</span> <span class="m">20px</span> <span class="m">60px</span><span class="p">;</span>
  <span class="nl">max-width</span><span class="p">:</span> <span class="m">680px</span><span class="p">;</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span> <span class="nb">auto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 실제 page 에서 import 하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">'</span><span class="s1">../style.css</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span><span class="o">&gt;</span> <span class="sr">/</span><span class="err">&gt;
</span><span class="p">}</span>
</code></pre></div></div>

<p>그럼 스타일이 위에서 선언한 <code class="language-plaintext highlighter-rouge">style.css</code> 처럼 적용이 된다.</p>

<table>
  <tbody>
    <tr>
      <td>global한 문제가 있기에 오직 하나만 import 해야 된다! 여기서는 <code class="language-plaintext highlighter-rouge">pages/_app.js</code></td>
    </tr>
  </tbody>
</table>

<h2 id="import-styles-from-node_modules">Import styles from <code class="language-plaintext highlighter-rouge">node_modules</code></h2>

<p>Next.js 9.5.4 버전부터는 <code class="language-plaintext highlighter-rouge">node_modules</code>에 CSS 파일을 넣는것이 가능해졌다. 만약 <code class="language-plaintext highlighter-rouge">bootstrap</code>이나 <code class="language-plaintext highlighter-rouge">nprogress</code> 같은 global stylesheet를 사용한다면, <code class="language-plaintext highlighter-rouge">pages/_app.js</code> 에서 import를 미리 해두어야 한다.</p>

<p><code class="language-plaintext highlighter-rouge">Third Party</code> 컴포넌트를 사용한다면, 다음과 같이 정의 할 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>Third Party란 프로그래밍시 도와주는 플러그인 혹은 라이브러리를 만드는 회사</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// components/ExampleDialog.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Dialog</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reach/dialog</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">VisuallyHidden</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reach/visually-hidden</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">@reach/dialog/styles.css</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">ExampleDialog</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">showDialog</span><span class="p">,</span> <span class="nx">setShowDialog</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">open</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setShowDialog</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">close</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setShowDialog</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">open</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Open</span> <span class="nx">Dialog</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Dialog</span> <span class="nx">isOpen</span><span class="o">=</span><span class="p">{</span><span class="nx">showDialog</span><span class="p">}</span> <span class="nx">onDismiss</span><span class="o">=</span><span class="p">{</span><span class="nx">close</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">close-button</span><span class="dl">"</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">close</span><span class="p">}</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">VisuallyHidden</span><span class="o">&gt;</span><span class="nx">Close</span><span class="o">&lt;</span><span class="sr">/VisuallyHidden</span><span class="err">&gt;
</span>          <span class="o">&lt;</span><span class="nx">span</span> <span class="nx">aria</span><span class="o">-</span><span class="nx">hidden</span><span class="o">&gt;</span><span class="err">×</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">there</span><span class="p">.</span> <span class="nx">I</span> <span class="nx">am</span> <span class="nx">a</span> <span class="nx">dialog</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/Dialog</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="component-level-css">Component-Level CSS</h2>

<p>Next.js는 <code class="language-plaintext highlighter-rouge">[name].module.css</code> 이라는 파일 컨벤션을 이용하여 CSS Module을 공식적으로 지원한다. CSS 모듈은 자동으로 unique class 이름을 만들어 생성하며, 이는 충돌을 방지하기 위함이다. 즉 이런식으로 사용하면, component-level 에서 사용하기 더욱 쉬워진다. 그리고 이러한 CSS Module은 파일 어디에서 import 되어도 사용 가능해진다!</p>

<p>예를들어, 재사용 가능한 <code class="language-plaintext highlighter-rouge">Button</code> 이라는 컴포넌트가 <code class="language-plaintext highlighter-rouge">components/</code>안에 있다 가정하고 다음을 보자.</p>

<p>우선 <code class="language-plaintext highlighter-rouge">components/Button.module.css</code>를 만든다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.error</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>후, <code class="language-plaintext highlighter-rouge">components/Button.js</code>를 만들어, 방금 제작한 CSS를 import 하면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">styles</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Button.module.css</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">Button</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">button</span>
      <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">button</span><span class="dl">"</span>
      <span class="c1">// Note how the "error" class is accessed as a property on the imported</span>
      <span class="c1">// `styles` object.</span>
      <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">error</span><span class="p">}</span>
    <span class="o">&gt;</span>
      <span class="nx">Destroy</span>
    <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이러한 CSS Module을 사용하는것은 추가적인 기능이고, 편히 global CSS를 사용하여도 무방하다.</p>

<p>정적 build시에, 이러한 모든 CSS Module 들이 자동으로 분할되어지는데, 최종적으로 프로그램 딴에서 css 파일의 무게를 줄이기 위함이다.</p>

<h2 id="sass-support">Sass Support</h2>

<p>Next.js는 Sass도 물론 지원한다. <code class="language-plaintext highlighter-rouge">.scss</code> 와 <code class="language-plaintext highlighter-rouge">.sass</code> 둘 다 지원하며, 마찬가지로 모듈화를 하여 <code class="language-plaintext highlighter-rouge">.module.scss</code> 와 <code class="language-plaintext highlighter-rouge">.module.sass</code> 로 사용할 수 있다.</p>

<p>간단한 Sass의 예제로 보면 다음과 같다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* variables.module.scss */</span>
<span class="err">$</span><span class="nt">primary-color</span><span class="o">:</span> <span class="err">#64</span><span class="nt">FF00</span>

<span class="nd">:export</span> <span class="p">{</span>
  <span class="py">primarycolor</span><span class="p">:</span> <span class="err">$</span><span class="n">primary-color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/_app.js</span>
<span class="k">import</span> <span class="nx">variables</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../styles/variables.module.scss</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span> <span class="nx">color</span><span class="o">=</span><span class="p">{</span><span class="nx">variables</span><span class="p">.</span><span class="nx">primaryColor</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="css-in-js">CSS in JS</h2>

<p>내가 주로 사용하는 방식인 CSS-in-JS 방식이다.</p>

<p>우선 사용하려면 <code class="language-plaintext highlighter-rouge">styled-jsx</code> 파일을 번들해야하며, 목적은 <code class="language-plaintext highlighter-rouge">shadow CSS</code>를 지원하여 마치 웹 컴포넌트처럼 사용하기 위함이다. 아쉽게도 SSR를 지원하지 않고, JS만 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">styled jsx</code>의 예제는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">HelloWorld</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="nx">Hello</span> <span class="nx">world</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">scoped</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">style</span> <span class="nx">jsx</span><span class="o">&gt;</span><span class="p">{</span><span class="s2">`
        p {
          color: blue;
        }
        div {
          background: red;
        }
        @media (max-width: 600px) {
          div {
            background: blue;
          }
        }
      `</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">style</span> <span class="nb">global</span> <span class="nx">jsx</span><span class="o">&gt;</span><span class="p">{</span><span class="s2">`
        body {
          background: black;
        }
      `</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">HelloWorld</span><span class="p">;</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Global Stylesheet]]></summary></entry><entry><title type="html">NEXT-Pages</title><link href="http://localhost:4000/next.js/2022/04/25/next-pages.html" rel="alternate" type="text/html" title="NEXT-Pages" /><published>2022-04-25T00:00:00+09:00</published><updated>2022-04-25T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/25/next-pages</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/25/next-pages.html"><![CDATA[<p>아래는 Next.js 공식문서의 번역본입니다</p>

<p><a href="https://nextjs.org/docs/basic-features/pages">공식문서</a></p>

<h2 id="pages">Pages</h2>

<p>Next.js 의 <code class="language-plaintext highlighter-rouge">Page</code> 는 <code class="language-plaintext highlighter-rouge">React Component</code> 로써, <code class="language-plaintext highlighter-rouge">.js</code>, <code class="language-plaintext highlighter-rouge">.jsx</code>, <code class="language-plaintext highlighter-rouge">.ts</code>, <code class="language-plaintext highlighter-rouge">.tsx</code> 의 형태로 존재한다.</p>

<h3 id="pre-rendering">Pre-rendering</h3>

<p>Next.js 는 매 페이지마다 <code class="language-plaintext highlighter-rouge">pre-render</code>를 지원한다. 즉 Next는 Client가 자바스크립트로 처리하는것이 아니라 매 페이지마다 HTML 을 만들어낸다. 즉 여기서 성능과 <a href="2022-04-24-why-next-js.md">SEO</a> 측면에서 더 좋다. 이렇게 만들어진 HTML은 정말 페이지에 필요한 자바스크립트 코드만 들어가 있으며, 브라우저에서 로딩이 되면, 해당 자바스크립트 코드로 상호작용을 할 수 있다. -&gt; <code class="language-plaintext highlighter-rouge">hydration</code></p>

<p>Pre-rendering 에는 두가지 방법이 존재하는데, <code class="language-plaintext highlighter-rouge">Static Generation</code> 과 <code class="language-plaintext highlighter-rouge">Server-side Rendering</code>이 있다. <a href="2022-04-24-why-next-js.md">SSR</a>같은 경우에는, 저번 포스트에서 설명을 하였으므로 넘어가고, 이번에는 Next에서 공식적으로 추천하는 Static Generation 방법에 대해서 알아보자.</p>

<h3 id="ssg">SSG</h3>

<p>어떠한 페이지가 <code class="language-plaintext highlighter-rouge">Static Generation</code> 이라면, 해당 페이지의 HTML은 빌드시간에 생성된다고 할 수 있다. 즉 <code class="language-plaintext highlighter-rouge">next build</code> 명령어의 실행과 동시에 페이지의 HTML이 만들어진다고 ㅂ로 수 있다. 그리고 이러한 HTML은 CDN(Contents Delivery Network)을 통하여 캐시 될 수 있다.</p>

<p>Next.js 는 기본적으로 데이터 fetching을 제외한 <code class="language-plaintext highlighter-rouge">Static Generation</code>으로 작동한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">About</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">About</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">About</span><span class="p">;</span>
</code></pre></div></div>

<p>아래와 같은 함수는 fetch 할 data가 없으니 바로 HTML로 변환되어 정적으로 하나의 HTML이 나올 것이다!</p>

<p>그럼 Data가 있는 경우를 살펴보자</p>

<p>Data가 있는 경우에 두가지로 쪼갤 수 있다. 1. page의 content가 외부 데이터에 의존할 때 (<code class="language-plaintext highlighter-rouge">getStaticProps</code>) 2. page의 path가 외부 데이터에 의존할 때 (<code class="language-plaintext highlighter-rouge">getStaticPaths</code>)</p>

<h4 id="1-content가-의존성일-때">1. content가 의존성일 때</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Blog</span><span class="p">({</span> <span class="nx">posts</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Blog</span><span class="p">;</span>
</code></pre></div></div>

<p>이러한 형태의 함수를 보낼시에, Next.js 는 async 를 export 하게 도와준다. <code class="language-plaintext highlighter-rouge">getStaticProps</code> 란 함수를 불러 사용이 가능하며, <code class="language-plaintext highlighter-rouge">pre-render</code> 과정에서, data를 fetch하게 도와준다. 그럼 수정본 코드를 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Blog</span><span class="p">({</span> <span class="nx">posts</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">posts</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Blog</span><span class="p">;</span>
</code></pre></div></div>

<p>언제 <code class="language-plaintext highlighter-rouge">getStaticProps</code>를 사용할까?</p>

<ol>
  <li>
    <p>data가 user의 request전에 rendering에 필요로 할 때!</p>
  </li>
  <li>
    <p>data가 headless CMS에서 올 때</p>
  </li>
  <li>
    <p>data가 외부적으로 캐시가 가능할 때</p>
  </li>
  <li>
    <p>페이지가 빨리 pre-render 되어아 할 때</p>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">getStaticProps</code> 가 오직 Server-Side 에서 작동하기에, Client 딴에서는 절대 실행이 되어서는 안된다. 심지어 브라우저에서는, JS bundle에 포함도 안되어 있다. 즉 API route에서 가져온다기보다, Server딴에서 코드를 바로 넣어 줄 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">getStaticProps</code>는 페이지에서만 만들어져야된다! 즉 component딴에서는 호출되면 안됨!</p>

<h4 id="2-path가-의존성일-때">2. path가 의존성일 때</h4>

<p>앞서 말했다시피 Next.js는 <code class="language-plaintext highlighter-rouge">dynamic routes</code>를 허용한다. 예를들어 file route가 <code class="language-plaintext highlighter-rouge">pages/posts/[id].js</code> 라면, <code class="language-plaintext highlighter-rouge">posts/1</code> 에 접속 시 <code class="language-plaintext highlighter-rouge">id: 1</code> 로 접근이 가능할것이다.</p>

<p>이러한 접근을 하려면 <code class="language-plaintext highlighter-rouge">async</code> 를 <code class="language-plaintext highlighter-rouge">export</code> 하는 함수 즉 <code class="language-plaintext highlighter-rouge">getStaticPaths</code>를 사용하여 가능하다.</p>

<p>path의 pre-render과정을 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Post</span><span class="p">({</span> <span class="nx">post</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Render post...</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticPaths</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Call an external API endpoint to get posts</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="c1">// Get the paths we want to pre-render based on posts</span>
  <span class="kd">const</span> <span class="nx">paths</span> <span class="o">=</span> <span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">params</span><span class="p">:</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">post</span><span class="p">.</span><span class="nx">id</span> <span class="p">},</span>
  <span class="p">}));</span>

  <span class="c1">// 빌드 할 시에만 path 로 pre-render</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">paths</span><span class="p">,</span> <span class="na">fallback</span><span class="p">:</span> <span class="kc">false</span> <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// 이것도 빌드시에 사용</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">({</span> <span class="nx">params</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// 다이나믹하게 작동한다</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`https://.../posts/</span><span class="p">${</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">post</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="c1">// Pass post data to the page via props</span>
  <span class="k">return</span> <span class="p">{</span> <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="nx">post</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Post</span><span class="p">;</span>
</code></pre></div></div>

<p>언제 <code class="language-plaintext highlighter-rouge">getStaticPaths</code>를 사용할까?</p>

<p>보통 dynamic route를 통하여 정적으로 페이지를 pre-render 하며</p>

<ol>
  <li>
    <p>headless CMS에서 데이터가 올 때(모니터가 연결되어있지 않거나, 키보드나 마우스 등의 주변장치가 연결되어있지 않은 서버)</p>
  </li>
  <li>
    <p>DB 에서 데이터가 올 때</p>
  </li>
  <li>
    <p>FIlesystem 에서 데이터가 올 때</p>
  </li>
  <li>
    <p>데이터가 외부로 캐시가능할 때</p>
  </li>
  <li>
    <p>페이지가 매우 빠르게 pre-render 되어야 할 때</p>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">getStaticProps</code>는 <code class="language-plaintext highlighter-rouge">HTML</code> 과 <code class="language-plaintext highlighter-rouge">JSON</code> 파일을 만들어, CDN으로 캐시 될 수 있다</li>
    </ol>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">getStaticPaths</code>는 오직 빌드 과정에서만 돌며, 런타임 환경에서는 작동하지 않는다. 오직, <code class="language-plaintext highlighter-rouge">getStaticProps</code>를 쓰는 다이나믹 루트를 통해서만 export 될 수 있으며, non-page file에서 export 할 수 없다! (ex. components)</p>

<h3 id="ssr">SSR</h3>

<p>SSR이란, 매 HTML 페이지가 매번 요청시에 Server 측에서 만들어 준다는 것이다. 즉 Server에 가는 부담이 커질 수 밖에 없다.</p>

<p>이건 <code class="language-plaintext highlighter-rouge">export</code> 와 <code class="language-plaintext highlighter-rouge">async</code> 를 활용한 <code class="language-plaintext highlighter-rouge">getServerSideProps</code> 란 함수를 사용하여 구현할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Page</span><span class="p">({</span> <span class="nx">data</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Render data...</span>
<span class="p">}</span>

<span class="c1">// 매번 불러온다</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getServerSideProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Fetch data from external API</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`https://.../data`</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="c1">// props 로 data 불러오기</span>
  <span class="k">return</span> <span class="p">{</span> <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="nx">data</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Page</span><span class="p">;</span>
</code></pre></div></div>

<p>자세히 보면, <code class="language-plaintext highlighter-rouge">getStaticProps</code> 와 매우 유사해 보이지만, 차이점은 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>는 build 시에 처음만 하는것이 아닌 매번 요청마다 작동한다는 점이다!</p>

<p>즉 <code class="language-plaintext highlighter-rouge">getServerSidePRops</code>는, 오직 Server-Side 에서만 굴러가고, 브라우저딴에서는 실행하지 않는다. 순서를 보면 다음과 같다.</p>

<ol>
  <li>
    <p>어떠한 페이지를 request 한다</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">getServerSideProps</code> 가 요청시에 실행된다</p>
  </li>
  <li>
    <p>해당 props와 같이 페이지가 pre-render 된다.</p>
  </li>
  <li>
    <p>링크를 통하여, 해당 페이지를 Client-Side에 요청시에 Next.js가 Server에 API 요청을 보내 <code class="language-plaintext highlighter-rouge">getServerSidePRops</code>를 실행한다.</p>
  </li>
</ol>

<p>그럼 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>는 페이지 렌더링에 필요한 JSON을 리턴하고, 이러한 부분들은 Next.js 에서 자동을 해준다!</p>

<p>중요한 부분은 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>를 독립적인 함수로 빼서 export 해야된다. 만약 page component 안에 넣어두면 제대로 작동하지 앟는다.</p>

<p>그럼 언제 사용할까? 한 페이지를 data가 fetch되는 request time 에 렌더링을 할 때 사용한다. 만약, request 시간에 렌더링을 할 필요가 없다면 Client Side 나 <code class="language-plaintext highlighter-rouge">getStaticProps</code>를 사용하는게 더 효율적이다.</p>

<h3 id="incremental-static-regeneration">Incremental Static Regeneration</h3>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 사이트의 빌드 후 static page를 만들거나 업데이트를 허용해준다. 사용되는 기능이 ISR(Incremental Static Regeneration)이며, 전체 사이트를 다시 build 하지 않아도, static-generation을 허용해준다.</p>

<p>사용하기 위해서는 다음과 같이 <code class="language-plaintext highlighter-rouge">getStaticProps</code>에 <code class="language-plaintext highlighter-rouge">revalidate</code>를 사용해야 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Blog</span><span class="p">({</span> <span class="nx">posts</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//serverside 에서 빌드되는 함수</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">pros</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">posts</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="c1">// ! 10초에 한번씩 OR request 가 들어오면 page를 re-generate 하려한다</span>
    <span class="na">revalidate</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">//마찬가지로 server-side 에서 build시 실행</span>
  <span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticPaths</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

    <span class="kd">const</span> <span class="nx">paths</span> <span class="o">=</span> <span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="na">params</span><span class="p">:</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">post</span><span class="p">.</span><span class="nx">id</span> <span class="p">},</span>
    <span class="p">}));</span>

    <span class="c1">//build 시에 이것만! pre-render 한다!</span>
    <span class="c1">// {fallback: blocking} 은 server-render</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">paths</span><span class="p">,</span> <span class="na">fallback</span><span class="p">:</span> <span class="dl">"</span><span class="s2">blocking</span><span class="dl">"</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">export</span> <span class="k">default</span> <span class="nx">Blog</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 코드를 해석해보면, request 요청이 와서 build 시간에 page가 만들어진다면, cache 된 page를 보여준다.</p>

<ol>
  <li>
    <p>첫 요청 후 10초안의 다른 요청들은 cache에 저장된다</p>
  </li>
  <li>
    <p>10초 후, 다음 요청은 아직도 cache된 정보를 보여준다 -&gt; stale (바꼈을 수 도 있음!)</p>
  </li>
  <li>
    <p>Next.js가 페이지에 regeneration을 건다</p>
  </li>
  <li>
    <p>page가 정상적으로 만들어졌다면, Next.js가 캐시를 사용하지 못하게 막은 후, 업데이트된 페이지를 보여준다!</p>
  </li>
</ol>

<table>
  <tbody>
    <tr>
      <td>만약 4번에서 실패했다면, 예전 페이지가 바뀌지 않았을 것이다</td>
    </tr>
  </tbody>
</table>

<h3 id="on-demand-revalidation">On-demand Revalidation</h3>

<p>만약 <code class="language-plaintext highlighter-rouge">revalidate</code> 시간을 60으로 잡는다면, 모든 방문자들은 1분동안 모두 같은 버전을 볼것이다. 여기서 유일하게 캐시를 비활성화 하는 방법은 다른 사람이 1분후에 접속을 하는것이다.</p>

<p>Next.js 의 <code class="language-plaintext highlighter-rouge">12.1.0</code> 버전 이후, on-demand Incremental Static Regenration을 지원하며, 사이트의 업데이트를 더 손쉽게 사용할 수 있게 해준다.</p>

<ol>
  <li>
    <p>headless CMS의 정보가 만들어지거나 업데이트됨</p>
  </li>
  <li>
    <p>Metadata 변화를 알아챔</p>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">getStaticProps</code>안에, <code class="language-plaintext highlighter-rouge">revalidate</code>를 명시해주지 않아도, 된다. 만약 빠졌다면, Next.js가 자동으로 FALSE로 주고, <code class="language-plaintext highlighter-rouge">unstable-revalidate</code>요청시에만 업데이트를 진행한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">secret</span> <span class="o">!==</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">MY_SECRET_TOKE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">401</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">message</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Invalid token</span><span class="dl">"</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">unstable_revalidate</span><span class="p">(</span><span class="dl">"</span><span class="s2">path-to-revalidate</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="na">revalidated</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">500</span><span class="p">).</span><span class="nx">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error revalidating</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="client-side-data-fetching-with-useeffect">Client-side data fetching with useEffect</h3>

<p>React 에서는 data fetching 을 하기 위해 SWR을 지원한다. 우선 SWR에 대해서 알아보자.</p>

<h4 id="swr">SWR</h4>

<p>SWR은 stale-while-revalidate의 약자로, 먼저 캐시(Stale한 상태)에서 데이터를 받고, fetch 요청 후 최종적으로 최신 데이터를 가져오는 전략이다.</p>

<p>간단한 코드를 보면 다음과 같다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">swr</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Profile</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/user</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">failed</span> <span class="nx">to</span> <span class="nx">load</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">hello</span> <span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">!&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<p>위의 코드를 보면, <code class="language-plaintext highlighter-rouge">useSWR</code>은 <code class="language-plaintext highlighter-rouge">key</code> 와 <code class="language-plaintext highlighter-rouge">fetcher</code>를 받아, 고유한 식별자가 <code class="language-plaintext highlighter-rouge">fetcher</code>로 전달되는 것이다. 주된 장점들은 다음과 같다.</p>

<ul>
  <li>빠르고, 가볍고, 재사용 가능한 데이터 가져오기</li>
  <li>내장된 캐시 혹은 요청의 중복을 제거</li>
  <li>실시간으로 이루어진다</li>
  <li>전송 및 프로토콜에 상관없음</li>
  <li>SSR/ ISR/ SSG 모두 사용 가능</li>
  <li>TypeScript에 적용된다</li>
</ul>

<p>그럼 이러한 SWR을 이용하여 profile data를 더 손쉽게 가져 올 수 있다. 그럼 SWR의 캐시로 데이터를 활용하는 코드를 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">swr</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">fetcher</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">fetch</span><span class="p">(...</span><span class="nx">args</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>

<span class="nx">functoin</span> <span class="nx">Profile</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/profile-data</span><span class="dl">'</span><span class="p">,</span> <span class="nx">fecther</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Failed</span> <span class="nx">to</span> <span class="nx">load</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">bio</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[아래는 Next.js 공식문서의 번역본입니다]]></summary></entry><entry><title type="html">NEXT</title><link href="http://localhost:4000/next.js/2022/04/24/why-next-js.html" rel="alternate" type="text/html" title="NEXT" /><published>2022-04-24T00:00:00+09:00</published><updated>2022-04-24T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/24/why-next-js</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/24/why-next-js.html"><![CDATA[<h2 id="next-란-무엇인가">NEXT 란 무엇인가?</h2>

<p><code class="language-plaintext highlighter-rouge">Next</code>란 간단하게 말하면, SSR을 쉽게 구현하도록 도와주는 프레임워크이다. SSR 이란 Server Side Rendering의 약자로, 쉽게 말하면, Server 딴에서 렌더링 과정을 해준다는 것이다. 그와 반대대는 개념으로는 CSR 즉 Client Side Rendering 이 존재한다.</p>

<h3 id="ssr-vs-csr">SSR vs CSR</h3>

<p>React 로 렌더링방식의 차이를 알아보자면, 우선 일반적으로는 <code class="language-plaintext highlighter-rouge">render()</code> 라는 함수가 실행 된 후 <code class="language-plaintext highlighter-rouge">componentDidMount()</code> 함수를 실행하여 다시 한번 더 렌더링이 된다. 그에 반에, Next 같은 경우에는 getInitialProps() 라는 함수를 먼저 호출하여 데이터를 렌더링을 우선으로 해준다. 이러한 CSR 은 SPA 의 구동방식이라고도 말한다. SPA는 Single Page 를 서버측에 제공하고, View 에서는 Client 딴에서 라이브러리 혹은 프레임워크를 사용하여 렌더링하는 방식이다. SSR의 장점으로는 초기로딩 속도가 빠르지만, 단점으로는 page 이동시에는 CSR 보다 느리다.</p>

<table>
  <tbody>
    <tr>
      <td>page 요청마다 중복되는 파일을 내려받아야 되기 때문!</td>
    </tr>
  </tbody>
</table>

<p>하지만 CSR 같은 경우, 초기로딩 속도가 느린것에 비해 첫 로딩에 모든 파일을 내려받아, 이동시에 필요한 데이터만 불러 사용하여 더 빠르다고 할 수 있다!</p>

<h3 id="next-의-작동-원리">Next 의 작동 원리</h3>

<p>하지만 React 는 SPA 적인 페이지를 구현하기 위한 라이브러리이다. 그럼 전통적으로 CSR 인데, 어떻게 Next는 React기반을 SSR로 구현할 수 있을까?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 사용자가 Server에 페이지 접속 요청시 SSR 방식으로 렌더링 된 HTML 을 전송
2. 브라우저에서 JavaScript 다운로드 후 React 실행
3. 사용자와 페이지가 상호작용 후 이동시에는 Client딴에서 처리
</code></pre></div></div>

<h2 id="why-next">Why Next?</h2>

<h3 id="search-engine-optimization">Search Engine Optimization</h3>

<p><code class="language-plaintext highlighter-rouge">Next</code>를 사용하면 <code class="language-plaintext highlighter-rouge">SEO</code> 혹은 <code class="language-plaintext highlighter-rouge">검색 엔진 최적화</code>가 가능하다! 사실 SSR을 이용하는 이유또한 SEO를 하기 위함이라고도 볼 수 있다.</p>

<p>SEO를 함으로써, 브라우저에 노출이 잘 되므로 마케팅 혹은 서비스적인 면에서 무조건 고려해봐야 되는 사항이라 볼 수 있다. 그럼 왜 CSR은 SEO 에서 불리할까? 그건 Search Engine 의 작동원리로 설명 할 수 있다.</p>

<h3 id="검색-엔진-작동원리">검색 엔진 작동원리</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 검색엔진이 데이터 크롤링 시 JavaScript 파일을 해석 할 수 없어 HTML 파일에서 크롤링한다
2. CSR 인 경우에는 Client가 받기전에, HTML에는 빈 문서이므로, 데이터를 받아 올 수 없다
3. SSR 같은 경우, 이미 HTML에 데이터가 포함이 되어있어, 데이터 수집에 용이하다!
</code></pre></div></div>

<p>즉 초기에 SSR을 함으로써, SEO에 용이하며 브라우저에서 JavaScript를 다운 후 React를 실행하여 다른 페이지로 이동시 CSR방식으로 작동하여 브라우저에서 처리할 때 SPA의 장점 또한 유지 할 수 있다!!</p>

<h3 id="code-splitting">Code Splitting</h3>

<p><code class="language-plaintext highlighter-rouge">Code Splitting</code> 또한 Next.js 를 사용하는 주된 이유이다. 그럼 코드 분할이 무엇일까? 우선 기본적인 프로젝트로 생각을 해보자. JavaScript 프로젝트를 생성하면 React 같은 경우 모든 코드를 하나의 Bundle로 받고 실행한다. 규모가 작은 프로젝트라면 문제가 없지만, 만약 프로젝트의 규모가 커질수록, 브라우저가 파싱해야되는 정보가 많아지므로 CPU의 처리속도가 느리거나 메모리가 낮은 기기일 경우 초기 구동속도가 느려질 수 밖에 없다.</p>

<p>이러한 번들링 작업을 Bundle을 동적으로 생성해주는 코드 분할을 제공하면 해결 할 수 있다. 코드 분할을 사용함으로써 Lazy Loading을 해결 할 수 있고, 필요하지 않은 코드들을 로딩하지 않아, 초기 로딩에 필요한 자원또한 줄여 줄 수 있다.</p>

<h3 id="hot-module-replacement">Hot Module Replacement</h3>

<p>HMR 이란 브라우저를 새로고침하지 않고 Webpack으로 빌드한 결과물을 실시간으로 반영시켜주는 설정이다. 즉 새로고침하지 않아도, Module을 Runtime중에 업데이트 시켜준다는 것이다.</p>

<p>즉 Webpack의 엄청나게 느린 build 과정을 더 줄여 줄 수 있다. 하지만 Vite를 쓴다면 그냥 해결이 되지 않을까…?</p>

<p><a href="https://ivorycode.tistory.com/entry/Nextjs를-사용하는-이유">참고링크1</a></p>

<p><a href="https://medium.com/@msj9121/next-js-제대로-알고-쓰자-8727f76614c9">참고링크2</a></p>

<p><a href="https://dtaxi.tistory.com/1090">참고링크2</a></p>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[NEXT 란 무엇인가?]]></summary></entry></feed>