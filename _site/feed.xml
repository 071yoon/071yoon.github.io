<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-03T14:59:57+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YeongGi’s tech blog</title><subtitle>This is YeongGi&apos;s tech blog. I post IT related items.</subtitle><author><name>071yoon</name></author><entry><title type="html">몬티 홀 문제</title><link href="http://localhost:4000/deep-thought/2022/02/03/monty-hall.html" rel="alternate" type="text/html" title="몬티 홀 문제" /><published>2022-02-03T00:00:00+09:00</published><updated>2022-02-03T00:00:00+09:00</updated><id>http://localhost:4000/deep-thought/2022/02/03/monty-hall</id><content type="html" xml:base="http://localhost:4000/deep-thought/2022/02/03/monty-hall.html"><![CDATA[<h2 id="몬티-홀-문제">몬티 홀 문제</h2>

<hr />

<h3 id="문제-분석">문제 분석</h3>

<p>몬티 홀 문제는 영화 <code class="language-plaintext highlighter-rouge">21</code>에서 처음 공개된 아이디어이다. 잠깐 문제를 보고 가자면</p>

<blockquote>
  <p>Suppose you’re on a game show, and you’re given the choice of three doors. Behind one door is a car, behind the others, goats. You pick a door, say #1, and the host, who knows what’s behind the doors, opens another door, say #3, which has a goat. He says to you, “Do you want to pick door #2?” Is it to your advantage to switch your choice of doors?</p>
</blockquote>

<blockquote>
  <p>당신이 한 게임 쇼에 참여하여 세 문들 중 하나를 고를 기회를 가졌다고 생각해봐라. 한 문 뒤에는 자동차가 있으며, 다른 두 문 뒤에는 염소가 있다. 당신은 1번 문을 고르고, 문 뒤에 무엇이 있는지 아는 사회자는 염소가 있는 3번 문을 연다. 그는 당신에게 “2번 문을 고르고 싶습니까?”라고 묻는다. 당신의 선택을 바꾸는 것은 이득이 되는가?</p>
</blockquote>

<p>즉 간단히 말하면</p>

<ol>
  <li>문 3개가 있는데 한 문 뒤에는 자동차가 있고 나머지 두 문 뒤에는 염소가 있다. 참가자는 이 상황에서 문을 하나 선택하여 그 뒤에 있는 상품을 얻는다.</li>
  <li>참가자가 어떤 문을 선택하면 사회자는 나머지 두 문 중에 염소가 있는 문 한 개를 열어 참가자에게 그 문에 염소가 있다고 확인시켜준다.</li>
  <li>그 후 사회자는 참가자에게 선택한 문을 닫혀있는 다른 문으로 선택을 바꿀 기회를 준다.</li>
</ol>

<p>얼핏보기에는 정말 간단해 보이는 문제고 나도 처음 문제를 접했을 때는 엥?? 이게 왜 이렇게 핫한 주제일까 라는 생각까지 했다. 하지만 여기서 중요한 점은 <code class="language-plaintext highlighter-rouge">사회자는 어디에 스포츠카가 있는지 알고있다</code> 라는것이 조건부 확률의 전제로 들어간다는 것이다. 정말 단순해 보이는 문제인데, 어째서 이게 많은 수학자들에게 항의 메일이 오도록 했을까??</p>

<blockquote>
  <p>IQ 200 인 사람도 처음에 틀리고, 노벨상 수상자 까지 문제가 잘못됐다고 메일을 보냈다고 한다…!!</p>
</blockquote>

<h3 id="my-thoughts">My Thoughts</h3>

<hr />

<p>우선 정답은 바꾸었을 때의 확률이 2/3 이고, 바꾸지 않았을 때의 확률은 1/3이므로, 당연히 바꾸는 것이 확률적으로 맞다!!</p>

<p>이제, 나의 처음 접근을 한번 살펴보자. 아마 많은 사람들일 나처럼 생각했겠지만, 당연히 50프로라고 생각을 했다. 그리고 이건 부끄러운 생각이 절대 아니다. 직관적으로 생각을 해보면 그렇기 때문이다. 내가 우선 선택을 하였고, 사회자가 둘중 하나를 오픈을 해 주었다. 그 시점을 독립사건으로 본다고 하면, 나는 둘중 하나를 개봉하는것이기 때문에, 확률은 마치 반반처럼 보이지만, 그렇게 단순한 문제가 아니다. 왜냐하면 확률적으로 접근을 해야하기 때문이다.</p>

<p>만약 처음에 내가 선택을 하지 않고, 사회자가 둘중 하나를 열어 준 다음 내가 선택을 하면 독립사건이 되어 50% 확률이 되는것이 수학적으롤도 맞다. 하지만, 내가 처음에 선택을 하였기 때문에, 바꾸지 않고 우승할 확률은 무조건 1/3 확률이고, 바꾸었을 때의 확률은 2/3이 된다. 여기서 중요한점은</p>

<ol>
  <li>사회자는 어디에 자동차에 있는지 이미 알고있다</li>
  <li>내가 처음 선택을 하였다</li>
</ol>

<p>이렇게 두가지가 전제조건으로 나와있어야 조건부 확률로 성립을 한다는 것이다. 만약 사회자가 둘중 하나에 에라이~! 하고 아무거나 열어버린다면 자동차가 나올 수가 있고, 내가 처음 선택을 하지않았다면, 사회자가 어떤 문을 열어야 할 지 선택 할 지 모르기 때문에 전제가 틀려버린다. 아마 많은 사람들이 헷갈린 부분이 이러한 전제조건의 여부가 정확하게 확립되지 않아 헷갈린 것 같다. 하지만 이런식으로 이야기를 하여도 직관적으로 보기엔 정말 어렵다. 그러때는 역시 묻지마 코딩이 정답이다. C++ 로 코딩을 하면서 차근차근 왜 이러하게 나오지는 살펴보자</p>

<h3 id="몬티-홀-문제-시뮬레이션-via-c">몬티 홀 문제 시뮬레이션 via C++</h3>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

int main(){
	srand(time(NULL));

	int monty_sum = 0;
	int dont_change_sum = 0;
	int test_case = 0;
	char simul_on;
	cout &lt;&lt; "simulation counts : ";
	cin &gt;&gt; test_case;
	cout &lt;&lt; "check every simulations? (y/n) ";
	cin &gt;&gt; simul_on;
	for(int i = 0; i &lt; test_case; i++){
		int chosen_door = rand() % 3;
		int correct_door = rand() % 3;
		if (simul_on == 'y')
			cout &lt;&lt; "TEST CASE " &lt;&lt; i + 1 &lt;&lt; " Car is in " &lt;&lt; (char)(correct_door + 'A') &lt;&lt; " and my choice is " &lt;&lt; (char)(chosen_door + 'A') &lt;&lt; "\n";
		if (correct_door == chosen_door){
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall X and got correct\n";
			dont_change_sum += 1;
		}
		else{
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall X and got wrong\n";
		}
		if (correct_door == chosen_door){ // When you choose the coorect one at the first time -&gt; you will never be able to win
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall and got wrong\n";
			continue;
		}
		else if (correct_door != chosen_door){ // When you choose the wrong one at the first time -&gt; you will get it for sure when you change
			if (simul_on == 'y')
				cout &lt;&lt; "Monty-Hall and got right\n";
			monty_sum += 1;
		}
		// Since there is 1/3 possibility to win at the first time, possibility to get the prize is 2/3
	}
	cout &lt;&lt; "\nmonty possibility is : " &lt;&lt; ((double)monty_sum / (double)test_case) * (double)100 &lt;&lt; "%" &lt;&lt; "\ndon't change possibility is : " &lt;&lt; ((double)dont_change_sum / (double)test_case) * (double)100 &lt;&lt; "%" &lt;&lt; "\n";
}
</code></pre>

<p>최대한 간략하면서, 직관적으로 보이게 짜보려고 했는데, 잘 됐을 지 모르겠다.
테스트를 해본 결과 대략 10만번을 돌려보면, 66.95% 와 33.05% 가 나와 거의 2/3 과 1/3에 수렴하는것을 볼 수 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>simulation counts : 100000
check every simulations? <span class="o">(</span>y/n<span class="o">)</span> n

monty possibility is : 66.95%
don<span class="s1">'t change possibility is : 33.05%
</span></code></pre></div></div>

<p>여기서 시뮬레이션에 <code class="language-plaintext highlighter-rouge">y</code> 를 주면 실제 테스트케이스별로 확인도 할 수 있다.</p>

<p>코드를 한번 설계를 해보면 왜 그런지 확실하게 알 수 있는데 확실하게 정의를 할 수 있다. 내가 몬티 홀을 믿고 무조건 바꾼다고 가정을 해보자. 그럼 당연하게 두가지 상황이 나온다.</p>

<ol>
  <li>내가 맞음</li>
  <li>내가 틀림</li>
</ol>

<p>자동차를 개봉하기 전 확률상으로 보면 내가 맞을 확률은 1/3, 그리고 내가 틀릴 확률은 2/3 이다.</p>

<p>여기서 만약 바꾸지 않고 똥고집을 부려 유지를 한다면, 그대로 1/3 확률로 나올 것이다. 하지만 바꾼다면 내가 처음에 틀린 경우 즉 2번으로 시작해서 무조건 맞으므로 맞을 확률이 2/3이 된다.</p>

<p>이제 그럼 매우 간단한 로직으로 설명을 들 수 있다. 내가 몬티홀을 무조건 믿고 바꾼다고 생각을 해보자</p>

<ol>
  <li>내가 처음에 맞으면 무조건 틀림</li>
  <li>내가 처음에 틀리면 무조건 맞음</li>
</ol>

<p>이렇게 설명 할 수 있다. 왜냐면 내가 바꿈으로써 나는 2개의 문을 동시에 확인하는 셈이 되어 버리기 때문이다. 그래서 처음에 맞을 확률 1/3, 처음에 틀릴 확률이 2/3 이므로 시뮬레이션을 돌려도 동일하게 나오는 것이다.</p>

<p>사람의 말로만 들으면 충분히 헷갈릴 수 있다. 컴퓨터 공학도라면 직접 시뮬레이션을 돌려보며 생각을 해보는 것이 이해에 더 도움이 될거라 생각한다.</p>

<h3 id="후기">후기</h3>

<p>나무위키나 블로그들을 보면, 정말 많은 사람들이 다양한 이유로 다양한 설명들을 해놓은 것을 볼 수 있다. 그 중에, 수학적으로 접근을 하여 베이즈의 확률론으로 정리를 해놓은 사람, 혹은 경우의 수로 정리 한 사람, 문이 100개라고 가정을 하고 생각을 해보라는 사람.</p>

<blockquote>
  <p>잘 생각해보면 확률론으로 정리해놓은 것 빼고는 다 증명을 할 수 없는 말들이다</p>
</blockquote>

<p>하지만 이렇게 똑똑이들이 해놓은 증명을 보고도 이해가 잘 안된다면, 무작정 시뮬레이션을 해보고 코딩을 하며 문제를 더 완벽히 파악하고 큰 문제를 짧게 쪼개며 단순화 하는것이 더 도움이 될 수 있다는 생각이 든다.</p>]]></content><author><name>071yoon</name></author><category term="deep-thought" /><category term="deep-thought" /><category term="TIL" /><summary type="html"><![CDATA[몬티 홀 문제]]></summary></entry><entry><title type="html">리액트JS로 앱 만들기 1</title><link href="http://localhost:4000/react/2022/02/02/make-react-app-1.html" rel="alternate" type="text/html" title="리액트JS로 앱 만들기 1" /><published>2022-02-02T00:00:00+09:00</published><updated>2022-02-02T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/02/02/make-react-app-1</id><content type="html" xml:base="http://localhost:4000/react/2022/02/02/make-react-app-1.html"><![CDATA[<h2 id="react란-무엇인가">React란 무엇인가</h2>

<p>React는 간단하게 말해서, 웹의 <code class="language-plaintext highlighter-rouge">Framework</code>이다.</p>

<blockquote>
  <p>정확하게는 사용자 인터페이스를 만들기 위한 Javascript Library</p>
</blockquote>

<p>그리고 <code class="language-plaintext highlighter-rouge">React</code> 란 놈에게는 큰 장점이 있다.</p>

<ol>
  <li>선언형</li>
  <li>컴포넌트 기반</li>
</ol>

<p>이렇게 볼 수 있다.</p>

<h3 id="선언형">선언형</h3>

<hr />

<p>선언형은 React는 상호작용이 많은 UI를 만들 때 생기는 어려움을 줄여준다. 즉 애플리케이션의 각 상태에 대한 간단한 뷰만 설계를 한다면 알아서 React가 데이터가 변경됨에 따라 적절한 컴포넌트만 효율적으로 갱신하고 렌더링을 해준다. 즉 말 그대로 <code class="language-plaintext highlighter-rouge">React</code> 하게 해준다는 것이다.</p>

<p>간단하게 보면, <code class="language-plaintext highlighter-rouge">React</code> 파일에서</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
  <span class="dl">"</span><span class="s2">button</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="na">onClick</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">im clicked</span><span class="dl">"</span><span class="p">),</span>
  <span class="p">},</span>
  <span class="dl">"</span><span class="s2">Click me</span><span class="dl">"</span>
<span class="p">);</span>
</code></pre></div></div>

<p>이런식으로 HTML 으로 선언하지 않고도 단번에 생성과 동시에 옵션을 설정 할 수 있다.</p>

<h3 id="컴포넌트-기반">컴포넌트 기반</h3>

<hr />

<p>스스로 상태를 관리하는 캡슐화된 컴포넌트를 만들 수 있다.</p>

<p>여기서 상태를 관리한다는 말이 리액트에서는 꽤나 중요한 포인트라 할 수 있다. 우선 리액트 컴포넌트는 <code class="language-plaintext highlighter-rouge">render()</code> 함수를 이용하여, 데이터를 입력받아 화면에 표시할 내용을 리턴을 한다는 점에서 자바스크립트와 다르다. 그리고 이러한 컴포넌트는 <code class="language-plaintext highlighter-rouge">this.props</code>를 이용하여 입력 데이터를 다루고, <code class="language-plaintext highlighter-rouge">this.state</code>로 접근 할 수 있다. 그리고 상태 데이터가 바뀌면 <code class="language-plaintext highlighter-rouge">render()</code> 가 다시 호출되어 갱신이 되는 구조이다.</p>

<p>말로 들어서는 이해가 잘 되지 않고, 역시 예제를 보며 학습을 하는것이 필요할 것 같다.</p>

<p>또하나의 큰 장점을 <code class="language-plaintext highlighter-rouge">React Native</code> 로의 방향이 자유롭다는 것이다. <code class="language-plaintext highlighter-rouge">Native</code> 언어란, iOS app 에서 Swift 처럼 그 자체의 OS 를 활용하여 만드는 앱인데, 물론 제작을 하여도 진짜 Native 급으로 속도가 나오지는 않는다. 하지만, 그와 비슷한 속도를 낼 수 있고 문법 자체가 너무나도 비슷해서, 금방 금방 수정하여 웹뿐만이 아닌 페이스북 혹은 인스타그램 처럼 웹앱으로 변환이 가능하다.</p>

<h3 id="jsx-의-활용">JSX 의 활용</h3>

<p>JSX 가 나옴으로써, <code class="language-plaintext highlighter-rouge">React</code> 가 단순히 Javascript 처럼 활용하는것이 아니라, 마치 <code class="language-plaintext highlighter-rouge">HTML</code> 에서 사용한 것 처럼도 사용 할 수 있게 되었다. 이것또한 예제를 보고 확인해보자</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Title</span> <span class="o">=</span> <span class="p">(</span>
  <span class="p">&lt;</span><span class="nt">h3</span> <span class="na">id</span><span class="p">=</span><span class="s">"title"</span> <span class="na">onMouseEnter</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">mouse enter</span><span class="dl">"</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
    Hello I am a title
  <span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
<span class="p">);</span>
</code></pre></div></div>

<p>이런식으로 <code class="language-plaintext highlighter-rouge">CreateElement</code> 를 사용하는것이 아니라, 마치 <code class="language-plaintext highlighter-rouge">HTML</code> 에서 태그를 해서 만드는것인데, 동시에 자바스크립트를 활용하여 만들 수 있게 되었다. 하지만 코드를 잘 보면 <code class="language-plaintext highlighter-rouge">CreateElement</code> 를 아예 안쓰는 것은 아니고, 이런식으로 <code class="language-plaintext highlighter-rouge">HTML</code> 처럼 편하게 적어두면 <code class="language-plaintext highlighter-rouge">BABEL</code> 이란 컴파일러에서 내부적으로 <code class="language-plaintext highlighter-rouge">CreateElement</code> 형으로 변환을 하여 적어주는 것이다.</p>

<blockquote>
  <p>여기서 중요한점은 함수나 변수명을 할 때 대문자로 시작을 해야 실제 HTML 의 태그 <code class="language-plaintext highlighter-rouge">button</code> 같은것과 헷갈리지 않는다</p>
</blockquote>

<h3 id="state-란">State 란</h3>

<p>기본적으로 데이터가 저장되는 곳이라고 보면 쉽다.</p>

<p>간단한 클릭형 버튼을 만들어서 확인해보자</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span> <span class="p">=</span> <span class="s">"text/babel"</span><span class="p">&gt;</span>
	const root = document.getElementById("root");
	let counter = 0;
	function countUp()<span class="si">{</span>
		<span class="nx">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="si">}</span>
	function Container() <span class="si">{</span>
		<span class="k">return</span> <span class="p">(</span>
			<span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span> Total Clicks: <span class="si">{</span><span class="nx">counter</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">countUp</span><span class="si">}</span><span class="p">&gt;</span>Click me<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
			<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
		<span class="p">);</span>
	<span class="si">}</span>
	ReactDom.render(<span class="p">&lt;</span><span class="nc">Container</span> <span class="p">/&gt;</span>, root);
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>이렇게만 보면 좋은 코드같아 보인다. 하지만 여기는 맹점이 있는데, 바로 Rendering 을 한번밖에 하지 않아, 아무리 클릭을 눌러도 웹상에서는 안보이는다는 것이다. 그래서 <code class="language-plaintext highlighter-rouge">State</code> 가 필요하게 된다.</p>

<p>가장 손쉬운 방법은 countUp 함수가 할 때마다, <code class="language-plaintext highlighter-rouge">Render</code> 를 다시 불러주게 되면 해결 할 수 있다. 하지만 아무리봐도, 효율적인 부분이 아니다. 왜냐면 전부 다 렌더링을 하는것이 비효율적이고, 계속 렌더링을 해줘야되는것을 함수를 만들면서 생각을 하면서 설계를 해줘야 되기 떄문이다. 그럼 <code class="language-plaintext highlighter-rouge">그 변수</code>만 업데이트를 하려면 어떻게 해야될까?? 그게 바로 <code class="language-plaintext highlighter-rouge">React</code> 의 최대 장점이다. 즉 매우 <code class="language-plaintext highlighter-rouge">Interactive</code> 하고 <code class="language-plaintext highlighter-rouge">Effective</code> 한 프로그램이 만들어 지는것이다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span> <span class="p">=</span> <span class="s">"text/babel"</span><span class="p">&gt;</span>
	const root = document.getElementById("root");
	function Container() <span class="si">{</span>
		<span class="kd">let</span> <span class="p">[</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">modifier</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="c1">//counter = data[0], modifier = data[1]</span>
		<span class="kd">const</span> <span class="nx">onClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
			<span class="nx">modifier</span><span class="p">(</span><span class="nx">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="c1">//OR modifier((current) =&gt; current + 1);</span>
		<span class="p">};</span>
		<span class="k">return</span> <span class="p">(</span>
			<span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span> Total Clicks: <span class="si">{</span><span class="nx">counter</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
				<span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">onClick</span><span class="si">}</span><span class="p">&gt;</span>Click me<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
			<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
		<span class="p">);</span>
	<span class="si">}</span>
	ReactDom.render(<span class="p">&lt;</span><span class="nc">Container</span> <span class="p">/&gt;</span>, root);
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>이렇게 설정하면, 클릭이 일어날 때 마다, modifier에서 counter + 1 로 해준 값이 반환되며, <code class="language-plaintext highlighter-rouge">modify</code> 가 일어날 때 마다, 딱 그 부분만 렌더링을 해주는 것이다.</p>

<h3 id="props">Props</h3>

<p>Props 란 부모 컴포넌트로부터 자식 컴포넌트로에게 데이터를 보낼 수 있게 해주는 방법이다.</p>

<blockquote>
  <p>Ex) 버튼의 스타일을 하나하나 다 바꿔주지 말고, 어차피 공통으로 갈거면 그러한 템플릿을 저장해 두었다가 사용하면 더 편하지 않겠냐 라는 것..!!</p>
</blockquote>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Btn</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">reutnr</span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">button</span>
      <span class="na">styles</span><span class="p">=</span>
    <span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">text</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Btn</span> <span class="na">text</span><span class="p">=</span><span class="s">"Save changes"</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">Btn</span> <span class="na">text</span><span class="p">=</span><span class="s">"Continue"</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 사용 할 수 있다.</p>

<h3 id="react-memo">React Memo</h3>

<p>위 예제를 보면 버튼이 <code class="language-plaintext highlighter-rouge">Save Changes</code> 와 <code class="language-plaintext highlighter-rouge">Continue</code> 두개가 생성되었다. 하지만 만약, <code class="language-plaintext highlighter-rouge">State</code>를 활용하여, 첫 버튼만 렌더를 해주려고 해도, 두 버튼 다 렌더링이되는 불상사가 발생한다. 이러한 사태를 어떻게 막을 수 있을까?? 리액트 메모를 활용하여 막을 수 있다.</p>

<blockquote>
  <p>const MemorizedBtn = React.memo(Btn);</p>
</blockquote>

<p>라고 활용하고나서, 그 후 Btn이 아니라 MemorizedBtn 으로 호출하면 렌더링을 한번만 해도 될 수 있게 된다!!</p>]]></content><author><name>071yoon</name></author><category term="react" /><category term="react" /><category term="javascript" /><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[React란 무엇인가]]></summary></entry><entry><title type="html">The mind behind linux</title><link href="http://localhost:4000/deep-thought/2022/01/26/deep-thoughts-1.html" rel="alternate" type="text/html" title="The mind behind linux" /><published>2022-01-26T00:00:00+09:00</published><updated>2022-01-26T00:00:00+09:00</updated><id>http://localhost:4000/deep-thought/2022/01/26/deep-thoughts-1</id><content type="html" xml:base="http://localhost:4000/deep-thought/2022/01/26/deep-thoughts-1.html"><![CDATA[<h2 id="talk-is-cheap-show-me-the-code">Talk is cheap. Show me the code.</h2>

<p><code class="language-plaintext highlighter-rouge">Linus</code>의 전설적인 명언이다. 컴퓨터 공학도라면 한번쯤은 들어봤을 이름 <code class="language-plaintext highlighter-rouge">리누스 토르발스</code>. 내가 이 이름을 처음 들었던 것은 <code class="language-plaintext highlighter-rouge">System Programming</code> 과목에서 <code class="language-plaintext highlighter-rouge">Linux</code> 를 처음 배울 때 였다. 처음 <code class="language-plaintext highlighter-rouge">Linux</code>를 접했을 때는, 엥?? 이게 뭐지?? 싶을정도로 기괴했고, <code class="language-plaintext highlighter-rouge">CLI</code> 를 처음 접했던 나는 정말 적응하기가 힘들었다. 하지만 사용하면 사용 할 수록, 그가 왜 이러한 운영체제를 만들었고, 어떤생각을 하고있는지 이해를 하기 시작했고, 사람에대한 관심이 생겨 찾아보다 <code class="language-plaintext highlighter-rouge">Ted talk</code> 에서 이야기 한 것을 보게되었고, 그에따른 이야기를 조금 해보려고 한다.</p>

<h2 id="who-is-linus">Who is Linus?</h2>

<p>리누스가 뭐하는 사람인가. 이름에서 알 수 있다시피 <code class="language-plaintext highlighter-rouge">Linux</code> 를 만든사람이다.</p>

<blockquote>
  <p>대학교때 교수님이 만든 OS를 다듬다 만들었다고 한다… ㄷㄷ</p>
</blockquote>

<p>그리고 무려 <code class="language-plaintext highlighter-rouge">Git</code> 을 만든 사람이다..!! 즉 오픈소스의 창시자라고 할 수 있는 사람이다. 아마 컴퓨터 공학도가 아니라면 체감이 안되겠지만, 이 사람이 없었더라면 다시말해서 <code class="language-plaintext highlighter-rouge">Linux</code> 와 <code class="language-plaintext highlighter-rouge">Git</code> 이 없었더라면 아마 현재는 우리가 살고있는 현재와 많이 다를 것이다. 일단 <code class="language-plaintext highlighter-rouge">Linux</code> 기반의 소프트웨어가 존재하지 않는다는점 -&gt; 우리의 일반적인 휴대폰이나 태블릿 기타등등 얼마나 퇴화했을지 모르는것이고, 오픈소스가 없었다면 개발자들이 아직도 책으로 공부하며 <code class="language-plaintext highlighter-rouge">Peer evluation</code>, 혹은 <code class="language-plaintext highlighter-rouge">code review</code> 없이 개발을 했을지도 모른다. 하지만 깃의 개발을 통해 우리가 좀 더 쉽게 누구나 어떤 코드에 접근 할 수 있게 되었다. 그리고 이러한 개발을 한 그의 사상은 역시나 남들과 다른데 한번 들어보자.</p>

<h2 id="ted-talk">Ted Talk</h2>

<p>21분짜리 Ted Talk를 듣고있으면, 상당히 딴소리도 많이 한다. 자신의 근무환경이 어떻고, 부실하며, 개그도 치고 자신의 신념에 대해서도 말한다.</p>

<blockquote>
  <p>고양이 그르릉 소리를 들어야돼서 컴퓨터가 팬 소음이 심하면 안된다고 한다… ㅋㅋ</p>
</blockquote>

<p>조금 더 본론으로 들어가, 자신이 어떻게 깃허브를 만들게 되었는지 설명하는 부분이 나온다. 애초에 리눅스가 협업을 해서 만든 프로젝트가 아니라고 설명하고, 거의 프로젝트가 완성이 되었을 때, 남들에게 보여주고 comment 를 받기 위해 만들었다고 한다. 처음에는 물론 <code class="language-plaintext highlighter-rouge">아 이게 상업적 용도로 쓰이면 어떡하지?</code> 라는 생각도 했다고 한다. 그럼에도 남들이 사용을 해보고, 누구나 <code class="language-plaintext highlighter-rouge">PR</code> 을 넣어서 수정을 할 수 있다는 장점이 더 크다고 판단해 만들었다고 한다. 그리고 여기서 리누스의 개그가 나오는데, 사실 깃은 사람들과 소통을 하기 위해서 만든게 아니라 소통을 피하기 위해 만들었다고 한다. 잉?? 이게 무슨 말일까.. 리누스의 명언을 보면 이해가 된다</p>

<p><code class="language-plaintext highlighter-rouge">Talk is cheap. Show me the code.</code></p>

<p>실제로 리누스가 깃을 만들 때, 21살이여서 사람 만나는거를 별로 안좋아 했다고 한다. MBTI는 I로 시작하는게 분명하다. 그래서 자랑을 하거나 리뷰를 받을 때도, 실제로 만나는것 보다, 사람이 사용해보고 코드로 review 를 해줄 수 있는 방법을 고안하다 나온 방법인 것 같다. 정말 컴퓨터 공학과인 사람이 생각할 만한 이유이고, 나도 너무나도 공감이 된다. 즉 본인이 깃허브를 만든 이유는 오직 리눅스를 만들다 우연히 만든거라고 했다.</p>

<blockquote>
  <p>근데 우연히 만든게 모든 세상 개발자의 중심지가 될줄이야..</p>
</blockquote>

<p>그리고 리누스의 어린시절 이야기도 잠깐 언급된다. 자신은 코딩을 10살 때 부터 했고, 똑똑한 편은 아니였다. 똑똑하다기 보다는 자신에게 생긴 일에 고집이 쎄고 자부심이 강했으며, 한번 시작한 일을 끝날 때 까지 놓지 않는 성격이라고 했다. 하지만 제 3자인 내가 보았을 때 리누스는 성공하는 개발자의 덕목을 모두 가지고 있는 것 처럼 보였다. 우선, 한번 일을 시작하면 고집마냥 틀어박혀서 끝날 때 까지 나오지 않는것, 그리고 호기심이 생기면 어떻게 해서든 해결을 하려고 하는것. 그리고 말만 그렇게 하였지, 개발에 대한 재능도 엄청나다고 생각한다. 어떤 재능없는 사람이 21살에 자신만의 OS 를 개발 할 수 있겠는가.</p>

<p>그리고 특히 더 대단한 것은, 보통 일반인으 개발자의 수명이 30중반 까지라고 한다. 그 이후가 되면, 머리도 굳고 힘에 부쳐 많이들 힘들어 한다고 한다. 그래서 보통 그 이후 SI 직군이나 소프트웨어 공학쪽으로 더 빠진다고 한다. 하지만 리누스의 개인 깃허브를 보면, 아직까지도 거의 매일매일 리눅스에대한 개발을 하고있다. 여전히 많은 사람들이 PR을 남겨주고, 매일매일 확인하며 그에 상응하는 대응을 해준다. 이정도의 부와 명예를 가지고 있다면, 충분히 다른 일을 찾아 나설 수 도 있지만, 본인이 이러한 개발을 좋아하고 보다 완벽한 것을 추구하기 떄문이라고 보인다.</p>

<p><code class="language-plaintext highlighter-rouge">Ted Talk</code> 중간에 코드를 잠깐 보여주고 어떤것이 좋은 코드인가에 대한 설명을 잠깐 한 적이 있다. 우선 코드를 한번 확인해 보자</p>

<pre><code class="language-C">remove_list_entry(enrty) {
	prev = NULL;
	walk = head;

	//Walk the list

	while (walk != entry) {
		prev = walk;
		walk = walk-&gt;next;
	}

	//Remove the entry by updating head or previous entry

	if (!prev)
		head = entry-&gt;next;
	else
		prev-&gt;next = entry-&gt;next;
}
</code></pre>

<pre><code class="language-C">remove_list_entry(entry) {
	//The "indirect" pointer points to the
	//address of the thing we'll update

	indirect = &amp;head;

	//Walk the list, looking for the thing that
	//points to the entry we want to remove

	while((*indirect) != entry)
		indirect = &amp;(*indirect)-&gt;next;

	//and remove
	*indrect = entry-&gt;next;
}
</code></pre>

<p>하단에 있는 코드는 실제로 리눅스에 있는 링크드 리스트에서 한 리스트를 삭제를 하는 과정을 보여주는 코드이다. 어떻게 보면 두 코드가 동일해 보이고, 실제로 동작을 하는 모습은 동일하다. 그리고 보통 우리는 첫번째 방법으로 코딩을 많이 한다. 포인터를 쓰는것이 아니라, 노드 두개를 가지고 하나씩 옮겨가며 삭제할 곳 까지 찾아간 다음 삭제하고 연결을 해주는 과정이다. 실제로 내가 보기에도 첫번째가 좀 더 보기가 쉽고, 직관적이라 생각을 했다.</p>

<blockquote>
  <p>내가 아직 코딩을 못해서 그런걸지도 모르지만, 아직도 포인터와 주소값을 왔다갔다하면 헷갈린다</p>
</blockquote>

<p>하지만 리누스는 오히려 두번째가 더 좋은 코드라고 설명을 한다. 애초에 <code class="language-plaintext highlighter-rouge">if</code>를 쓰지 않고도 할 수 있고, 예외처리가 아예 필요가 없어지는 경우라고 한다. 내가 한국어로 표현을 잘 못해 직접 내용을 인용해 오겠다.</p>

<p><code class="language-plaintext highlighter-rouge">that sometimes you can see a problem in a different way, and rewrite it so that a special case goes away and becomes the normal case. And that's the good code</code></p>

<p>즉 한 문제에 대해서 갇혀있는 생각만 하지말고, 다양한 생각과 다양한 시각으로 보면 더 간편하고 직관적이며, 효율이 좋은 코드가 나올 수 있다는 것이다.
항상 생각을 하고 행동을 하라는 의미로 받아들이고 싶다.</p>

<p>오늘은 컴퓨터공학의 정말 중요한 인물인 리누스 토르발스에 대해서 알아보았는데, 정말 배울점이 많고, 신념이 뚜렷한 사람 같아서 정말 보기 좋다. 이 테드영상 이후로도 몇가지의 영상을 찾아보았는데, 정말 자부심이 강하고 멋진 사람이라고 생각한다. 나도 언젠가 이렇게 자신의 신념을 가지고 행동 할 수 있으며, 그에 따른 무게의 책임질 수 있는 사람이 되고싶다.</p>]]></content><author><name>071yoon</name></author><category term="deep-thought" /><category term="deep thought" /><category term="linux" /><category term="philosophy" /><summary type="html"><![CDATA[Talk is cheap. Show me the code.]]></summary></entry><entry><title type="html">SQL 예제를 풀어보자</title><link href="http://localhost:4000/sql/2022/01/24/sql-practice.html" rel="alternate" type="text/html" title="SQL 예제를 풀어보자" /><published>2022-01-24T00:00:00+09:00</published><updated>2022-01-24T00:00:00+09:00</updated><id>http://localhost:4000/sql/2022/01/24/sql-practice</id><content type="html" xml:base="http://localhost:4000/sql/2022/01/24/sql-practice.html"><![CDATA[<h2 id="why-sql">Why SQL?</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">SQL</code>은 내가 데이터베이스 강의를 들을 때 잠깐 만져보고 처음 본 <code class="language-plaintext highlighter-rouge">Query</code> 언어이다. 그 당시에 효율이 정몰 좋고 데이터베이스 관리를 위해서 꼭 사용해야 하는 언어라고 배웠고, 실제로 <code class="language-plaintext highlighter-rouge">MariaDB</code> 를 활용한 웹을 만들어 보면서 왜 사용해야되는지 배워보았다. 그리고 <code class="language-plaintext highlighter-rouge">SQl</code> 을 펼쳐보지도 않은지 거의 두 세달 이 되어서, S/W Maestro 관련 글을 보던 중 코딩테스트에 <code class="language-plaintext highlighter-rouge">SQL</code>이 나온다는 소식을 들었다… ㅜㅜ 그래서 어쩔 수 없이 <code class="language-plaintext highlighter-rouge">SQL</code> 문제들을 살펴보던 중 프로그래머스에 <code class="language-plaintext highlighter-rouge">SQL</code> 문제들이 올라와 있는걸 보았고, 기본기를 다지는데 훌륭하다고 하여서 한번 풀어보기로 했다.</p>

<blockquote>
  <p>그리고 어차피 한번 리마인드 할 때 됐다!!</p>
</blockquote>

<p>문제풀기를 진행하며 까다로웠던 부분들을 다시 보자</p>

<h2 id="select">SELECT</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">SELECT</code>는 <code class="language-plaintext highlighter-rouge">SQL</code>을 처음 배우면 나오는 문법이다. 그냥 찾아주는거고 여기서 뭐 어려운 것은 없다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_ID</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
<span class="k">WHERE</span> <span class="n">ANIMAL_ID</span> <span class="o">&gt;</span> <span class="mi">100</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="nb">DATETIME</span> <span class="k">ASC</span> <span class="o">#</span><span class="k">DESC</span>
<span class="n">LMIIT</span> <span class="mi">1</span>
</code></pre></div></div>

<p>이런식으로, 찾는다 -&gt; 어디서? -&gt; 어떻게? 이런식으로 주면 된다</p>

<h2 id="count">COUNT</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">COUNT(*)</code> 로 무엇의 개수를 셀 지 정할 수 있다.
중요한점은 <code class="language-plaintext highlighter-rouge">GROUP BY</code> 로 어떤것의 개수를 어떤 그룹으로 쪼개서 계산할 지 할 수 있고, 같은것을 세기가 싫다면 <code class="language-plaintext highlighter-rouge">COUNT(DISTINCT NAME)</code> 이런식으로 할 수 도 있다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">HOUR</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span> <span class="k">as</span> <span class="n">HOUR</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span> <span class="k">as</span> <span class="k">COUNT</span>
<span class="k">FROM</span> <span class="n">ANIMAL_OUTS</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">HOUR</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span> <span class="k">HAVING</span> <span class="n">HOUR</span> <span class="o">&gt;=</span> <span class="mi">9</span> <span class="k">AND</span> <span class="n">HOUR</span> <span class="o">&lt;=</span> <span class="mi">19</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">HOUR</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">)</span>
</code></pre></div></div>

<p>09:00부터 19:59까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문</p>

<h2 id="is-null">IS NULL</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">NULL</code> 문은 특징이 있다. 우선 단독으로 <code class="language-plaintext highlighter-rouge">Something = 'NULL'</code> 이런식으로 사용 할 수 없고, <code class="language-plaintext highlighter-rouge">Something is NULL</code> 이런식으로 사용해야 알아듣는다. 생각해보면 당연한 것</p>

<p>그리고 만약 <code class="language-plaintext highlighter-rouge">NULL</code> 이면 이러한 구문을 넣어라 이런것도 가능하다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_TYPE</span><span class="p">,</span> <span class="n">IFNULL</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="nv">"No name"</span><span class="p">)</span> <span class="k">as</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">SEX_UPON_INTAKE</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
</code></pre></div></div>

<p>이렇게 하면 만약 <code class="language-plaintext highlighter-rouge">Name</code> 에 <code class="language-plaintext highlighter-rouge">NULL</code> 이라면 <code class="language-plaintext highlighter-rouge">No name</code> 이 들어가게 된다.</p>

<h2 id="join">JOIN</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">SQL</code>의 꽃이라고 할 수 있는 <code class="language-plaintext highlighter-rouge">JOIN</code> 문이다. 간단하게 말하면 두 테이블을 합쳐주는 것인데, 합치는 과정에서 어떤식으로 문제를 찾을 지 정할 수 있는 방법이 무궁무진하기 떄문에, 만약 제대로 알고 가지 못한다면 어려워 질 수 있다. 실제로 내가 공부를 할 때는 <code class="language-plaintext highlighter-rouge">Natural JOIN</code> 으로 다 풀었었는데, 문제에서는 다 특이한 방법으로 값들을 찾으라 해서 조금 까다로웠다.</p>

<p><code class="language-plaintext highlighter-rouge">OUTS</code> 에는 있지만 <code class="language-plaintext highlighter-rouge">INS</code> 에는 없는 데이터 출력</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">NAME</span>
<span class="k">FROM</span>
    <span class="n">ANIMAL_INS</span> <span class="k">AS</span> <span class="n">INS</span>
<span class="k">RIGHT</span> <span class="k">JOIN</span>
    <span class="n">ANIMAL_OUTS</span> <span class="k">AS</span> <span class="n">OUTS</span>
<span class="k">ON</span>
    <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="o">=</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span>
<span class="k">WHERE</span>
    <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>보호소에서 중성화 즉 Intact -&gt; Neutered or Sapyed가 된 경우 찾기</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_TYPE</span><span class="p">,</span> <span class="n">INS</span><span class="p">.</span><span class="n">NAME</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span> <span class="n">INS</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">ANIMAL_OUTS</span> <span class="n">OUTS</span>
<span class="k">ON</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="o">=</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span>
<span class="k">WHERE</span> <span class="n">INS</span><span class="p">.</span><span class="n">SEX_UPON_INTAKE</span> <span class="k">LIKE</span> <span class="s1">'Intact%'</span> <span class="k">AND</span> <span class="p">(</span><span class="n">OUTS</span><span class="p">.</span><span class="n">SEX_UPON_OUTCOME</span> <span class="k">LIKE</span> <span class="s1">'Neutered%'</span> <span class="k">OR</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">SEX_UPON_OUTCOME</span> <span class="k">LIKE</span> <span class="s1">'Spayed%'</span><span class="p">)</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ANIMAL_ID</span>
</code></pre></div></div>

<h2 id="string-date">STRING, DATE</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">CASE</code> 를 나눠서 만약 1번이면 <code class="language-plaintext highlighter-rouge">X</code> 2번이면 <code class="language-plaintext highlighter-rouge">O</code> 를 출력하는 테이블을 만들 수 있다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span>
<span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">SEX_UPON_INTAKE</span> <span class="k">LIKE</span> <span class="s1">'Neutered%'</span> <span class="k">OR</span> <span class="n">SEX_UPON_INTAKE</span> <span class="k">LIKE</span> <span class="s1">'Spayed%'</span> <span class="k">THEN</span> <span class="s1">'O'</span> <span class="k">ELSE</span> <span class="s1">'X'</span> <span class="k">END</span> <span class="k">AS</span> <span class="s1">'중성화'</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ANIMAL_ID</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DATE</code> 를 뺼 때, 두가지 경우가 있는데 <code class="language-plaintext highlighter-rouge">DATEDIFF</code> 함수를 사용해서, 실제로 차이가 얼마나 나는지 원하는 데이터 타입으로 찾을 수 있고 아니면 그냥 변수마냥 빼도 알아서 게산을 해준다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">INS</span><span class="p">.</span><span class="n">NAME</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span> <span class="n">INS</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">ANIMAL_OUTS</span> <span class="n">OUTS</span>
<span class="k">ON</span> <span class="n">INS</span><span class="p">.</span><span class="n">ANIMAL_ID</span> <span class="o">=</span> <span class="n">OUTS</span><span class="p">.</span><span class="n">ANIMAL_ID</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">OUTS</span><span class="p">.</span><span class="nb">DATETIME</span> <span class="o">-</span> <span class="n">INS</span><span class="p">.</span><span class="nb">DATETIME</span> <span class="k">DESC</span>
<span class="k">LIMIT</span> <span class="mi">2</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DATE</code> 에는 내장 함수들이 많은데, 그 중에 <code class="language-plaintext highlighter-rouge">DATE_FORMAT</code> 을 통해 내가 원하는 형식을 지정 해 줄 수 도 있다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">ANIMAL_ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">DATE_FORMAT</span><span class="p">(</span><span class="nb">DATETIME</span><span class="p">,</span> <span class="s1">'%Y-%m-%d'</span><span class="p">)</span> <span class="k">as</span> <span class="s1">'날짜'</span>
<span class="k">FROM</span> <span class="n">ANIMAL_INS</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ANIMAL_ID</span>
</code></pre></div></div>

<p>이렇게 하면 내가 원하는 YEAR-MONTH-DAY 형식으로 출력이 된다.</p>

<blockquote>
  <p>{Y,y} {M,m} {D,d} 모두 형식이 다르다. [문자열 vs 숫자]</p>
</blockquote>]]></content><author><name>071yoon</name></author><category term="sql" /><category term="sql" /><category term="qeury" /><summary type="html"><![CDATA[Why SQL?]]></summary></entry><entry><title type="html">바닐라JS로 앱 만들기 2</title><link href="http://localhost:4000/javascript/2022/01/22/javascript-coding-2.html" rel="alternate" type="text/html" title="바닐라JS로 앱 만들기 2" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/22/javascript-coding-2</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/22/javascript-coding-2.html"><![CDATA[<h2 id="자바스크립트를-browser로-로딩하기">자바스크립트를 Browser로 로딩하기</h2>

<hr />

<h3 id="document-object"><code class="language-plaintext highlighter-rouge">document</code> Object</h3>

<p><code class="language-plaintext highlighter-rouge">console</code>에 <code class="language-plaintext highlighter-rouge">document</code>를 쓰면, 이미 정의되어 있는 함수인걸 알 수 있다.
그럼 html 에서 <code class="language-plaintext highlighter-rouge">block</code>으로 지정한 부분을 자바스크립트에서 바로 가져올 수 있다.</p>

<blockquote>
  <p>ex) <code class="language-plaintext highlighter-rouge">document.title</code> -&gt; 내가 지정한 HTML 의 title</p>
</blockquote>

<p>즉 이렇게 하면 HTML 의 코드를 자바스크립트의 관점에서 볼 수 있게된다</p>

<p>그럼 다른 block 에서 <code class="language-plaintext highlighter-rouge">id</code>로 가져오려면 어떻게 해야될까??</p>

<p>HTML 에서 <code class="language-plaintext highlighter-rouge">&lt;h1 id="name"&gt;Name&lt;/h1&gt;</code> 이런식의 블럭이 있다면 간단하게 <code class="language-plaintext highlighter-rouge">document.getElementById("name")</code> 이런식으로 호출 할 수 있다.</p>

<blockquote>
  <p>주의할점! <code class="language-plaintext highlighter-rouge">getElementById</code> 는 특정항목 하나만 가져오기 때문에 변수 하나에 저장되지만, <code class="language-plaintext highlighter-rouge">getElementByClass</code> 혹은 <code class="language-plaintext highlighter-rouge">getElementByTag</code> 는 여러 값들을 가져오기 때문에 배열로 할당되어 저장된다</p>
</blockquote>

<p>하지만 가장 많이 사용하는 것은 <code class="language-plaintext highlighter-rouge">querySelector</code>라고 한다. 하나만 가져오고 가져오는것 중 하나를 CSS형태로 선택 할 수 있어서 가장 깔끔하고 보기 편하다고 한다. 그리고 만약 겹친다면 첫번 째 나오는 element 만 가져온다!!</p>

<ul>
  <li>
    <p>배열로 가져오려면 <code class="language-plaintext highlighter-rouge">quertySelectorAll</code>을 사용하면된다.</p>

    <p><code class="language-plaintext highlighter-rouge">document.querySelector('.class_name block')</code></p>

    <p><code class="language-plaintext highlighter-rouge">docuemnt.querySelector('.class_name block:first-child)</code> 도 가능하다</p>
  </li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">document.querySelector("#id")</code> 는 <code class="language-plaintext highlighter-rouge">document.getElementById("hello")</code> 와 동일하다</p>
</blockquote>

<p>그럼 이렇게 호출된 <code class="language-plaintext highlighter-rouge">name</code> 은 <code class="language-plaintext highlighter-rouge">name.innerText()</code> 함수를 통해 안에 있는 내용을 변경 할 수 있게 해준다.</p>

<h3 id="events">Events</h3>

<p><code class="language-plaintext highlighter-rouge">variable.addEventListener("event", function);</code> 으로 선언을 해주면, 어떠한 event 를 할 때마다 function을 실행 해 줄것이다. event의 예로는 click, hover 기타등등이 있다. <code class="language-plaintext highlighter-rouge">console.dir</code> 으로 어떠한 함수들이 있는지 확인 할 수 있다.</p>

<blockquote>
  <p>function을 호출할 떄 함수의 이름만 호출함에 주의! function()이렇게 아예 실행하도록 주지않고, 이름만 넘겨줘서 Event가 발생 시 function 을 실행하도록 한다</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">HTMLHeadingElement</code> 에 들어가서 어떠한 API 들을 사용 할 수 있는지 확인을 해봐도 된다.</p>

<p>혹은 <code class="language-plaintext highlighter-rouge">variable.on'event' = function</code> 이런식으로 선언을 해도 같은식으로 동작하게 만들 수 있다</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">Event</code>의 특징으로 또 강력한 것은 <code class="language-plaintext highlighter-rouge">Window</code> 객체에서 불러 올 수 있다는 것이다. <code class="language-plaintext highlighter-rouge">Window</code>는 현재 실행을 하는 그 화면을 말하는 것이고, 그 화면에서 정말 많은것을 구현 할 수 있다. 예를들어 <code class="language-plaintext highlighter-rouge">resize</code> 로 윈도우 크기를 조절하고 있을때의 이벤트, 혹은 <code class="language-plaintext highlighter-rouge">copy</code>, <code class="language-plaintext highlighter-rouge">offline</code> 등등 정말 많은 이벤트들이 구현되어 있고, 우리는 사용만 하면 된다!!</p>

<p>내가 만약 <code class="language-plaintext highlighter-rouge">class</code> 를 받아와서 사용중에 있는데, 현재 내가 사용하고 있는 클래스는 폰트지정 클래스이고, 색변환 클래스를 추가하고 싶으면 어떻게 사용해야 될까??</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleCheck</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">clickedClass</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">clicked</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nx">clickedClass</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">clickedClass</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">clickedClass</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 사용할 수 있다. 그럼 원래 있던 클래스 <code class="language-plaintext highlighter-rouge">class = "test"</code> 라 두면 추가되면 <code class="language-plaintext highlighter-rouge">class = "test clicked"</code> 이렇게 되고 remove시 <code class="language-plaintext highlighter-rouge">class = "test"</code> 이렇게 돌아갈 것이다. 이런식으로 클래스의 중첩이 가능하다!!</p>

<p>이걸 편하게 해주는것이 <code class="language-plaintext highlighter-rouge">toggle function</code> 은 어떤 역할이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleCheck</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">h1</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">toggle</span><span class="p">(</span><span class="dl">"</span><span class="s2">clicked</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로 한번에 해결 할 수 있다.</p>

<p>즉 toggle 은 이미 있는지 확인을 해서, 있다면 삭제하고 없다면 생성해주는 불을 키고 끄는것과 비슷한 행동을 해주는 함수라 할 수 있다.</p>

<p>다음 포스트부터는 실제로 코드를 작성해서 VanillaJS 앱을 만들어보겠다</p>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[자바스크립트를 Browser로 로딩하기]]></summary></entry><entry><title type="html">바닐라JS로 앱 만들기 1</title><link href="http://localhost:4000/javascript/2022/01/22/javascript-coding-1.html" rel="alternate" type="text/html" title="바닐라JS로 앱 만들기 1" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/22/javascript-coding-1</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/22/javascript-coding-1.html"><![CDATA[<h2 id="자바스크립트-실습">자바스크립트 실습</h2>

<hr />

<p>자바스크립트의 이론적인 부분에 대해서는 공부를 대충 해봤지만, 실생활에 어떤식으로 사용할 지, 혹은 어떤식으로 프로젝트를 진행할 지에 대해서 너무 무지했기 떄문에, 처음에는 강의에 의존을 해보기로 결정했다. 여러 자바스크립트 강의를 찾던 도중, <code class="language-plaintext highlighter-rouge">노마드코더</code>가 자바스크립트를 처음 접하기 좋다는 소식을 들어 이 사이트에서, 바닐라JS로 크롬 앱 만들기 강의를 시작해보기로 결정했다.</p>

<h3 id="why-javscript">Why Javscript?</h3>

<hr />

<p>왜 우리는 자바스크립트를 사용할까??</p>

<p>사실 자바스크립트는 그렇게 좋은 언어는 아니다. <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">var</code> 등등 (요새는 <code class="language-plaintext highlighter-rouge">var</code>를 안쓴다고 하긴 하더라) 데이터 타입을 명시해주는것 부터, 문법등을 보면 그렇게 멋진 언어는 아니다. 개인적으로 C언어가 완벽에 가까운 언어라고 생각을 하는데 (개발자의 역량에 따라 시간을 투자하면 원하는만큼 다 구현이 가능하니까) 왜 자바스크립트를 사용할까?? 사실 어쩔 수 없다는게 맞는 표현이다. 문제는 처음부터 웹을 만들 떄 자바스크립트를 사용했다는 것…! 애초부터 급조한 언어였기 때문에, 문제가 많았다.</p>

<blockquote>
  <p>실제로 10일만에 만든 언어라고 한다!</p>
</blockquote>

<p>하지만 이미 많은 사람들이 웹에서 자바스크립트를 사용하였기에, 갑자기 언어를 바꿔버리면 웹에 마비가 올 수 있다는 생각에 그냥 해당 자바스크립트를 두고 패치를 계속 진행을 하며, 현재의 자바스크립트까지 왔다고 한다. 즉 자바스크립트는 현재 웹에서 <code class="language-plaintext highlighter-rouge">대체불가언어</code> 라고 해도 과언이 아닐정도로 모든 웹에서 사용중이며, 우리가 배워야 하는 이유이다. 너무 싫어서 사용하기 싫다고 하더라도 웹쪽으로 커리어를 생각중이라면 어쩔 수 없이 배워야 하는 언어..? 정말 애증의 언어가 아닐 수 없다. 물론 요즘은 그런점들을 보완하며, 같이 상용이 가능한 <code class="language-plaintext highlighter-rouge">typescript</code>의 존재로 이러한 원성들을 조금이나마 잠재워 주고 있는듯 보인다.</p>

<h3 id="project의-시작">Project의 시작</h3>

<hr />

<p>옛날에 웹디자인을 공부 할 때, 해봤지만 너무 옛날이라 기억도 안나고 역시 정리를 안해두니 찾아보기가 힘들어 이번에는 조금 정리를 하면서 진행을 해보려고 한다.</p>

<p>우선 웹을 배우려면 <code class="language-plaintext highlighter-rouge">HTML</code>, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">Javascript</code> 이 3개의 연관성에 대해서 조금이나마 알고 가야한다. <code class="language-plaintext highlighter-rouge">CSS</code> 와 <code class="language-plaintext highlighter-rouge">Javascript</code> 는 일반적으로 혼자 작동할 수 없는 언어이다. 즉 <code class="language-plaintext highlighter-rouge">HTML의 의존성을 가진 파일들</code> 이라고 할 수 있다. 아무리 이쁜 디자인을 <code class="language-plaintext highlighter-rouge">CSS</code> 에서 진행을 하고 얼마나 멋진 함수들을 <code class="language-plaintext highlighter-rouge">Javscript</code> 에서 구현을 했다 한들, 실제 보여지지않으면 의미가 없고, 이러한것들을 가시적으로 보여주면서 동작하게하는 것이 <code class="language-plaintext highlighter-rouge">HTML</code>이라고 보면 되겠다. 어떻게 연결하는지 기본적인 HTML을 보며 살펴보자</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"style.css"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>momentum<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"script.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>이런식으로 <code class="language-plaintext highlighter-rouge">stylesheet</code>를 <code class="language-plaintext highlighter-rouge">style.css</code>로 두고 <code class="language-plaintext highlighter-rouge">script</code>를 <code class="language-plaintext highlighter-rouge">script.js</code> 로 두어 링크를 했다고 보면 되겠다.</p>

<blockquote>
  <p>주의할점! <code class="language-plaintext highlighter-rouge">script.js</code> 는 <code class="language-plaintext highlighter-rouge">body</code>의 끝에 주로 둔다. WHY? 왜냐하면 보통 사이즈가 큰 파일들은 <code class="language-plaintext highlighter-rouge">script.js</code>에 들어가 있고, 인터넷 속도가 느려서 자바스크립트파일을 다운받는데 오래 걸린다면, 그 전에 화면에 출력할 것을 먼저 다운받지 못해 빈 화면을 출력하고, 자바스크립트를 다운 다 받은 후 출력을 하기때문. 즉 유저의 편의를 좀 봐주자</p>
</blockquote>

<h3 id="data-types">Data Types</h3>

<hr />

<p>일단 자바스크립트는 <code class="language-plaintext highlighter-rouge">syntax</code>가 세개밖에 없다. <code class="language-plaintext highlighter-rouge">const, let, var</code> 심지어 <code class="language-plaintext highlighter-rouge">var</code> 는 잘 쓰지 않으므로 <code class="language-plaintext highlighter-rouge">const</code> 와 <code class="language-plaintext highlighter-rouge">let</code> 두개가 있다고 해도 무방하다.</p>

<blockquote>
  <p>심지어 파이썬은 저것조차 안써도 된다</p>
</blockquote>

<p>그럼 데이터타입을 알아서 정해준다는 것이다. 그럼 문제가 무엇이냐?? 언제 정수에서 문자형으로 바뀌는것이고, 문자열로 바뀌는지 프로그램이 정해주기 때문에 정할 수 없다는 것이다. 그래서 새로운 <code class="language-plaintext highlighter-rouge">typescript</code> 라고 자바스크립트에서 <code class="language-plaintext highlighter-rouge">type</code> 형식을 지정해주는 변형된 언어가 탄생을 했다.</p>

<p>그럼 요새 사용은 안하는 <code class="language-plaintext highlighter-rouge">var</code> 형식은 언제 사용하는것일까? 사실 사용을 잘 안한다. <code class="language-plaintext highlighter-rouge">var</code> 는 처음에 만들어진 변수 선언 type 이고, 어디서나 재정의가 가능하다는 장점이 있지만, 사실이건 매우 위험하고 차라리 다른 변수명을 선언하는게 훨씬 낫다. 그래서 요새는 <code class="language-plaintext highlighter-rouge">let</code> 과 <code class="language-plaintext highlighter-rouge">const</code>로 대체해서 사용한다.</p>

<p>자바스크립트에서 특이한것이 있는데, <code class="language-plaintext highlighter-rouge">null</code> 과 <code class="language-plaintext highlighter-rouge">undefined</code> 가 두개나 존재한다는 것이다. <code class="language-plaintext highlighter-rouge">null</code>은 내가 지정을 해 줘서 비어있을 때 <code class="language-plaintext highlighter-rouge">null</code> 인것이고, <code class="language-plaintext highlighter-rouge">undefined</code>는 내가 만약 <code class="language-plaintext highlighter-rouge">let variable;</code> 을 해주고 지정을 안해주면 <code class="language-plaintext highlighter-rouge">undefined</code> 라고 나오게 된다.</p>

<blockquote>
  <p>즉 null 은 비어있는것이고, undefined는 변수이지만 값이 없는것</p>
</blockquote>

<p>그리고 자바스크립트 배열에는 C 혹은 C++ 과 다른 특이점이 있다. 나의 테스트케이스를 보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">test</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">test</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="dl">"</span><span class="s2">c</span><span class="dl">"</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">test</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">test</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">test2</span><span class="dl">"</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">test</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">: </span><span class="dl">"</span> <span class="o">+</span> <span class="k">typeof</span> <span class="nx">test</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>특이한 점 1 : 배열의 type 은 각 항목마다 다르다</p>
</blockquote>

<blockquote>
  <p>특이한 점 2 : 만약에 7번을 만들면 자동으로 배열의 크기가 8로 늘어나고, 5 6 7 번은 undefined로 정의된다</p>
</blockquote>

<h3 id="비교연산자">비교연산자</h3>

<hr />

<p>타 언어들을 보면 비교연산자로 <code class="language-plaintext highlighter-rouge">==</code> 밖에 쓰지 않는데, 자바스크립트는 특이하게 <code class="language-plaintext highlighter-rouge">===</code> 를 주로 사용한다. 그렇다고해서 <code class="language-plaintext highlighter-rouge">==</code> 가 없다는 것은 아니다. 차이점은 <code class="language-plaintext highlighter-rouge">==</code> 은 값만 비교하는 것이고 <code class="language-plaintext highlighter-rouge">===</code> 는 <code class="language-plaintext highlighter-rouge">type</code> 까지 묶어서 비교를 한다는 점이다. 즉 <code class="language-plaintext highlighter-rouge">5 == '5'</code> 는 참이지만 <code class="language-plaintext highlighter-rouge">5 === '5'</code> 는 거짓이라는 것.</p>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[자바스크립트 실습]]></summary></entry><entry><title type="html">자바스크립트 객체 프로퍼티 설정</title><link href="http://localhost:4000/javascript/2022/01/20/javascript-property.html" rel="alternate" type="text/html" title="자바스크립트 객체 프로퍼티 설정" /><published>2022-01-20T00:00:00+09:00</published><updated>2022-01-20T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/20/javascript-property</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/20/javascript-property.html"><![CDATA[<h1 id="객체-프로퍼티">객체 프로퍼티</h1>

<p>프로퍼티란 단순히 <code class="language-plaintext highlighter-rouge">key-value</code> 가 아닌 더 유연한 자료구조로 사용 될 수 있으며, <code class="language-plaintext highlighter-rouge">getter</code>와 <code class="language-plaintext highlighter-rouge">setter</code> 등에 대해서 학습해보자</p>

<h2 id="프로퍼티-플래그와-생성자">프로퍼티 플래그와 생성자</h2>

<p>객체 프로퍼티는 값과 플래그라는 속성을 가진다</p>
<ul>
  <li>writable - true 라면 수정이 가능하다</li>
  <li>enumerable - true 라면 반복문으로 나열 할 수 있다</li>
  <li>configurable - true 라면 삭제나 플래그 수정이 가능하다</li>
</ul>

<p>평범한 방식으로 설계를 한다면, 프로퍼티는 모두 <code class="language-plaintext highlighter-rouge">true</code>이며, 언제든 수정 될 수 있다</p>

<p><code class="language-plaintext highlighter-rouge">let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);</code></p>

<p>여기서</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">obj</code> 란 정보를 얻고자 하는 객체</li>
  <li><code class="language-plaintext highlighter-rouge">propertyName</code> 이란 정보를 얻고자 하는 객체 내 프로퍼티
를 말한다</li>
</ul>

<p>예시</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">alert</span><span class="p">(</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">);</span>
<span class="cm">/* property descriptor:
{
  "value": "Yoon",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
*/</span>
</code></pre></div></div>

<p>이 상태에서 <code class="language-plaintext highlighter-rouge">Object.defineProperty</code>로 플래그를 변경 할 수 있다</p>

<h2 id="getter-와-setter">getter 와 setter</h2>

<p>객체의 프로퍼티를 나누는 두 분류로 볼 수 있다.</p>
<ol>
  <li>데이터 프로퍼티 -&gt; 현재까지 모두 사용한 프로퍼티</li>
  <li>접근자 프로퍼티 -&gt; 새로운 종류로, 함수의 값을 획득하고 설정하는 역할을 담당한다</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nx">propName</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// getter, obj.propName실행시</span>
  <span class="p">},</span>

  <span class="kd">set</span> <span class="nx">propName</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// setter, obj.propName = value실행시</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>그럼 이걸 어떤식으로 활용 할 수 있을까??</p>

<p><code class="language-plaintext highlighter-rouge">getter</code>와 <code class="language-plaintext highlighter-rouge">setter</code>를 실제 프로퍼티 값을 감싸는 래퍼로 사용하여, 프로퍼티 값을 통제하는 방법이 있다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="kd">get</span> <span class="nx">name</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="kd">set</span> <span class="nx">name</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Too Short</span><span class="dl">"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Yoon</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span> <span class="c1">// 너무 짧은 이름을 할당하려 함</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">user</code>의 이름이 <code class="language-plaintext highlighter-rouge">_name</code>에 저장되어, 프로퍼티에 접근하는것이 <code class="language-plaintext highlighter-rouge">getter</code> 와 <code class="language-plaintext highlighter-rouge">setter</code>로 이루어진다.</p>

<blockquote>
  <p>솔직히 왜 사용하는지 이해는 되지 않지만, 그냥 이런게 있구나~ 하고 넘어가고 이후에 다시 확인해보기로 하자</p>
</blockquote>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="typescript" /><category term="TIL" /><category term="property" /><summary type="html"><![CDATA[객체 프로퍼티]]></summary></entry><entry><title type="html">자바스크립트 프로토타입과 클래스</title><link href="http://localhost:4000/javascript/2022/01/20/prototype.html" rel="alternate" type="text/html" title="자바스크립트 프로토타입과 클래스" /><published>2022-01-20T00:00:00+09:00</published><updated>2022-01-20T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/20/prototype</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/20/prototype.html"><![CDATA[<h2 id="프로토타입과-프로토타입-상속">프로토타입과 프로토타입 상속</h2>

<p>상속을 하는 이유??</p>

<p>내가 <code class="language-plaintext highlighter-rouge">user</code>라는 객체가 있고, <code class="language-plaintext highlighter-rouge">user</code>와 유사하지만 비슷한 <code class="language-plaintext highlighter-rouge">admin</code> 과 <code class="language-plaintext highlighter-rouge">guest</code>를 만들어야 했을 때, 유사한 객체를 만들 수 있을까??</p>

<blockquote>
  <p>프로토타입 상속을 이용하여 만들 수 있다</p>
</blockquote>

<p>프로토타입의 예시 -&gt; <code class="language-plaintext highlighter-rouge">__proto__</code> 로 만들 수 있다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">animal</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">eats</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">let</span> <span class="nx">rabbit</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">jumps</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">rabbit</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">animal</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">__proto__</code>는 Prototype용 getter/setter다</p>
</blockquote>

<blockquote>
  <p>프로토타입은 읽기 전용이다</p>
</blockquote>

<h3 id="this-는-무엇을-나타낼까">this 는 무엇을 나타낼까?</h3>

<p>먼저 코드를 보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// animal엔 다양한 메서드가 있습니다.</span>
<span class="kd">let</span> <span class="nx">animal</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">walk</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">isSleeping</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">alert</span><span class="p">(</span><span class="s2">`Animal Walking.`</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">sleep</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isSleeping</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">rabbit</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">White Rabbit</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">__proto__</span><span class="p">:</span> <span class="nx">animal</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// rabbit에 새로운 프로퍼티 isSleeping을 추가하고 그 값을 true로 변경합니다.</span>
<span class="nx">rabbit</span><span class="p">.</span><span class="nx">sleep</span><span class="p">();</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">rabbit</span><span class="p">.</span><span class="nx">isSleeping</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">animal</span><span class="p">.</span><span class="nx">isSleeping</span><span class="p">);</span> <span class="c1">// undefined (프로토타입에는 isSleeping이라는 프로퍼티가 없습니다.</span>
</code></pre></div></div>

<p>그럼 여기서 <code class="language-plaintext highlighter-rouge">this</code>는 무엇을 나타낼까??</p>

<blockquote>
  <p>method위치에 상관없이 <code class="language-plaintext highlighter-rouge">this</code> 는 항상 <code class="language-plaintext highlighter-rouge">.</code>앞에 있다</p>
</blockquote>

<p>상속받은 메서드의 this는 animal이 아닌 실제 메서드가 호출되는 시점의 점(.) 앞에 있는 객체가 된다. 따라서 this에 데이터를 쓰면 animal이 아닌 해당 객체의 상태가 변화한다.</p>

<h2 id="클래스란">클래스란</h2>

<blockquote>
  <p>클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 객체를 정의하기 위한 상태(멤버 변수)와 메서드(함수)로 구성된다.</p>
</blockquote>

<h3 id="클래스의-기본-문법">클래스의 기본 문법</h3>

<p>new 연산자와 생성자 함수에서 new function 을 사용해보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
	<span class="kd">constructor</span><span class="p">()</span> <span class="p">{...}</span>
	<span class="nx">method1</span><span class="p">()</span> <span class="p">{...}</span>
	<span class="nx">method2</span><span class="p">()</span> <span class="p">{...}</span>
	<span class="nx">method3</span><span class="p">()</span> <span class="p">{...}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">constructor()</code>는 <code class="language-plaintext highlighter-rouge">new</code>에 자동으로 호출되어, 초기화 할 수 있다</p>

<p>class User{…} 가 어떤식으로 동작하는가 알아보면</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">User</code>이라는 이름을 가지는 함수를 만들어, <code class="language-plaintext highlighter-rouge">constructor</code>에서 가져온다</li>
  <li><code class="language-plaintext highlighter-rouge">sayHi</code> 같은 클래스 내에서 정의한 method를 <code class="language-plaintext highlighter-rouge">User.prototype</code>에 저장한다</li>
</ol>

<p>라는 과정을 거치게 된다.</p>

<p>이러한 과정을 코드로 살펴보면</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 클래스는 함수입니다.</span>
<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">User</span><span class="p">);</span> <span class="c1">// function</span>

<span class="c1">// 생성자 method와 동일</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">User</span> <span class="o">===</span> <span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// User.prototype에 저장</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">);</span> <span class="c1">// alert(this.name);</span>

<span class="c1">// 현재 프로토타입에는 메서드가 두</span>
<span class="nx">alert</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">));</span> <span class="c1">// constructor, sayHi</span>
</code></pre></div></div>

<p>이렇게 볼 수 있다.</p>

<h3 id="클래스의-상속">클래스의 상속</h3>

<p><code class="language-plaintext highlighter-rouge">extends</code> 키워드를 통해 클래스의 상속을 할 수 있다.</p>

<p>먼저 <code class="language-plaintext highlighter-rouge">Animal</code> 이라는 클래스를 만들고, <code class="language-plaintext highlighter-rouge">Rabbit</code>을 <code class="language-plaintext highlighter-rouge">Animal</code>에 상속시켜 확장해보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">run</span><span class="p">(</span><span class="nx">speed</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">speed</span> <span class="o">=</span> <span class="nx">speed</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> 은/는 속도 </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">speed</span><span class="p">}</span><span class="s2">로 달립니다.`</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> 이/가 멈췄습니다.`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">(</span><span class="dl">"</span><span class="s2">동물</span><span class="dl">"</span><span class="p">);</span>

<span class="kd">class</span> <span class="nx">Rabbit</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nx">hide</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> 이/가 숨었습니다!`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">rabbit</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rabbit</span><span class="p">(</span><span class="dl">"</span><span class="s2">흰 토끼</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">rabbit</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 흰 토끼 은/는 속도 5로 달립니다.</span>
<span class="nx">rabbit</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span> <span class="c1">// 흰 토끼 이/가 숨었습니다!</span>
</code></pre></div></div>

<p>이정도는 예전 객체지향에 대해서 배울 때 사용했던 부분이라 쉽게 이해가 된다</p>

<p>근데 여기서 <code class="language-plaintext highlighter-rouge">Rabbit</code> 클래스에 <code class="language-plaintext highlighter-rouge">stop</code> 이란 method를 자체적으로 정의하면 상속받은 method가 아닌 자신의 method가 호출하게 된다.</p>

<p>하지만 가끔, 부모 method의 일부만 변경하고 싶거나, 기능을 확장 하고 싶을 때가 있는데, 그 때 <code class="language-plaintext highlighter-rouge">super</code> 키워드를 사용하여 해결 할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Rabbit</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nx">hide</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">가 숨었습니다!`</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">stop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">.</span><span class="nx">stop</span><span class="p">();</span> <span class="c1">// 부모 클래스의 stop을 호출해 멈추고,</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span> <span class="c1">// 숨습니다.</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로, Rabbit.stop() 을 하게되면 부모클래스의 <code class="language-plaintext highlighter-rouge">stop</code>을 이용해 호출을 해서 멈춘 후 숨게 된다.</p>

<h3 id="정적-method-와-정적-property">정적 Method 와 정적 Property</h3>

<p><code class="language-plaintext highlighter-rouge">prototype</code>이 아닌 클래스 함수 자체에서도 method를 설정 할 수 있다 -&gt; static method</p>

<p>예시</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">staticMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">User</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">User</span><span class="p">.</span><span class="nx">staticMethod</span><span class="p">();</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>이런식으로 선언된 정적 method는 프로퍼티 형태로 직접 할당하는것과 동일한 역할을 한다</p>

<p><code class="language-plaintext highlighter-rouge">User.staticMethod()</code> 호출 시 <code class="language-plaintext highlighter-rouge">this</code> 는 클래스 생성자인 <code class="language-plaintext highlighter-rouge">User</code>가 된다.</p>

<h3 id="private-protected-property--method">Private, Protected Property &amp; Method</h3>

<p>객체지향 프로그래밍에서 Property &amp; Method 는 두 그룹으로 분류된다</p>

<ol>
  <li>내부 인터페이스 [Internal Interface] - 동일한 클래스 내의 다른 Method에 접근 할 수 있고, 클래스 밖에서는 접근할 수 없는 Property &amp; Method -&gt; Private</li>
  <li>외부 인터페이스 [External Interface] - 클래스 밖에서도 접근 가능한 Property &amp; Method -&gt; Public</li>
</ol>

<h3 id="protecting-property">Protecting Property</h3>

<p>Protected Property 이름의 앞에는 관행적으로 밑줄 [_] 이 붙는다.</p>

<p>예를들어, 커피머신이란 클래스를 만들어서 물의 양을 protect 해보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">CoffeeMachine</span> <span class="p">{</span>
  <span class="nx">_waterAmount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kd">set</span> <span class="nx">waterAmount</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">물의 양은 음수가 될 수 없습니다.</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_waterAmount</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">get</span> <span class="nx">waterAmount</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_waterAmount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="nx">power</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_power</span> <span class="o">=</span> <span class="nx">power</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 커피 머신 생성</span>
<span class="kd">let</span> <span class="nx">coffeeMachine</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CoffeeMachine</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

<span class="c1">// 물 추가</span>
<span class="nx">coffeeMachine</span><span class="p">.</span><span class="nx">waterAmount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="c1">// Error: 물의 양은 음수가 될 수 없습니다.</span>
</code></pre></div></div>

<p>이런식으로 물의 양을 protect 하여 관행적으로 접근을 하지 말라고 소개할 수 있다</p>

<p>하지만 Java처럼 아예 접근이 불가능하게 private 하게 사용을 하려면 <code class="language-plaintext highlighter-rouge">_</code> 대신 <code class="language-plaintext highlighter-rouge">#</code> 을 사용하면 java에서 private 하게 사용했던 것 처럼 사용이 가능하다.</p>

<h3 id="mix-in">Mix in</h3>

<p>자바스크립트는 보통 단일상속만 허용한다. 하지만 여러 상속들을 한번에 밭을 수 있는방법이 존재한다</p>

<blockquote>
  <p>믹스인을 활용하여 다중상속을 받아보자</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">sayHiMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">`Hello </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">sayBye</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">`Bye </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 사용법:</span>
<span class="kd">class</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 메서드 복사</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">sayHiMixin</span><span class="p">);</span>

<span class="c1">// 이제 User가 인사를 할 수 있습니다.</span>
<span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="dl">"</span><span class="s2">Dude</span><span class="dl">"</span><span class="p">).</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// Hello Dude!</span>
</code></pre></div></div>

<p>이런식으로 상속없이 메서드를 복사하여, 믹스인을 활용하면 <code class="language-plaintext highlighter-rouge">User</code> 가 예시처럼 동시에 상속받아, 추가로 구현된 메서드 또한 사용 할 수 있는 모습을 볼 수 있다.</p>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="typescript" /><category term="TIL" /><category term="prototype" /><category term="class" /><summary type="html"><![CDATA[프로토타입과 프로토타입 상속]]></summary></entry><entry><title type="html">자바스크립트 함수의 심화학습</title><link href="http://localhost:4000/javascript/2022/01/18/javascript-functions.html" rel="alternate" type="text/html" title="자바스크립트 함수의 심화학습" /><published>2022-01-18T00:00:00+09:00</published><updated>2022-01-18T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/18/javascript-functions</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/18/javascript-functions.html"><![CDATA[<h2 id="나머지-매개변수와-스프레드-문법">나머지 매개변수와 스프레드 문법</h2>

<h3 id="나머지-매개변수">나머지 매개변수</h3>
<p>예전에 printf를 구현을 할 때, 가변인수라고 해서 <code class="language-plaintext highlighter-rouge">va args</code>를 써서 구현을 했던 적이 있는데, 그거에 비해서 정말 아니 이렇게 써도 된다고??? 할정도로 자바스크립트에서는 구현이 가능하다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sumAll</span><span class="p">(...</span><span class="nx">args</span><span class="p">){</span>
	<span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">arg</span> <span class="k">of</span> <span class="nx">args</span><span class="p">)</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">arg</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런식으로도 구현이 가능하다!!</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">showName</span><span class="p">(</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">,</span> <span class="p">...</span><span class="nx">titles</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//firstName = Bora;</span>
	<span class="c1">//LastName = Lee;</span>
	<span class="c1">// titles = ["Software Engineer", "Researcher"]</span>
<span class="p">}</span>

<span class="nx">showName</span><span class="p">(</span><span class="dl">"</span><span class="s2">Bora</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Software Engineer</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Researcher</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="스프레드-문법">스프레드 문법</h3>

<p>배열안에 있는 요소들을 함수안에 사용을 하여 매개변수로 사용할 떄, 그냥 <code class="language-plaintext highlighter-rouge">max(arr)</code> 이런식으로 하면 안된다!!</p>
<blockquote>
  <p>뭔가 파이썬이면 될거같은데…</p>
</blockquote>

<p>그래서 아까처럼 가변인자처럼 넘겨쓰는 스프레드 문법을 사용해야 된다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>

<span class="nx">alert</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">arr1</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span> <span class="c1">//9</span>
</code></pre></div></div>

<p>이런식으로 사용하면 된다!!</p>

<h2 id="new-function-문법">New Function 문법</h2>

<p><code class="language-plaintext highlighter-rouge">new Function</code>을 통해 함수를 만들어 보자!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">let func = new Function ([arg1, arg2, ...argN], functionBody);</code></p>
</blockquote>

<p>새로 만들어지는 함수는 들어오는 인수 arg1…argN 과 functionBody로 이루어지며 최대 장점은 런타임 시간에 동적으로 문자열을 사용해 함수를 만들 수 있는것!!</p>

<h2 id="함수-바인딩">함수 바인딩</h2>

<blockquote>
  <p>setTimeout 을 진행하면 Method callback 진행 시 <code class="language-plaintext highlighter-rouge">this</code>정보가 사라지는데, 방지를 어떻게 할것인가!!</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">this</code>가 사라지는 과정</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">firstName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span><span class="p">,</span>
	<span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">alert</span> <span class="p">(</span><span class="s2">`Hello </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">(),</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>이러면 당연히 <code class="language-plaintext highlighter-rouge">Hello Yoon!</code> 이 나와야될것 처럼 보이지만, <code class="language-plaintext highlighter-rouge">setTimeout</code>이 객체에서 분리가 되어 <code class="language-plaintext highlighter-rouge">user.sayHi</code>로 전달되어 <code class="language-plaintext highlighter-rouge">Hello undefined!</code> 가 나오게 된다.</p>

<h3 id="해결방안1-래퍼">해결방안1. 래퍼</h3>

<blockquote>
  <p>쇼미더머니 아님</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">firstName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span><span class="p">,</span>
	<span class="nx">sayHi</span><span class="p">(){</span>
		<span class="nx">alert</span><span class="p">(</span><span class="s2">`Hello </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
	<span class="nx">user</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>이러면 외부 렉시컬 환경에서 <code class="language-plaintext highlighter-rouge">user</code>를 받아오기 때문에 오류가 나지 않는다!!</p>

<h3 id="해결방안2-바인딩">해결방안2. 바인딩</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">firstName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="s2">`Hello </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">funcUser</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">funcUser</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<p>이런식으로 method를 user에 바인딩을 시켜버려서 묶어 버리는 방법이다.</p>

<p>아무리봐도 바인딩이 래퍼보다 사용하기가 쉽고 활용도가 높아보인다!!</p>

<h2 id="화살표-함수">화살표 함수</h2>

<p>화살표 함수에는 대체로 <code class="language-plaintext highlighter-rouge">this</code>가 없다. 화살표 함수에서 <code class="language-plaintext highlighter-rouge">this</code>를 사용하면 외부에서 값을 가져온다고 한다..!!</p>

<p>코드를 살펴보자</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">title</span><span class="p">:</span> <span class="dl">"</span><span class="s2">group1</span><span class="dl">"</span>
	<span class="na">students</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Yoon</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Kim</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Lee</span><span class="dl">"</span><span class="p">],</span>

	<span class="nx">showList</span><span class="p">(){</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">students</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span>
			<span class="nx">student</span> <span class="o">=&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">title</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">student</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="nx">group</span><span class="p">.</span><span class="nx">showList</span><span class="p">();</span>
</code></pre></div></div>

<p>여기서 forEach에서 가리키느 화살표는 <code class="language-plaintext highlighter-rouge">this.title</code>의 화살표 밖에 있는 method인 showList가 가리키는 대상과 동일하다. 즉 <code class="language-plaintext highlighter-rouge">this.title == group.title</code> !!</p>

<blockquote>
  <p>화살표 함수는 new 와 함께 사용될 수 없음에 주의!</p>
</blockquote>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="typescript" /><category term="TIL" /><category term="functions" /><summary type="html"><![CDATA[나머지 매개변수와 스프레드 문법]]></summary></entry><entry><title type="html">자바스크립트 자료구조와 자료형</title><link href="http://localhost:4000/javascript/2022/01/17/javascript-data-structure.html" rel="alternate" type="text/html" title="자바스크립트 자료구조와 자료형" /><published>2022-01-17T00:00:00+09:00</published><updated>2022-01-17T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/01/17/javascript-data-structure</id><content type="html" xml:base="http://localhost:4000/javascript/2022/01/17/javascript-data-structure.html"><![CDATA[<h2 id="자료구조와-자료형">자료구조와 자료형</h2>

<p>기본적으로, 프로그래밍 언어들에 대한 기본지식이 있는 상태로 공부를 진행하여, 기본적인 유형인 부분들은 스킵하도록 하였다</p>

<h3 id="원시값과-객체의-차이">원시값과 객체의 차이</h3>

<p>원시값이란</p>
<ul>
  <li>원시형의 값</li>
  <li>종류로는 <code class="language-plaintext highlighter-rouge">string, number, bigint, boolean, symbol, null, undefined </code>으로 총 7가지가 올 수 있다</li>
</ul>

<p>객체</p>
<ul>
  <li>Property에 다양한 종류의 값을 저장 할 수 있다</li>
  <li><code class="language-plaintext highlighter-rouge">{name: "Yoon", age: 25}</code>와 같이 {}를 사용해 만들 수 있다</li>
  <li>자바스크립트에는 여러 종류의 객체가 있으며, 함수도 객체의 일종이다</li>
</ul>

<h3 id="문자열">문자열</h3>
<blockquote>
  <p>자바스크립트는 글자 하나만 저장 할 수 있는 <code class="language-plaintext highlighter-rouge">char</code> 형의 자료형이 없다!</p>
</blockquote>

<p>따옴표의 종류가 <code class="language-plaintext highlighter-rouge">'</code> 와 <code class="language-plaintext highlighter-rouge">"</code> 으로 두개 있고, 둘 다 사용 할 수 있으며, 백틱으로도 감쌀 수가 있다. 그리고 백틱에는 특별한 기능이 있는데, 표현식을 ${…} 으로 감싸고 이를 백틱에 감싼 문자열에 넣어주면, 표현식을 쉽게 삽입을 할 수 있게 해준다</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">template literal</code> 이라 부른다
예시를 보면</p>
  <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">){</span>
	<span class="k">return</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="s2">`1 + 2 = </span><span class="p">${</span><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span><span class="s2">.`</span><span class="p">);</span>
</code></pre></div>  </div>
  <p>또한 백틱을 이용하여 문자열을 여러줄로 작성 할 수 도 있다</p>
  <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">guests</span> <span class="o">=</span> <span class="s2">`Guests:
	* Kim
	* Yoon
	* Lee
`</span><span class="p">;</span>
</code></pre></div>  </div>
</blockquote>

<h3 id="배열">배열</h3>

<p>배열 선언에는 두가지 방법이 있다</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span><span class="c1">//no.1</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span><span class="c1">//no.2</span>
</code></pre></div></div>
<ul>
  <li>그리고 두번째 방법으로 대괄호 안에, 초기화를 시켜주는 것 또한 가능하다.</li>
  <li>배열 요소의 자료형에는 제약이 없다
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">apple</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">yoon</span><span class="dl">'</span><span class="p">},</span> <span class="kc">true</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);}];</span>
  <span class="nx">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]();</span> <span class="c1">//hello</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="반복문">반복문</h4>
<p><code class="language-plaintext highlighter-rouge">for</code>문은 배열을 순회 할 때 사용하는 가장 쉬운 방법이다
배열에 적용하는 순회 방법중 가장 쉬운 for…of를 사용해 보자</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">fruits</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">apple</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">orange</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">pear</span><span class="dl">'</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">fruit</span> <span class="k">of</span> <span class="nx">fruits</span><span class="p">){</span>
	<span class="nx">alert</span> <span class="p">(</span><span class="nx">fruit</span><span class="p">);</span><span class="c1">//apple -&gt; orange -&gt; pear</span>
<span class="c1">//	or alert(arr[key]);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">for..of</code>를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다. 하지만 구현하기가 쉽고 문법도 짧아 배열의 요소를 대상으로 반복 작업을 할 때는 매우 편리하다</p>

<h3 id="iterable-객체"><code class="language-plaintext highlighter-rouge">iterable</code> 객체</h3>

<ul>
  <li>반복 가능한 객체는 배열을 일반화 한 객체이다</li>
  <li><code class="language-plaintext highlighter-rouge">iterable</code>을 사용하여 어떤 객체에서든 <code class="language-plaintext highlighter-rouge">for..of</code> 반복문을 적용 시킬 수 있다</li>
</ul>

<h4 id="symboliterator"><code class="language-plaintext highlighter-rouge">Symbol.iterator</code></h4>
<ol>
  <li><code class="language-plaintext highlighter-rouge">range</code> 를 iterable로 만들기 위해 객체에 <code class="language-plaintext highlighter-rouge">Symbol.iterator</code> 를 추가한다</li>
  <li><code class="language-plaintext highlighter-rouge">for..of</code> 가 시작되면 <code class="language-plaintext highlighter-rouge">Symbol.iterator</code>를 호출 해 조건성을 만족시킨다</li>
  <li><code class="language-plaintext highlighter-rouge">for..of</code>는 반환된 객체만을 대상으로 동작한다</li>
  <li><code class="language-plaintext highlighter-rouge">for..of</code>에 다음값이 필요하면 iterator의 <code class="language-plaintext highlighter-rouge">next()</code>를 호출한다</li>
  <li><code class="language-plaintext highlighter-rouge">next()</code>의 반환값은 <code class="language-plaintext highlighter-rouge">{done: Boolean, value: any}</code> 와 같은 형태이고 <code class="language-plaintext highlighter-rouge">done === true</code>면 반복이 종료되었다는 뜻이다</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">range</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">from</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">to</span><span class="p">:</span> <span class="mi">5</span>
<span class="p">};</span>

<span class="c1">// 1. for..of 최초 호출 시, Symbol.iterator가 호출됩니다.</span>
<span class="nx">range</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Symbol.iterator는 이터레이터 객체를 반환합니다.</span>
  <span class="c1">// 2. 이후 for..of는 반환된 이터레이터 객체만을 대상으로 동작하는데, 이때 다음 값도 정해집니다.</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">current</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="k">from</span><span class="p">,</span>
    <span class="na">last</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">to</span><span class="p">,</span>

    <span class="c1">// 3. for..of 반복문에 의해 반복마다 next()가 호출됩니다.</span>
    <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 4. next()는 값을 객체 {done:.., value :...}형태로 반환해야 합니다.</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">current</span> <span class="o">&lt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span> <span class="na">done</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">current</span><span class="o">++</span> <span class="p">};</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span> <span class="na">done</span><span class="p">:</span> <span class="kc">true</span> <span class="p">};</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// 이제 의도한 대로 동작합니다!</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">num</span> <span class="k">of</span> <span class="nx">range</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span> <span class="c1">// 1, then 2, 3, 4, 5</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="date-객체와-날짜">Date 객체와 날짜</h3>
<p>날짜를 저장 할 수 있고, 관련된 함수를 제공하는 <code class="language-plaintext highlighter-rouge">Date</code>에 대해 알아보자</p>
<ul>
  <li>객체의 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">new Date()</code> 를 호출해 새로운 객체를 만들어 사용 할 수 있다</li>
    </ul>
  </li>
  <li>날짜 찾기
    <ul>
      <li>getFullYear() -&gt; 네자릿수 연도</li>
      <li>getMonth() -&gt; 0부터 11까지의 월</li>
      <li>getDate() -&gt; 1부터 31까지 날</li>
      <li>getHours()</li>
      <li>getMinutes()</li>
      <li>getSeconds()</li>
      <li>getMillioseconds()</li>
      <li>getDay() -&gt; 0부터 6까지, 일요일부터 토요일</li>
      <li>getTime() -&gt; 주어진 시간과 1970년 1월 1일 00초 사이의 간격</li>
      <li>getTimezoneOffset() -&gt; 현지 시간과 표준 시간의 차이를 반환</li>
    </ul>
  </li>
</ul>

<h3 id="json과-method">JSON과 Method</h3>

<p>복잡한 객체를 사용하고 있어, 네트워크를 통해 객체를 보내거나 로깅 목적으로 객체를 출력해야 할 때 사용하는 방법으로 <code class="language-plaintext highlighter-rouge">JSON</code>을 사용 할 수 있다</p>

<h4 id="jsonstringify">JSON.stringify</h4>
<ul>
  <li>JSON,stringify -&gt; 객체를 JSON으로 바꿔준다</li>
  <li>JSON.parse -&gt; JSON을 객체로 바꿔준다</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">student</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Yoon</span><span class="dl">'</span><span class="p">,</span>
	<span class="na">age</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>
	<span class="na">isAdmin</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
	<span class="na">courses</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">html</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">css</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">js</span><span class="dl">'</span><span class="p">],</span>
	<span class="na">wifi</span><span class="p">:</span><span class="kc">null</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">json</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">student</span><span class="p">);</span>

<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">json</span><span class="p">);</span> <span class="c1">//string</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span><span class="c1">//student의 내용을 string으로 출력</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="typescript" /><category term="TIL" /><category term="data structure" /><summary type="html"><![CDATA[자료구조와 자료형]]></summary></entry></feed>