<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-05-08T16:55:58+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YeongGi’s tech blog</title><subtitle>This is YeongGi&apos;s tech blog. I post IT related items.</subtitle><author><name>071yoon</name></author><entry><title type="html">NEXT-Others-2</title><link href="http://localhost:4000/next.js/2022/05/08/next-others-2.html" rel="alternate" type="text/html" title="NEXT-Others-2" /><published>2022-05-08T00:00:00+09:00</published><updated>2022-05-08T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/08/next-others-2</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/08/next-others-2.html"><![CDATA[<h2 id="environment-variables">Environment Variables</h2>

<h3 id="loading-environment-variables">Loading Environment Variables</h3>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 우선 내부적으로 <code class="language-plaintext highlighter-rouge">.env.local</code> 과 <code class="language-plaintext highlighter-rouge">process.env</code> 같은 환경변수를 제공해준다. 예를들어 <code class="language-plaintext highlighter-rouge">.env.local</code> 같은 경우에는 다음과 같이 사용한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB_HOST</span><span class="o">=</span>localhost
<span class="nv">DB_USER</span><span class="o">=</span>myuser
<span class="nv">DB_PASS</span><span class="o">=</span>mypassword
</code></pre></div></div>

<p>해당 환경변수들은 Node.js에서 자동으로 <code class="language-plaintext highlighter-rouge">Next.js</code>의 데이터를 가져오는 방식으로 사용하게 된다. 예를들어 해당 환경변수를 가지고 ` getStaticProps`를 사용하는 방식을 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">myDB</span><span class="p">.</span><span class="nx">connect</span><span class="p">({</span>
    <span class="na">host</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_HOST</span><span class="p">,</span>
    <span class="na">username</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_USER</span><span class="p">,</span>
    <span class="na">password</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_PASS</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>서버가 민감한 정보들을 안전하게 다루기 위해 Next.js는 <code class="language-plaintext highlighter-rouge">process.env.*</code> 파일을 빌드 시간에 맞는 경로로 전달한다. 즉 <code class="language-plaintext highlighter-rouge">process.env</code>는 자바스크립트에서의 표준이 아니며, object destructuring을 사용할 수 없다는 뜻이다. 즉 환경 변수는 <code class="language-plaintext highlighter-rouge">const { PUBLISHABLE_KEY } = process.env</code> 처럼 사용하는 것이 아닌 <code class="language-plaintext highlighter-rouge">process.env.PUBLISHABLE_KEY</code> 처럼 사용해야 된다.</td>
    </tr>
  </tbody>
</table>

<p>또한 Next.js는 (<code class="language-plaintext highlighter-rouge">$VAR</code>) 과 같은 변수들은 자동적으로 <code class="language-plaintext highlighter-rouge">.env*</code> 파일에서 연장하여 사용한다. 변수를 사용한 방법은 다음과 같다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># .env</span>
<span class="nv">HOSTNAME</span><span class="o">=</span>localhost
<span class="nv">PORT</span><span class="o">=</span>8080
<span class="nv">HOST</span><span class="o">=</span>http://<span class="nv">$HOSTNAME</span>:<span class="nv">$PORT</span>
</code></pre></div></div>

<p>만약 <code class="language-plaintext highlighter-rouge">$</code> 를 그대로 쓰고싶다면 <code class="language-plaintext highlighter-rouge">\$</code> 과 같이 백슬래쉬를 넣어 사용해야된다.</p>

<h3 id="exposing-environment-variables-to-the-browser">Exposing Environment Variables to the Browser</h3>

<p>일반적인 환경변수들은 <code class="language-plaintext highlighter-rouge">Node.js</code> 환경에서만 사용가능하므로, 브라우저에 유출이 되진 않는다. 만약 브라우저에서 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC</code> 으로 시작하는 변수를 외부로 유출시키고 싶다면, 다음과 같이 사용하면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NEXT_PUBLIC_ANALYTICS_ID</span><span class="o">=</span>abcdefghijk
</code></pre></div></div>

<p>이렇게 사용하게 되면, <code class="language-plaintext highlighter-rouge">process.env.NEXT_PUBLIC_ANALYTICS_ID</code>가 로드되어, Node.js 환경으로 자동으로 들어가 코드 어디에서도 사용 할 수 있게 된다. 즉 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_</code>과 같은 접두사를 사용하게 된다면, 자바스크립트가 브라우저에게 바로 값을 넘겨주게 된다. 이러한 인라인은 빌드시간에 일어나며, 다음과 같은 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_</code>의 환경변수들은 프로젝트가 빌드가 끝난 후 사용된다. 코드에서 사용되는 예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/index.js</span>
<span class="k">import</span> <span class="nx">setupAnalyticsService</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../lib/my-analytics-service</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// NEXT_PUBLIC_ANALYTICS_ID can be used here as it's prefixed by NEXT_PUBLIC_</span>
<span class="nx">setupAnalyticsService</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NEXT_PUBLIC_ANALYTICS_ID</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">HomePage</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">World</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">HomePage</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="default-envrionment-variables">Default Envrionment Variables</h3>

<p>일반적으로는 하나의 <code class="language-plaintext highlighter-rouge">.env.local</code>파일만이 필요하다. 하지만 가끔 <code class="language-plaintext highlighter-rouge">development</code>나 <code class="language-plaintext highlighter-rouge">production</code>에 따라 다른 환경 변수들을 사용 할 수 있다. 그래서 <code class="language-plaintext highlighter-rouge">Next.js</code> 는 <code class="language-plaintext highlighter-rouge">.env</code>, <code class="language-plaintext highlighter-rouge">.env.development</code>, <code class="language-plaintext highlighter-rouge">.env.production</code>과 같은 환경변수 또한 지원하며 <code class="language-plaintext highlighter-rouge">.env.local</code>을 항상 표준으로 둔다.</p>

<table>
  <tbody>
    <tr>
      <td>주의사항으로는 <code class="language-plaintext highlighter-rouge">.env</code>, <code class="language-plaintext highlighter-rouge">.env.development</code>, <code class="language-plaintext highlighter-rouge">.env.production</code> 과 같은 파일들은 <code class="language-plaintext highlighter-rouge">.env*.local</code>에 정의되어 있어야 하고 <code class="language-plaintext highlighter-rouge">.gitignore</code>에 포함시켜 안전하게 보관해야된다.</td>
    </tr>
  </tbody>
</table>

<h3 id="test-envrionment-variables">Test Envrionment Variables</h3>

<p><code class="language-plaintext highlighter-rouge">development</code>와 <code class="language-plaintext highlighter-rouge">production</code> 환경변수외로, <code class="language-plaintext highlighter-rouge">text</code>라는 세번째 옵션이 또 존재한다. 앞선 방법들과 마찬가지로 <code class="language-plaintext highlighter-rouge">.env.teest</code>에서 <code class="language-plaintext highlighter-rouge">testing</code> 환경을 구축하여 사용 할 수 있다.</p>

<p>이러한 방법은 <code class="language-plaintext highlighter-rouge">jest</code>나 <code class="language-plaintext highlighter-rouge">cypress</code>와 같은 테스팅 툴을 사용할 때 유용하게 사용 할 수 있다. 이러한 테스트 방식은 <code class="language-plaintext highlighter-rouge">NODE_ENV</code>가 <code class="language-plaintext highlighter-rouge">test</code>로 되어있다면, 테스트의 표준 환경을 사용 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">test</code> 가 <code class="language-plaintext highlighter-rouge">development</code> 와 <code class="language-plaintext highlighter-rouge">production</code> 와 다른점이 있다면, 테스트 환경은 <code class="language-plaintext highlighter-rouge">.env.local</code>에 로딩이 안된다는 것이다. 이러한 방식으로 실행되어야 매번 같은 환경을 사용할 수 있기 때문이다.</p>

<p>unit test 를 하는 동안에는 <code class="language-plaintext highlighter-rouge">@next/env</code> 패키지를 사용하여 <code class="language-plaintext highlighter-rouge">loadEnvConfig</code>를 해야함에 주의한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The below can be used in a Jest global setup file or similar for your testing set-up</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">loadEnvConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@next/env</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">projectDir</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">cwd</span><span class="p">();</span>
  <span class="nx">loadEnvConfig</span><span class="p">(</span><span class="nx">projectDir</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>env의 우선순위는 다음과 같다.</p>

<h4 id="node_envproduction">NODE_ENV=production</h4>

<ol>
  <li>.env.production.local</li>
  <li>.env.local</li>
  <li>.env.production</li>
  <li>.env</li>
</ol>

<h4 id="node_envdevelopment">NODE_ENV=development</h4>

<ol>
  <li>.env.development.local</li>
  <li>.env.local</li>
  <li>.env.development</li>
  <li>.env</li>
</ol>

<h4 id="node_envtest">NODE_ENV=test</h4>

<ol>
  <li>.env.test.local</li>
  <li>.env.test</li>
  <li>.env</li>
</ol>

<h2 id="supported-browsers-and-features">Supported Browsers and Features</h2>

<h2 id="script-component">Script Component</h2>

<p>Image를 NEXT 에서 제공했던것 처럼, Script같은 경우에도 따로 지정해주는걸 사용하는것이 효율과 성능면에서 더 좋다. 해당 Script 컴포넌트는 <code class="language-plaintext highlighter-rouge">next/script</code>에서 가져올 수 있으며 기본적인 HTML <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>의 연장선이다. 해당 <script></script>는 <code class="language-plaintext highlighter-rouge">next/head</code> 밖에서 개발자들에게 로딩하는 우선순위를 지정할 수 있게 해주어 로딩 효율을 높여준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Script</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/script</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://www.google-analytics.com/analytics.js</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="overview">Overview</h3>

<p>웹사이트는 가끔 통계, 광고, 위젯등을 사용할 때 써드파티의 스크립트를 사이트에서 사용하게 된다. 하지만 이러한 스크립트를 가져오는것이 보통 유저와 개발 입장에서 둘 다 문제를 일으키게 된다.</p>

<ul>
  <li>어떠한 써드파티의 스크립트 같은경우 너무 무거워서 로딩효율이 안좋고, UX 관점에서 되게 안좋을 수 있다. 특히나, render-block 혹은 딜레이가 생길 수 있다.</li>
  <li>개발자들은 어떠한 써드파티의 스크립트를 어디에 두어야 효율적인 로딩이 될지 고민하게 된다.</li>
</ul>

<p>이러한 문제들을 Next 에서 제공하는 <code class="language-plaintext highlighter-rouge">Script</code>를 사용하여 해결 할 수 있다.</p>

<h3 id="usage">Usage</h3>

<p>이러한 <code class="language-plaintext highlighter-rouge">Script</code>를 사용시에, <code class="language-plaintext highlighter-rouge">strategy</code>란 속성을 두어서 관리를 할 수 있다. 간단한 예제를 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://connect.facebook.net/en_US/sdk.js</span><span class="dl">"</span> <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">lazyOnload</span><span class="dl">"</span> <span class="o">/&gt;</span>
</code></pre></div></div>

<p>속성들을 보면 다음과 같다.</p>

<ul>
  <li><a href="#beforeinteractive">beforeInteractive</a></li>
  <li><a href="#afterinteractive">afterInteractive</a></li>
  <li><a href="#lazyonload">lazyOnload</a></li>
  <li><a href="#worker">worker</a></li>
</ul>

<h4 id="beforeinteractive">beforeInteractive</h4>

<p><code class="language-plaintext highlighter-rouge">beforeInteractive</code>속성이 있는 스크립트 같은 경우에는 최초의 HTML에 들어가, 서버가 바로 실행하여 self-bundle된 Javascript가 실행되기 전에 돌아간다. 이러한 방법은 페이지가 상호작용을 하기도전에, fetch하여 실행을 해야될 경우 주로 사용된다. 이러한 방법은 메인 페이지인 <code class="language-plaintext highlighter-rouge">_document.js</code>에서 동작하며, 보통 모든 사이트에서 로딩이 필요한 script인 경우에 들어가서 실행된다.</p>

<p>이러한 <code class="language-plaintext highlighter-rouge">beforeInteractive</code>한 방법이 사용되는 이유는, 오직 <code class="language-plaintext highlighter-rouge">_document.js</code>에서만 동작하게 하여 스티리밍과 Suspense functionality를 지원하기 위함이다. 즉 <code class="language-plaintext highlighter-rouge">_document.js</code> 의 밖에서는 <code class="language-plaintext highlighter-rouge">beforeInteractive</code>의 방식이 우선순위를 잘 두어 실행된다는 보장을 할 수 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In _document.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Html</span><span class="p">,</span> <span class="nx">Head</span><span class="p">,</span> <span class="nx">Main</span><span class="p">,</span> <span class="nx">NextScript</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/document</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Script</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/script</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Document</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Head</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">Script</span>
          <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js</span><span class="dl">"</span>
          <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">beforeInteractive</span><span class="dl">"</span>
        <span class="o">&gt;&lt;</span><span class="sr">/Script</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>보통 이러한 속성을 띄는 예는 다음과 같다.</p>

<ul>
  <li>Bot detectors</li>
  <li>Cookie consent managers</li>
</ul>

<h4 id="afterinteractive">afterInteractive</h4>

<p><code class="language-plaintext highlighter-rouge">afterInteractive</code> 방법을 쓰는 Script같은 경우에는 클라이언트 딴에서 삽입되어, Next.js가 hydration 작업을 마친 후에 동작한다. 이러한 방식은 제일빨리 실행될 필요가 없으며 우선순위가 낮을 때 사용하게 된다.</p>

<p>이러한 방식의 스크립트는 다음과 같은 상황에 많이 사용된다.</p>

<ul>
  <li>Tag managers</li>
  <li>Analytics</li>
</ul>

<h4 id="lazyonload">lazyOnload</h4>

<p><code class="language-plaintext highlighter-rouge">lazyOnload</code>의 속성을 띄는 Script 같은 경우에는, 모든 리소스들이 로딩된 후 <code class="language-plaintext highlighter-rouge">idle</code> 한 시간에 fetch되어 정보를 가져올 떄 사용된다. 이러한 방식은 background 나 낮은 우선순위를 가진 스크립트들이 주로 사용된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://connect.facebook.net/en_US/sdk.js</span><span class="dl">"</span> <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">lazyOnload</span><span class="dl">"</span> <span class="o">/&gt;</span>
</code></pre></div></div>

<p>이러한 방식을 사용하는 스크립트는 주로 다음과 같다.</p>

<ul>
  <li>Chat support plugins</li>
  <li>Social media widgets</li>
</ul>

<h4 id="worker">worker</h4>

<p>해당 속성 같은 경우에는, 메일 쓰레드를 정해주어 효율을 높여주는 방식이지만, 아직 테스트 환경이라 안전하지 않다.</p>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Environment Variables]]></summary></entry><entry><title type="html">NEXT-Others-1</title><link href="http://localhost:4000/next.js/2022/05/05/next-others-1.html" rel="alternate" type="text/html" title="NEXT-Others-1" /><published>2022-05-05T00:00:00+09:00</published><updated>2022-05-05T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/05/next-others-1</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/05/next-others-1.html"><![CDATA[<h2 id="static-file-serving">Static File Serving</h2>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 파일을 <code class="language-plaintext highlighter-rouge">public</code>에서 이미지처럼 정적으로 활용 할 수 있다. <code class="language-plaintext highlighter-rouge">public</code>은 root 안에 있어야 하며, <code class="language-plaintext highlighter-rouge">public</code> 안에서는 <code class="language-plaintext highlighter-rouge">/</code>로 시작하는 base URL을 따라가야된다.</p>

<p><code class="language-plaintext highlighter-rouge">public/me.png</code>를 삽입하는 과정은 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Avatar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Image</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span> <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">me</span><span class="dl">"</span> <span class="nx">width</span><span class="o">=</span><span class="dl">"</span><span class="s2">64</span><span class="dl">"</span> <span class="nx">height</span><span class="o">=</span><span class="dl">"</span><span class="s2">64</span><span class="dl">"</span> <span class="o">/&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Avatar</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">next/img</code>의 대한 내용은 <a href="2022-05-04-next-optimization.md">NextOptimization</a> 를 참고.</p>

<p>이러한 폴더는 <code class="language-plaintext highlighter-rouge">robots.txt</code> 혹은 <code class="language-plaintext highlighter-rouge">favicon.ico</code> 에서도 사용이 될 수 있으며, Google Site Verification 등에도 활용될 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>주의사항! <code class="language-plaintext highlighter-rouge">public</code>이란 명명은 다른곳에서 사용하면 안된다. 해당 폴더는 정적인 asset만 포함되어야 된다!</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>주의사항2! 마찬가지로 정적 파일을 <code class="language-plaintext highlighter-rouge">pages/</code>라는 폴더 안에 넣게되면 에러가 난다!</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>주의사항3! <code class="language-plaintext highlighter-rouge">public</code> 폴더 안에 들어간 assets 들 만이 빌드 타임에서 Next.js로 넘겨진다. 런타임중에서는 추가가 되어도 활용되지 않으므로, <code class="language-plaintext highlighter-rouge">AWS S3</code>과 같은 third party를 사용하는 것이 좋다.</td>
    </tr>
  </tbody>
</table>

<h2 id="fast-refresh">Fast Refresh</h2>

<p>Fast Refresh는 React component에 편집을 한 즉시 피드백을 주는 기능이다. 이러한 기능은 Next.jsdml 9.4 이상에서 자동으로 작동하며, 켜져있다면 component 의 상태정보를 잃지 않고 바로 확인을 할 수 있다.</p>

<h3 id="how-it-works">How It Works</h3>

<ul>
  <li>
    <p>만약 <code class="language-plaintext highlighter-rouge">React component</code>만 export하는 환경이라면, Fast Refresh는 오직 그 한 파일만 업데이트를 하며, 컴포넌트를 다시 렌더링 해준다. 해당 파일 안에서는 style, logic, handler, effects 등 아무거나 편집을 해도 된다!</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">React component</code>가 아닌 파일을 편집한다면, Fast Refresh는 두 파일 모두와 import 된 다른 파일들을 재실행 할 것이다. 예를들어, <code class="language-plaintext highlighter-rouge">Button.tsx</code>와 <code class="language-plaintext highlighter-rouge">Modal.tsx</code>가 <code class="language-plaintext highlighter-rouge">theme.tsx</code>를 import 한다면, <code class="language-plaintext highlighter-rouge">theme.tsx</code>를 편집하게 되면, 두 컴포넌트 다 업데이트가 된다.</p>
  </li>
  <li>
    <p>만약 React 구조에서 벗어난 import 파일을 편집하게 된다면, Fast Refresh는 full reload를 어쩔 수 없이 하게된다. 예를들어, 만약 상수 component를 export 하지만, non-React utility file이 import 되어 있다면 파일의 위치를 바꾸어야된다.</p>
  </li>
</ul>

<h3 id="error-resillience">Error Resillience</h3>

<h4 id="syntax-errors">Syntax Errors</h4>

<p>만약 개발중에 syntax error가 나온다면, 수정 후 파일을 저장하면 바로 적용이 된다. 오류는 자동으로 없어지고, 앱을 재로딩할 필요도 없다.</p>

<table>
  <tbody>
    <tr>
      <td>컴포넌트의 상태정보 또한 잃지 않는다.</td>
    </tr>
  </tbody>
</table>

<h4 id="runtime-errors">Runtime Errors</h4>

<p>만약 런타임 에러가 나는 코드를 짜버렸다면, contextual overlay가 나온다. 에러를 고치면 바로 overlay가 없어지면서 앱이 재로딩이 된다.</p>

<p>컴포넌트의 상태정보는 렌더링을 하지 않았을 시 저장된다. 만약 렌더링 중에 에러가 나왔다면, 리액트는 업데이트된 코드로 재구동 한다.</p>

<p>만약 앱에 <code class="language-plaintext highlighter-rouge">error boundaries</code>가 설정 되어있다면, 렌더링 에러 이후 렌더링하려고 바로 재시도를 한다. 즉 <code class="language-plaintext highlighter-rouge">error boundary</code>가 설정되어 있다면, 루트의 앱 상탲정보를 항상 재설정 해주는 수고를 겪지 않아도 된다. 하지만, <code class="language-plaintext highlighter-rouge">error boundary</code>가 너무 세분화되면 안된다. 보통 React production에 많이 사용되고, 의도적으로 사용되어야 한다.</p>

<h3 id="limitations">Limitations</h3>

<p>Fast Refresh는 컴포넌트를 수정시에도 local React state를 유지하려고 노력한다.</p>

<table>
  <tbody>
    <tr>
      <td>안전하다고 판단될떄만 사용해야됨!</td>
    </tr>
  </tbody>
</table>

<p>local state가 자주 재설정 되는 이유는 다음과 같다.</p>

<ul>
  <li>
    <p>Local State는 클래스 컴포넌트에서 예약되어지지 않는다.</p>
  </li>
  <li>
    <p>편집하려는 파일이 다른 export된 리액트 컴포넌트를 사용하고 있을 수 도 있다.</p>
  </li>
  <li>
    <p>파일이 <code class="language-plaintext highlighter-rouge">HOC</code>같은 상위의 컴포넌트를 export 할 수 있다. 만약 리턴된 형태가 class라면 상태는 리셋된다.</p>
  </li>
  <li>
    <p>익명 화살표함수는 Fast Refresh를 local component state에 저장하지 않는다. 더 큰 코드인 경우에는 <code class="language-plaintext highlighter-rouge">name-default-component</code>를 사용 할 수 있다.</p>
  </li>
</ul>

<h3 id="tips">Tips</h3>

<p>Fast Refresh는 React local state를 함수 컴포넌트로 예약한다</p>

<table>
  <tbody>
    <tr>
      <td>만약 강제로 상태를 초기화하고 싶을 수가 있다. <code class="language-plaintext highlighter-rouge">// @refresh reset</code>과 같이 초기화 할 수 있다.</td>
    </tr>
  </tbody>
</table>

<h3 id="fast-refresh-and-hooks">Fast Refresh and Hooks</h3>

<p>가능하다면 Fast Refresh는 수정중에 컴포넌트에 상태 정보를 저장한다. 특히 <code class="language-plaintext highlighter-rouge">useState</code> 와 <code class="language-plaintext highlighter-rouge">useRef</code> 같은 경우에, 인자나 Hook call을 하지 않는 이상 이전값을 저장하고 있다.</p>

<p><code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useMemo</code>, <code class="language-plaintext highlighter-rouge">useCallback</code> 같은 의존성이 있는 Hook 같은 경우에는, Fast Refresh중에 항상 update 된다. 이러한 의존성들은 Fast Refresh가 일어나고 있는중에 무시된다. 예를들어, <code class="language-plaintext highlighter-rouge">useMemo(() =&gt; x * 2, [x])</code> 가 <code class="language-plaintext highlighter-rouge">useMemo(() =&gt; x * 10, [x])</code> 로 변환다면, x가 변하지 않았음에도 불구하고 재실행 된다.</p>

<p>위와 같은 방법은 예상치못한 결과를 낳을 수 있다. 예를들어 <code class="language-plaintext highlighter-rouge">uesEffect</code>가 빈 배열을 줄 수 도 있다. 하지만, 이런 탄력적인 코드를 사용하는것은 좋은 연습이 된다.</p>

<h2 id="typescript">TypeScript</h2>

<h3 id="typescript로-npx-설정하는법">TypeScript로 npx 설정하는법</h3>

<p>새로 설정하는것이라면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx create-next-app@latest <span class="nt">--ts</span>
<span class="c"># or</span>
yarn create next-app <span class="nt">--typescript</span>
<span class="c"># or</span>
pnpm create next-app <span class="nt">--</span> <span class="nt">--ts</span>
</code></pre></div></div>

<p>이미 있는 프로젝트에 삽입한다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">touch </span>tsconfig.json
</code></pre></div></div>

<h3 id="static-generation--server-side-rendering">Static Generation &amp; Server-side Rendering</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">GetStaticProps</span><span class="p">,</span> <span class="nx">GetStaticPaths</span><span class="p">,</span> <span class="nx">GetServerSideProps</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStaticProps</span><span class="p">:</span> <span class="nx">GetStaticProps</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStaticPaths</span><span class="p">:</span> <span class="nx">GetStaticPaths</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getServerSideProps</span><span class="p">:</span> <span class="nx">GetServerSideProps</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="api-routing">API Routing</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">NextApiResponse</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">(</span><span class="nx">req</span><span class="p">:</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">NextApiResponse</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John Doe</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>혹은</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">NextApiResponse</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">(</span><span class="nx">req</span><span class="p">:</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">NextApiResponse</span><span class="o">&lt;</span><span class="nx">Data</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John Doe</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>와 같이 사용 할 수 있다.</p>

<h3 id="custom-app">Custom <code class="language-plaintext highlighter-rouge">App</code></h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">AppProps</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/app</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">}:</span> <span class="nx">AppProps</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="ignoring-typescript-errors">Ignoring TypeScript Errors</h3>

<p>Next.js는 TypeScript 에러가 존재 할 시 build 에서 오류를 낸다.</p>

<p>만약 이러한 오류에도 불구하고 사용을 하고 싶다면 다음과 같이 사용하면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">next.config.js</code>에서 <code class="language-plaintext highlighter-rouge">ignoreBuildErrors</code>를 켜주면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//next.config.js</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">typescript</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// !! WARN !!</span>
    <span class="c1">// Dangerously allow production builds to successfully complete even if</span>
    <span class="c1">// your project has type errors.</span>
    <span class="c1">// !! WARN !!</span>
    <span class="na">ignoreBuildErrors</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Static File Serving]]></summary></entry><entry><title type="html">NEXT-Optimization</title><link href="http://localhost:4000/next.js/2022/05/04/next-optimization.html" rel="alternate" type="text/html" title="NEXT-Optimization" /><published>2022-05-04T00:00:00+09:00</published><updated>2022-05-04T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/04/next-optimization</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/04/next-optimization.html"><![CDATA[<h2 id="image-component-and-image-optimization">Image Component and Image Optimization</h2>

<p><code class="language-plaintext highlighter-rouge">next/image</code> 에서의 Next의 이미지 컴포넌트는 HTML에서 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 의 연장선이라 볼 수 있다. 더 좋은 Web 환경을 위해 더 좋은 효율과 압축성을 보여준다. 이러한 효율성은 웹사이트 사용에 있어 UX 적으로 도움이 된다.</p>

<blockquote>
  <p>SEO 측면에서도 도움이 된다</p>
</blockquote>

<p>이러한 효율성은 크게 4가지로</p>

<ol>
  <li>
    <p>Improve Perforamce : 모든 장치마다 최신 이미지 포맷을 사용하여 정확한 사이즈를 전달한다</p>
  </li>
  <li>
    <p>Visual Stability : CLS(Cumulative Layout Shift)를 방지한다</p>
  </li>
</ol>

<blockquote>
  <p>CLS란 누적 레이아웃 변경으로, 웹페이지를 보는 사용자에게 예상치 못한 화면 변환이 나타나는 빈도 수</p>
</blockquote>

<ol>
  <li>
    <p>Faster Page Loads : 이미지가 <code class="language-plaintext highlighter-rouge">viewport</code>에 접근 시 로딩되어, 빠르고, 로딩 전 blur-up placeholder 를 설정 할 수 있다.</p>
  </li>
  <li>
    <p>Asset Flexibility : 다른 서버에 이미지가 있는 경우에도, 원하는대로 이미지 리사이징이 자유롭다</p>
  </li>
</ol>

<h3 id="local-images">Local Images</h3>

<p>이미지의 예제는 다음과 같다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">profilePic</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../public/me.png</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="p">{</span><span class="nx">profilePic</span><span class="p">}</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="c1">// width={500} automatically provided</span>
        <span class="c1">// height={500} automatically provided</span>
        <span class="c1">// blurDataURL="data:..." automatically provided</span>
        <span class="c1">// placeholder="blur" // Optional blur-up while loading</span>
      <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">import</code> 하는 과정이 정적이 되어야 build 과정에서 분석이 되기에 <code class="language-plaintext highlighter-rouge">await import()</code> 혹은 <code class="language-plaintext highlighter-rouge">require()</code>같은 동적인 행동은 지원하지 않는다.</p>

<table>
  <tbody>
    <tr>
      <td>width 와 height 가 자동으로 고정 된 이유는 CLS를 방지하기 위함이다</td>
    </tr>
  </tbody>
</table>

<h3 id="remote-images">Remote Images</h3>

<p>외부에 있는 이미지를 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">src</code>로 위치를 잘 가져와야한다. Next.js같은 경우 build 과정에서 외부로 접근 할 권한이 없으므로 아까 전과는 달리 <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, <code class="language-plaintext highlighter-rouge">blurDataURL</code> 을 넣어 줘야한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="nx">width</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">height</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
      <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="domains">Domains</h3>

<p>가끔 외부의 이미지를 사용하면서도 Next.js의 최적화 기법을 사용하고 싶을 수 있다. <code class="language-plaintext highlighter-rouge">loader</code>를 기본으로 두고, <code class="language-plaintext highlighter-rouge">src</code>에 절대경로 URL을 넣어 사용 할 수 있다.</p>

<p>어플을 외부로부터 보호하기 위해 아래와 같이 <code class="language-plaintext highlighter-rouge">next.config.js</code>파일을 사용하여 외부 도메인으로 바로 접근하는것을 막을 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="k">export</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">images</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">domains</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">071yoon.github.io</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">github.com/071yoon</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="loaders">Loaders</h3>

<p>앞서 <a href="#remote-images">Remote Images</a> 에서처럼 URL의 부분만 쓰는 경우 (<code class="language-plaintext highlighter-rouge">'/me.png'</code>) 는 <code class="language-plaintext highlighter-rouge">next/image</code> 의 loader의 구조상 가능한 부분이다.</p>

<p><code class="language-plaintext highlighter-rouge">Loader</code>는 이미지의 URL을 만들어 주는 기능을 한다. 제공된 <code class="language-plaintext highlighter-rouge">src</code>에 root domain 까지 추가 후 image를 다른 사이즈로 여러 URL을 만들어 연결 요청을 보낸다. 이러한 URL들은 srcset을 만들어내고, 방문자는 각자 <code class="language-plaintext highlighter-rouge">viewport</code>에 맞는 사이즈의 이미지를 볼 수 있게 된다.</p>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>의 default loader는 <code class="language-plaintext highlighter-rouge">built-in Image Optimization API</code>를 사용했고, 웹의 어디에서나 이미지를 최적화 할 수 있었고, 바로 Next.js의 웹 서버에 보냈다. 만약 이미지를 CDN 이나 이미지 서버에 바로 보내고 싶다면, <code class="language-plaintext highlighter-rouge">built-in loader</code>를 사용하거나, 자바스크립트에서 따로 추가를 해야된다.</p>

<p>이러한 로더는 Application Level 에서 이미지당 하나씩 정의가 된다.</p>

<h3 id="priority">Priority</h3>

<p>이미지에 <code class="language-plaintext highlighter-rouge">priority</code>란 속성을 넣어 매 페이지마다 LCP element를 가지게 할 수 있다. 즉 Next.js가 이미지 로딩의 우선순위를 둘 수 있다.</p>

<blockquote>
  <p>LCP : Largest Contentful Paint로 페이지의 메인 컨텐츠가 로드되었을 가능성이 있을 때 페이지 로드 타임라인에 해당 시점을 표시하여 사용자가 감지하는 로드 속도를 측정할 수 있는 메트릭스 -&gt; LCP가 빠르다 = 해당 페이지를 사용할 수 있다</p>
</blockquote>

<p>LCP element는 보통 viewport 에서 가장 큰 이미지거나 텍스트로 본다. <code class="language-plaintext highlighter-rouge">next dev</code> 실행시에, <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> 에 <code class="language-plaintext highlighter-rouge">priority</code>가 설정되어 있지 않다면, Next는 자체적으로 경고창을 띄운다. 예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="nx">width</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">height</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">priority</span>
      <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="image-sizing">Image Sizing</h2>

<p>이미지가 성능에 영향을 미치는 경우는 보통 <code class="language-plaintext highlighter-rouge">layout shift</code>가 일어났을 때 이다. 이러한 <code class="language-plaintext highlighter-rouge">layout shift</code>는 이미지가 로딩되면서 다른 요소들을 밀치고 삽입되는 경우이다. 이런 문제는 Client 입장에서 매우 불편하고 <code class="language-plaintext highlighter-rouge">CLS</code>를 일으킨다. 이러한 문제를 해결하는법은 언제나 이미지의 사이즈를 조정하는것이다. 그럼으로써 브라우저딴에서 항상 로딩되기 전에 이미지의 자리를 예약 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">next/image</code>가 항상 좋은 성능을 위해 디자인 되었으므로, <code class="language-plaintext highlighter-rouge">layout shift</code> 현상은 일어나서는 안된다. 즉 아래 세가지 규칙중 하나를 사용해야 된다.</p>

<ol>
  <li>
    <p>static import를 사용</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">width</code> 와 <code class="language-plaintext highlighter-rouge">height</code> 요소를 사용</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout="fill"</code>을 사용</p>
  </li>
</ol>

<p>3번 같은 경우 내 이미지의 사이즈를 모를 때 사용한다. parent element 사이즈만큼 image가 사이즈될 수 있게 설정하게 된다. 그럼 <code class="language-plaintext highlighter-rouge">objectFit property</code> 를 <code class="language-plaintext highlighter-rouge">fill</code>, <code class="language-plaintext highlighter-rouge">contain</code>, <code class="language-plaintext highlighter-rouge">cover</code>, <code class="language-plaintext highlighter-rouge">objectPosition property</code>와 함께 사용하여 얼마나 이미지가 차지해야되는지 알 수 있다.</p>

<p>만약 내가 아는 소스에서 이미지를 가져오는 것이라면, image의 pipeline을 일반화 하는것이 좋다.</p>

<p>만약 API call 을 사용하여 이미지를 가져온다면, API call 을 중간에 수정하여 URL과 함께 이미지의 크기를 리턴하는것이 가능하다.</p>

<p>만약 위 3가지의 방법을 사용하지 않는다면 <code class="language-plaintext highlighter-rouge">next/image</code>는 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>와 차이가 없다.</p>

<h2 id="styling">Styling</h2>

<p>Styling 같은 경우에 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>와 크게 다를것 없지만, 주의사항이 몇가지 존재한다.</p>

<ol>
  <li>
    <p>올바른 layout mode 설정하기</p>
  </li>
  <li>
    <p>이미지를 className으로 지정하기 (DOM 구조에 맞추지 말것)</p>
  </li>
</ol>

<p>보통 layout에서 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 는 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>에 둘러싸여 있다. 이러한 추가적인 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>은 layout shift를 만드는 주된 원인이다. 즉 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>에 <code class="language-plaintext highlighter-rouge">className</code>을 붙여 CSS Module을 사용하는것이 일반적이다. 혹은, <code class="language-plaintext highlighter-rouge">className</code>을 사용하여 <code class="language-plaintext highlighter-rouge">global stylesheet</code>를 사용할 수 도 있다.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout='fill'</code>을 한다면 <code class="language-plaintext highlighter-rouge">position:relative</code> 도 함께 사용해야된다</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout='responsive'</code>를 사용할 시 <code class="language-plaintext highlighter-rouge">display:block</code>을 같이 사용할 것</p>
  </li>
</ol>

<h2 id="font-optimization">Font Optimization</h2>

<p>버전 <code class="language-plaintext highlighter-rouge">10.2</code> 부터 Next.js 는 built-in web font optimization 을 지원하게 되었다.</p>

<p>일반적으로 Next.js는 자동으로 CSS를 빌드타임에 넣어, 추가적인 반복작업을 피한다. 이렇게 함으로써 FCP 와 LCP에 도움이 된다.</p>

<table>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FCP(First Contentful Paint)</code>란 페이지가 로드되기 시작한 시점부터 컨텐츠의 일부가 화면에 렌더링 될 때까지의 시간 <code class="language-plaintext highlighter-rouge">LCP(Largest Contentful Paint)</code>란 페이지가 로드되기 시작한 시점부터 뷰포트 내부의 가장 큰 이미지 또는 텍스트의 렌더링까지 걸리는 시간</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before</span>
<span class="o">&lt;</span><span class="nx">link</span>
  <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span>
  <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">stylesheet</span><span class="dl">"</span>
<span class="o">/&gt;</span>

<span class="c1">// After</span>
<span class="o">&lt;</span><span class="nx">link</span> <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">preconnect</span><span class="dl">"</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.gstatic.com</span><span class="dl">"</span> <span class="nx">crossorigin</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">style</span> <span class="nx">data</span><span class="o">-</span><span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="p">@</span><span class="nd">font</span><span class="o">-</span><span class="nx">face</span><span class="p">{</span><span class="nx">font</span><span class="o">-</span><span class="nx">family</span><span class="p">:</span><span class="dl">'</span><span class="s1">Inter</span><span class="dl">'</span><span class="p">;</span><span class="nx">font</span><span class="o">-</span><span class="nx">style</span><span class="p">:</span><span class="nx">normal</span><span class="p">...</span>
<span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span></code></pre></div></div>

<h3 id="usage">Usage</h3>

<p>Webfont 를 Next.js에 넣으려면 <code class="language-plaintext highlighter-rouge">Document</code>안에 폰트를 삽입하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/_document.js</span>

<span class="k">import</span> <span class="nx">Document</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Html</span><span class="p">,</span> <span class="nx">Head</span><span class="p">,</span> <span class="nx">Main</span><span class="p">,</span> <span class="nx">NextScript</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/document</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">MyDocument</span> <span class="kd">extends</span> <span class="nx">Document</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Head</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">link</span>
            <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span>
            <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">stylesheet</span><span class="dl">"</span>
          <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="sr">/Head</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">MyDocument</span><span class="p">;</span>
</code></pre></div></div>

<p>특이한점은 해당 폰트는 특정한 페이지에만 사용되므로 <code class="language-plaintext highlighter-rouge">next/head</code>를 사용하지 않는다는 점이다. 현재 Automatic Webfont Optimization 은 Google Fonts에 의해 지원된다.</p>

<h3 id="disabling-optimization">Disabling Optimization</h3>

<p>Font Optimization 을 끄는 방식은 아래와 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// next.config.js</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimizeFonts</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Image Component and Image Optimization]]></summary></entry><entry><title type="html">NEXT-Layouts</title><link href="http://localhost:4000/next.js/2022/04/28/next-layouts.html" rel="alternate" type="text/html" title="NEXT-Layouts" /><published>2022-04-28T00:00:00+09:00</published><updated>2022-04-28T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/28/next-layouts</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/28/next-layouts.html"><![CDATA[<h2 id="layouts">Layouts</h2>

<p>React는 페이지를 컴포넌트로 나누는것이 가능하다. 이러한 컴포넌트들은 페이지간에 재사용이 가능하고, 예를 들어, 모든 페이지마다 같은 네비게이션바를 사용한다.</p>

<h3 id="single-shared-layout-with-custom-app">Single Shared Layout with Custom App</h3>

<p>만약 전체 어플에 대하여 하나의 레이아웃만 사용한다면, Custom App 을 만들어, 해당 레이아웃으로 둘러 쌀 수 있다. 해당 컴포넌트가 모든 페이지마다 재사용되므로, 이러한 컴포넌트의 상태정보는 계속 유지된다.</p>

<table>
  <tbody>
    <tr>
      <td>예를 들어, input value가 들어와도 고정된다</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Layout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/layout</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="per-page-layout">Per-Page Layout</h3>

<p>만약 여러 레이아웃이 필요한 경우에, <code class="language-plaintext highlighter-rouge">getLayout</code> 이라는 property를 사용 할 수 있다. 컴포넌트안에 getLayout을 사용해서, 표현할지 안할지로 정해서 사용 가능하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Layout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/layout</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">NestedLayout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/nested-layout</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Page</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="cm">/** Your content */</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">Page</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">getLayout</span><span class="p">(</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">NestedLayout</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">page</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/NestedLayout</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이렇게 선언 후 실제로 사용할 때는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Use the layout defined at the page level, if available</span>
  <span class="kd">const</span> <span class="nx">getLayout</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">||</span> <span class="p">((</span><span class="nx">page</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">page</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">getLayout</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<p>타입스크립트를 이용하면 Props의 type에 주의해야된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">}:</span> <span class="nx">AppPropsWithLayout</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Use the layout defined at the page level, if available</span>
  <span class="kd">const</span> <span class="nx">getLayout</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">??</span> <span class="p">((</span><span class="nx">page</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">page</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">getLayout</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="data-fetching">Data Fetching</h3>

<p>레이아웃안에, Client-Side에서 <code class="language-plaintext highlighter-rouge">useEffect</code>로 데이터를 가져올 수 도 있고, 라이브러리를 활용하여 <code class="language-plaintext highlighter-rouge">SWR</code>(React Query와 유사)로 가져올 수 도 있다. 하지만, Page가 아니기에, <code class="language-plaintext highlighter-rouge">getStaticProps</code>나 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>를 사용 할 수는 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">swr</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Navbar</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./navbar</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Footer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./footer</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Layout</span><span class="p">({</span> <span class="nx">children</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/navigation</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Failed</span> <span class="nx">to</span> <span class="nx">load</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">Navbar</span> <span class="nx">links</span><span class="o">=</span><span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">links</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">main</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/main</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Layouts]]></summary></entry><entry><title type="html">NEXT-Built-In CSS</title><link href="http://localhost:4000/next.js/2022/04/27/next-built-in-css.html" rel="alternate" type="text/html" title="NEXT-Built-In CSS" /><published>2022-04-27T00:00:00+09:00</published><updated>2022-04-27T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/27/next-built-in-css</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/27/next-built-in-css.html"><![CDATA[<h2 id="global-stylesheet">Global Stylesheet</h2>

<p>프로젝트에 <code class="language-plaintext highlighter-rouge">stylesheet</code>를 추가하려면, <code class="language-plaintext highlighter-rouge">pages/_app.js</code> 라는 CSS 파일을 import 해야된다.</p>

<p>우선 다음과 같이 <code class="language-plaintext highlighter-rouge">style.css</code>를 만들었다 보면</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">body</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="nb">sans-serif</span><span class="p">;</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">20px</span> <span class="m">20px</span> <span class="m">60px</span><span class="p">;</span>
  <span class="nl">max-width</span><span class="p">:</span> <span class="m">680px</span><span class="p">;</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span> <span class="nb">auto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 실제 page 에서 import 하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">'</span><span class="s1">../style.css</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span><span class="o">&gt;</span> <span class="sr">/</span><span class="err">&gt;
</span><span class="p">}</span>
</code></pre></div></div>

<p>그럼 스타일이 위에서 선언한 <code class="language-plaintext highlighter-rouge">style.css</code> 처럼 적용이 된다.</p>

<table>
  <tbody>
    <tr>
      <td>global한 문제가 있기에 오직 하나만 import 해야 된다! 여기서는 <code class="language-plaintext highlighter-rouge">pages/_app.js</code></td>
    </tr>
  </tbody>
</table>

<h2 id="import-styles-from-node_modules">Import styles from <code class="language-plaintext highlighter-rouge">node_modules</code></h2>

<p>Next.js 9.5.4 버전부터는 <code class="language-plaintext highlighter-rouge">node_modules</code>에 CSS 파일을 넣는것이 가능해졌다. 만약 <code class="language-plaintext highlighter-rouge">bootstrap</code>이나 <code class="language-plaintext highlighter-rouge">nprogress</code> 같은 global stylesheet를 사용한다면, <code class="language-plaintext highlighter-rouge">pages/_app.js</code> 에서 import를 미리 해두어야 한다.</p>

<p><code class="language-plaintext highlighter-rouge">Third Party</code> 컴포넌트를 사용한다면, 다음과 같이 정의 할 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>Third Party란 프로그래밍시 도와주는 플러그인 혹은 라이브러리를 만드는 회사</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// components/ExampleDialog.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Dialog</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reach/dialog</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">VisuallyHidden</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reach/visually-hidden</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">@reach/dialog/styles.css</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">ExampleDialog</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">showDialog</span><span class="p">,</span> <span class="nx">setShowDialog</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">open</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setShowDialog</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">close</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setShowDialog</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">open</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Open</span> <span class="nx">Dialog</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Dialog</span> <span class="nx">isOpen</span><span class="o">=</span><span class="p">{</span><span class="nx">showDialog</span><span class="p">}</span> <span class="nx">onDismiss</span><span class="o">=</span><span class="p">{</span><span class="nx">close</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">close-button</span><span class="dl">"</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">close</span><span class="p">}</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">VisuallyHidden</span><span class="o">&gt;</span><span class="nx">Close</span><span class="o">&lt;</span><span class="sr">/VisuallyHidden</span><span class="err">&gt;
</span>          <span class="o">&lt;</span><span class="nx">span</span> <span class="nx">aria</span><span class="o">-</span><span class="nx">hidden</span><span class="o">&gt;</span><span class="err">×</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">there</span><span class="p">.</span> <span class="nx">I</span> <span class="nx">am</span> <span class="nx">a</span> <span class="nx">dialog</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/Dialog</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="component-level-css">Component-Level CSS</h2>

<p>Next.js는 <code class="language-plaintext highlighter-rouge">[name].module.css</code> 이라는 파일 컨벤션을 이용하여 CSS Module을 공식적으로 지원한다. CSS 모듈은 자동으로 unique class 이름을 만들어 생성하며, 이는 충돌을 방지하기 위함이다. 즉 이런식으로 사용하면, component-level 에서 사용하기 더욱 쉬워진다. 그리고 이러한 CSS Module은 파일 어디에서 import 되어도 사용 가능해진다!</p>

<p>예를들어, 재사용 가능한 <code class="language-plaintext highlighter-rouge">Button</code> 이라는 컴포넌트가 <code class="language-plaintext highlighter-rouge">components/</code>안에 있다 가정하고 다음을 보자.</p>

<p>우선 <code class="language-plaintext highlighter-rouge">components/Button.module.css</code>를 만든다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.error</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>후, <code class="language-plaintext highlighter-rouge">components/Button.js</code>를 만들어, 방금 제작한 CSS를 import 하면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">styles</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Button.module.css</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">Button</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">button</span>
      <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">button</span><span class="dl">"</span>
      <span class="c1">// Note how the "error" class is accessed as a property on the imported</span>
      <span class="c1">// `styles` object.</span>
      <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">error</span><span class="p">}</span>
    <span class="o">&gt;</span>
      <span class="nx">Destroy</span>
    <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이러한 CSS Module을 사용하는것은 추가적인 기능이고, 편히 global CSS를 사용하여도 무방하다.</p>

<p>정적 build시에, 이러한 모든 CSS Module 들이 자동으로 분할되어지는데, 최종적으로 프로그램 딴에서 css 파일의 무게를 줄이기 위함이다.</p>

<h2 id="sass-support">Sass Support</h2>

<p>Next.js는 Sass도 물론 지원한다. <code class="language-plaintext highlighter-rouge">.scss</code> 와 <code class="language-plaintext highlighter-rouge">.sass</code> 둘 다 지원하며, 마찬가지로 모듈화를 하여 <code class="language-plaintext highlighter-rouge">.module.scss</code> 와 <code class="language-plaintext highlighter-rouge">.module.sass</code> 로 사용할 수 있다.</p>

<p>간단한 Sass의 예제로 보면 다음과 같다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* variables.module.scss */</span>
<span class="err">$</span><span class="nt">primary-color</span><span class="o">:</span> <span class="err">#64</span><span class="nt">FF00</span>

<span class="nd">:export</span> <span class="p">{</span>
  <span class="py">primarycolor</span><span class="p">:</span> <span class="err">$</span><span class="n">primary-color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/_app.js</span>
<span class="k">import</span> <span class="nx">variables</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../styles/variables.module.scss</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span> <span class="nx">color</span><span class="o">=</span><span class="p">{</span><span class="nx">variables</span><span class="p">.</span><span class="nx">primaryColor</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="css-in-js">CSS in JS</h2>

<p>내가 주로 사용하는 방식인 CSS-in-JS 방식이다.</p>

<p>우선 사용하려면 <code class="language-plaintext highlighter-rouge">styled-jsx</code> 파일을 번들해야하며, 목적은 <code class="language-plaintext highlighter-rouge">shadow CSS</code>를 지원하여 마치 웹 컴포넌트처럼 사용하기 위함이다. 아쉽게도 SSR를 지원하지 않고, JS만 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">styled jsx</code>의 예제는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">HelloWorld</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="nx">Hello</span> <span class="nx">world</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">scoped</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">style</span> <span class="nx">jsx</span><span class="o">&gt;</span><span class="p">{</span><span class="s2">`
        p {
          color: blue;
        }
        div {
          background: red;
        }
        @media (max-width: 600px) {
          div {
            background: blue;
          }
        }
      `</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">style</span> <span class="nb">global</span> <span class="nx">jsx</span><span class="o">&gt;</span><span class="p">{</span><span class="s2">`
        body {
          background: black;
        }
      `</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">HelloWorld</span><span class="p">;</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Global Stylesheet]]></summary></entry><entry><title type="html">NEXT-Pages</title><link href="http://localhost:4000/next.js/2022/04/25/next-pages.html" rel="alternate" type="text/html" title="NEXT-Pages" /><published>2022-04-25T00:00:00+09:00</published><updated>2022-04-25T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/25/next-pages</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/25/next-pages.html"><![CDATA[<p>아래는 Next.js 공식문서의 번역본입니다</p>

<p><a href="https://nextjs.org/docs/basic-features/pages">공식문서</a></p>

<h2 id="pages">Pages</h2>

<p>Next.js 의 <code class="language-plaintext highlighter-rouge">Page</code> 는 <code class="language-plaintext highlighter-rouge">React Component</code> 로써, <code class="language-plaintext highlighter-rouge">.js</code>, <code class="language-plaintext highlighter-rouge">.jsx</code>, <code class="language-plaintext highlighter-rouge">.ts</code>, <code class="language-plaintext highlighter-rouge">.tsx</code> 의 형태로 존재한다.</p>

<h3 id="pre-rendering">Pre-rendering</h3>

<p>Next.js 는 매 페이지마다 <code class="language-plaintext highlighter-rouge">pre-render</code>를 지원한다. 즉 Next는 Client가 자바스크립트로 처리하는것이 아니라 매 페이지마다 HTML 을 만들어낸다. 즉 여기서 성능과 <a href="2022-04-24-why-next-js.md">SEO</a> 측면에서 더 좋다. 이렇게 만들어진 HTML은 정말 페이지에 필요한 자바스크립트 코드만 들어가 있으며, 브라우저에서 로딩이 되면, 해당 자바스크립트 코드로 상호작용을 할 수 있다. -&gt; <code class="language-plaintext highlighter-rouge">hydration</code></p>

<p>Pre-rendering 에는 두가지 방법이 존재하는데, <code class="language-plaintext highlighter-rouge">Static Generation</code> 과 <code class="language-plaintext highlighter-rouge">Server-side Rendering</code>이 있다. <a href="2022-04-24-why-next-js.md">SSR</a>같은 경우에는, 저번 포스트에서 설명을 하였으므로 넘어가고, 이번에는 Next에서 공식적으로 추천하는 Static Generation 방법에 대해서 알아보자.</p>

<h3 id="ssg">SSG</h3>

<p>어떠한 페이지가 <code class="language-plaintext highlighter-rouge">Static Generation</code> 이라면, 해당 페이지의 HTML은 빌드시간에 생성된다고 할 수 있다. 즉 <code class="language-plaintext highlighter-rouge">next build</code> 명령어의 실행과 동시에 페이지의 HTML이 만들어진다고 ㅂ로 수 있다. 그리고 이러한 HTML은 CDN(Contents Delivery Network)을 통하여 캐시 될 수 있다.</p>

<p>Next.js 는 기본적으로 데이터 fetching을 제외한 <code class="language-plaintext highlighter-rouge">Static Generation</code>으로 작동한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">About</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">About</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">About</span><span class="p">;</span>
</code></pre></div></div>

<p>아래와 같은 함수는 fetch 할 data가 없으니 바로 HTML로 변환되어 정적으로 하나의 HTML이 나올 것이다!</p>

<p>그럼 Data가 있는 경우를 살펴보자</p>

<p>Data가 있는 경우에 두가지로 쪼갤 수 있다. 1. page의 content가 외부 데이터에 의존할 때 (<code class="language-plaintext highlighter-rouge">getStaticProps</code>) 2. page의 path가 외부 데이터에 의존할 때 (<code class="language-plaintext highlighter-rouge">getStaticPaths</code>)</p>

<h4 id="1-content가-의존성일-때">1. content가 의존성일 때</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Blog</span><span class="p">({</span> <span class="nx">posts</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Blog</span><span class="p">;</span>
</code></pre></div></div>

<p>이러한 형태의 함수를 보낼시에, Next.js 는 async 를 export 하게 도와준다. <code class="language-plaintext highlighter-rouge">getStaticProps</code> 란 함수를 불러 사용이 가능하며, <code class="language-plaintext highlighter-rouge">pre-render</code> 과정에서, data를 fetch하게 도와준다. 그럼 수정본 코드를 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Blog</span><span class="p">({</span> <span class="nx">posts</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">posts</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Blog</span><span class="p">;</span>
</code></pre></div></div>

<p>언제 <code class="language-plaintext highlighter-rouge">getStaticProps</code>를 사용할까?</p>

<ol>
  <li>
    <p>data가 user의 request전에 rendering에 필요로 할 때!</p>
  </li>
  <li>
    <p>data가 headless CMS에서 올 때</p>
  </li>
  <li>
    <p>data가 외부적으로 캐시가 가능할 때</p>
  </li>
  <li>
    <p>페이지가 빨리 pre-render 되어아 할 때</p>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">getStaticProps</code> 가 오직 Server-Side 에서 작동하기에, Client 딴에서는 절대 실행이 되어서는 안된다. 심지어 브라우저에서는, JS bundle에 포함도 안되어 있다. 즉 API route에서 가져온다기보다, Server딴에서 코드를 바로 넣어 줄 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">getStaticProps</code>는 페이지에서만 만들어져야된다! 즉 component딴에서는 호출되면 안됨!</p>

<h4 id="2-path가-의존성일-때">2. path가 의존성일 때</h4>

<p>앞서 말했다시피 Next.js는 <code class="language-plaintext highlighter-rouge">dynamic routes</code>를 허용한다. 예를들어 file route가 <code class="language-plaintext highlighter-rouge">pages/posts/[id].js</code> 라면, <code class="language-plaintext highlighter-rouge">posts/1</code> 에 접속 시 <code class="language-plaintext highlighter-rouge">id: 1</code> 로 접근이 가능할것이다.</p>

<p>이러한 접근을 하려면 <code class="language-plaintext highlighter-rouge">async</code> 를 <code class="language-plaintext highlighter-rouge">export</code> 하는 함수 즉 <code class="language-plaintext highlighter-rouge">getStaticPaths</code>를 사용하여 가능하다.</p>

<p>path의 pre-render과정을 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Post</span><span class="p">({</span> <span class="nx">post</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Render post...</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticPaths</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Call an external API endpoint to get posts</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="c1">// Get the paths we want to pre-render based on posts</span>
  <span class="kd">const</span> <span class="nx">paths</span> <span class="o">=</span> <span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">params</span><span class="p">:</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">post</span><span class="p">.</span><span class="nx">id</span> <span class="p">},</span>
  <span class="p">}));</span>

  <span class="c1">// 빌드 할 시에만 path 로 pre-render</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">paths</span><span class="p">,</span> <span class="na">fallback</span><span class="p">:</span> <span class="kc">false</span> <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// 이것도 빌드시에 사용</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">({</span> <span class="nx">params</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// 다이나믹하게 작동한다</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`https://.../posts/</span><span class="p">${</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">post</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="c1">// Pass post data to the page via props</span>
  <span class="k">return</span> <span class="p">{</span> <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="nx">post</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Post</span><span class="p">;</span>
</code></pre></div></div>

<p>언제 <code class="language-plaintext highlighter-rouge">getStaticPaths</code>를 사용할까?</p>

<p>보통 dynamic route를 통하여 정적으로 페이지를 pre-render 하며</p>

<ol>
  <li>
    <p>headless CMS에서 데이터가 올 때(모니터가 연결되어있지 않거나, 키보드나 마우스 등의 주변장치가 연결되어있지 않은 서버)</p>
  </li>
  <li>
    <p>DB 에서 데이터가 올 때</p>
  </li>
  <li>
    <p>FIlesystem 에서 데이터가 올 때</p>
  </li>
  <li>
    <p>데이터가 외부로 캐시가능할 때</p>
  </li>
  <li>
    <p>페이지가 매우 빠르게 pre-render 되어야 할 때</p>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">getStaticProps</code>는 <code class="language-plaintext highlighter-rouge">HTML</code> 과 <code class="language-plaintext highlighter-rouge">JSON</code> 파일을 만들어, CDN으로 캐시 될 수 있다</li>
    </ol>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">getStaticPaths</code>는 오직 빌드 과정에서만 돌며, 런타임 환경에서는 작동하지 않는다. 오직, <code class="language-plaintext highlighter-rouge">getStaticProps</code>를 쓰는 다이나믹 루트를 통해서만 export 될 수 있으며, non-page file에서 export 할 수 없다! (ex. components)</p>

<h3 id="ssr">SSR</h3>

<p>SSR이란, 매 HTML 페이지가 매번 요청시에 Server 측에서 만들어 준다는 것이다. 즉 Server에 가는 부담이 커질 수 밖에 없다.</p>

<p>이건 <code class="language-plaintext highlighter-rouge">export</code> 와 <code class="language-plaintext highlighter-rouge">async</code> 를 활용한 <code class="language-plaintext highlighter-rouge">getServerSideProps</code> 란 함수를 사용하여 구현할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Page</span><span class="p">({</span> <span class="nx">data</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Render data...</span>
<span class="p">}</span>

<span class="c1">// 매번 불러온다</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getServerSideProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Fetch data from external API</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">`https://.../data`</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="c1">// props 로 data 불러오기</span>
  <span class="k">return</span> <span class="p">{</span> <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="nx">data</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Page</span><span class="p">;</span>
</code></pre></div></div>

<p>자세히 보면, <code class="language-plaintext highlighter-rouge">getStaticProps</code> 와 매우 유사해 보이지만, 차이점은 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>는 build 시에 처음만 하는것이 아닌 매번 요청마다 작동한다는 점이다!</p>

<p>즉 <code class="language-plaintext highlighter-rouge">getServerSidePRops</code>는, 오직 Server-Side 에서만 굴러가고, 브라우저딴에서는 실행하지 않는다. 순서를 보면 다음과 같다.</p>

<ol>
  <li>
    <p>어떠한 페이지를 request 한다</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">getServerSideProps</code> 가 요청시에 실행된다</p>
  </li>
  <li>
    <p>해당 props와 같이 페이지가 pre-render 된다.</p>
  </li>
  <li>
    <p>링크를 통하여, 해당 페이지를 Client-Side에 요청시에 Next.js가 Server에 API 요청을 보내 <code class="language-plaintext highlighter-rouge">getServerSidePRops</code>를 실행한다.</p>
  </li>
</ol>

<p>그럼 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>는 페이지 렌더링에 필요한 JSON을 리턴하고, 이러한 부분들은 Next.js 에서 자동을 해준다!</p>

<p>중요한 부분은 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>를 독립적인 함수로 빼서 export 해야된다. 만약 page component 안에 넣어두면 제대로 작동하지 앟는다.</p>

<p>그럼 언제 사용할까? 한 페이지를 data가 fetch되는 request time 에 렌더링을 할 때 사용한다. 만약, request 시간에 렌더링을 할 필요가 없다면 Client Side 나 <code class="language-plaintext highlighter-rouge">getStaticProps</code>를 사용하는게 더 효율적이다.</p>

<h3 id="incremental-static-regeneration">Incremental Static Regeneration</h3>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 사이트의 빌드 후 static page를 만들거나 업데이트를 허용해준다. 사용되는 기능이 ISR(Incremental Static Regeneration)이며, 전체 사이트를 다시 build 하지 않아도, static-generation을 허용해준다.</p>

<p>사용하기 위해서는 다음과 같이 <code class="language-plaintext highlighter-rouge">getStaticProps</code>에 <code class="language-plaintext highlighter-rouge">revalidate</code>를 사용해야 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Blog</span><span class="p">({</span> <span class="nx">posts</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">post</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>      <span class="p">))}</span>
    <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//serverside 에서 빌드되는 함수</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">pros</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">posts</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="c1">// ! 10초에 한번씩 OR request 가 들어오면 page를 re-generate 하려한다</span>
    <span class="na">revalidate</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">//마찬가지로 server-side 에서 build시 실행</span>
  <span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticPaths</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://.../posts</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">posts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>

    <span class="kd">const</span> <span class="nx">paths</span> <span class="o">=</span> <span class="nx">posts</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="na">params</span><span class="p">:</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">post</span><span class="p">.</span><span class="nx">id</span> <span class="p">},</span>
    <span class="p">}));</span>

    <span class="c1">//build 시에 이것만! pre-render 한다!</span>
    <span class="c1">// {fallback: blocking} 은 server-render</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">paths</span><span class="p">,</span> <span class="na">fallback</span><span class="p">:</span> <span class="dl">"</span><span class="s2">blocking</span><span class="dl">"</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">export</span> <span class="k">default</span> <span class="nx">Blog</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 코드를 해석해보면, request 요청이 와서 build 시간에 page가 만들어진다면, cache 된 page를 보여준다.</p>

<ol>
  <li>
    <p>첫 요청 후 10초안의 다른 요청들은 cache에 저장된다</p>
  </li>
  <li>
    <p>10초 후, 다음 요청은 아직도 cache된 정보를 보여준다 -&gt; stale (바꼈을 수 도 있음!)</p>
  </li>
  <li>
    <p>Next.js가 페이지에 regeneration을 건다</p>
  </li>
  <li>
    <p>page가 정상적으로 만들어졌다면, Next.js가 캐시를 사용하지 못하게 막은 후, 업데이트된 페이지를 보여준다!</p>
  </li>
</ol>

<table>
  <tbody>
    <tr>
      <td>만약 4번에서 실패했다면, 예전 페이지가 바뀌지 않았을 것이다</td>
    </tr>
  </tbody>
</table>

<h3 id="on-demand-revalidation">On-demand Revalidation</h3>

<p>만약 <code class="language-plaintext highlighter-rouge">revalidate</code> 시간을 60으로 잡는다면, 모든 방문자들은 1분동안 모두 같은 버전을 볼것이다. 여기서 유일하게 캐시를 비활성화 하는 방법은 다른 사람이 1분후에 접속을 하는것이다.</p>

<p>Next.js 의 <code class="language-plaintext highlighter-rouge">12.1.0</code> 버전 이후, on-demand Incremental Static Regenration을 지원하며, 사이트의 업데이트를 더 손쉽게 사용할 수 있게 해준다.</p>

<ol>
  <li>
    <p>headless CMS의 정보가 만들어지거나 업데이트됨</p>
  </li>
  <li>
    <p>Metadata 변화를 알아챔</p>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">getStaticProps</code>안에, <code class="language-plaintext highlighter-rouge">revalidate</code>를 명시해주지 않아도, 된다. 만약 빠졌다면, Next.js가 자동으로 FALSE로 주고, <code class="language-plaintext highlighter-rouge">unstable-revalidate</code>요청시에만 업데이트를 진행한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">secret</span> <span class="o">!==</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">MY_SECRET_TOKE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">401</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">message</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Invalid token</span><span class="dl">"</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">unstable_revalidate</span><span class="p">(</span><span class="dl">"</span><span class="s2">path-to-revalidate</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="na">revalidated</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">500</span><span class="p">).</span><span class="nx">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error revalidating</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="client-side-data-fetching-with-useeffect">Client-side data fetching with useEffect</h3>

<p>React 에서는 data fetching 을 하기 위해 SWR을 지원한다. 우선 SWR에 대해서 알아보자.</p>

<h4 id="swr">SWR</h4>

<p>SWR은 stale-while-revalidate의 약자로, 먼저 캐시(Stale한 상태)에서 데이터를 받고, fetch 요청 후 최종적으로 최신 데이터를 가져오는 전략이다.</p>

<p>간단한 코드를 보면 다음과 같다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">swr</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Profile</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/user</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">failed</span> <span class="nx">to</span> <span class="nx">load</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">hello</span> <span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">!&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<p>위의 코드를 보면, <code class="language-plaintext highlighter-rouge">useSWR</code>은 <code class="language-plaintext highlighter-rouge">key</code> 와 <code class="language-plaintext highlighter-rouge">fetcher</code>를 받아, 고유한 식별자가 <code class="language-plaintext highlighter-rouge">fetcher</code>로 전달되는 것이다. 주된 장점들은 다음과 같다.</p>

<ul>
  <li>빠르고, 가볍고, 재사용 가능한 데이터 가져오기</li>
  <li>내장된 캐시 혹은 요청의 중복을 제거</li>
  <li>실시간으로 이루어진다</li>
  <li>전송 및 프로토콜에 상관없음</li>
  <li>SSR/ ISR/ SSG 모두 사용 가능</li>
  <li>TypeScript에 적용된다</li>
</ul>

<p>그럼 이러한 SWR을 이용하여 profile data를 더 손쉽게 가져 올 수 있다. 그럼 SWR의 캐시로 데이터를 활용하는 코드를 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">swr</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">fetcher</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">fetch</span><span class="p">(...</span><span class="nx">args</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>

<span class="nx">functoin</span> <span class="nx">Profile</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/profile-data</span><span class="dl">'</span><span class="p">,</span> <span class="nx">fecther</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Failed</span> <span class="nx">to</span> <span class="nx">load</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">bio</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[아래는 Next.js 공식문서의 번역본입니다]]></summary></entry><entry><title type="html">NEXT</title><link href="http://localhost:4000/next.js/2022/04/24/why-next-js.html" rel="alternate" type="text/html" title="NEXT" /><published>2022-04-24T00:00:00+09:00</published><updated>2022-04-24T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/24/why-next-js</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/24/why-next-js.html"><![CDATA[<h2 id="next-란-무엇인가">NEXT 란 무엇인가?</h2>

<p><code class="language-plaintext highlighter-rouge">Next</code>란 간단하게 말하면, SSR을 쉽게 구현하도록 도와주는 프레임워크이다. SSR 이란 Server Side Rendering의 약자로, 쉽게 말하면, Server 딴에서 렌더링 과정을 해준다는 것이다. 그와 반대대는 개념으로는 CSR 즉 Client Side Rendering 이 존재한다.</p>

<h3 id="ssr-vs-csr">SSR vs CSR</h3>

<p>React 로 렌더링방식의 차이를 알아보자면, 우선 일반적으로는 <code class="language-plaintext highlighter-rouge">render()</code> 라는 함수가 실행 된 후 <code class="language-plaintext highlighter-rouge">componentDidMount()</code> 함수를 실행하여 다시 한번 더 렌더링이 된다. 그에 반에, Next 같은 경우에는 getInitialProps() 라는 함수를 먼저 호출하여 데이터를 렌더링을 우선으로 해준다. 이러한 CSR 은 SPA 의 구동방식이라고도 말한다. SPA는 Single Page 를 서버측에 제공하고, View 에서는 Client 딴에서 라이브러리 혹은 프레임워크를 사용하여 렌더링하는 방식이다. SSR의 장점으로는 초기로딩 속도가 빠르지만, 단점으로는 page 이동시에는 CSR 보다 느리다.</p>

<table>
  <tbody>
    <tr>
      <td>page 요청마다 중복되는 파일을 내려받아야 되기 때문!</td>
    </tr>
  </tbody>
</table>

<p>하지만 CSR 같은 경우, 초기로딩 속도가 느린것에 비해 첫 로딩에 모든 파일을 내려받아, 이동시에 필요한 데이터만 불러 사용하여 더 빠르다고 할 수 있다!</p>

<h3 id="next-의-작동-원리">Next 의 작동 원리</h3>

<p>하지만 React 는 SPA 적인 페이지를 구현하기 위한 라이브러리이다. 그럼 전통적으로 CSR 인데, 어떻게 Next는 React기반을 SSR로 구현할 수 있을까?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 사용자가 Server에 페이지 접속 요청시 SSR 방식으로 렌더링 된 HTML 을 전송
2. 브라우저에서 JavaScript 다운로드 후 React 실행
3. 사용자와 페이지가 상호작용 후 이동시에는 Client딴에서 처리
</code></pre></div></div>

<h2 id="why-next">Why Next?</h2>

<h3 id="search-engine-optimization">Search Engine Optimization</h3>

<p><code class="language-plaintext highlighter-rouge">Next</code>를 사용하면 <code class="language-plaintext highlighter-rouge">SEO</code> 혹은 <code class="language-plaintext highlighter-rouge">검색 엔진 최적화</code>가 가능하다! 사실 SSR을 이용하는 이유또한 SEO를 하기 위함이라고도 볼 수 있다.</p>

<p>SEO를 함으로써, 브라우저에 노출이 잘 되므로 마케팅 혹은 서비스적인 면에서 무조건 고려해봐야 되는 사항이라 볼 수 있다. 그럼 왜 CSR은 SEO 에서 불리할까? 그건 Search Engine 의 작동원리로 설명 할 수 있다.</p>

<h3 id="검색-엔진-작동원리">검색 엔진 작동원리</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 검색엔진이 데이터 크롤링 시 JavaScript 파일을 해석 할 수 없어 HTML 파일에서 크롤링한다
2. CSR 인 경우에는 Client가 받기전에, HTML에는 빈 문서이므로, 데이터를 받아 올 수 없다
3. SSR 같은 경우, 이미 HTML에 데이터가 포함이 되어있어, 데이터 수집에 용이하다!
</code></pre></div></div>

<p>즉 초기에 SSR을 함으로써, SEO에 용이하며 브라우저에서 JavaScript를 다운 후 React를 실행하여 다른 페이지로 이동시 CSR방식으로 작동하여 브라우저에서 처리할 때 SPA의 장점 또한 유지 할 수 있다!!</p>

<h3 id="code-splitting">Code Splitting</h3>

<p><code class="language-plaintext highlighter-rouge">Code Splitting</code> 또한 Next.js 를 사용하는 주된 이유이다. 그럼 코드 분할이 무엇일까? 우선 기본적인 프로젝트로 생각을 해보자. JavaScript 프로젝트를 생성하면 React 같은 경우 모든 코드를 하나의 Bundle로 받고 실행한다. 규모가 작은 프로젝트라면 문제가 없지만, 만약 프로젝트의 규모가 커질수록, 브라우저가 파싱해야되는 정보가 많아지므로 CPU의 처리속도가 느리거나 메모리가 낮은 기기일 경우 초기 구동속도가 느려질 수 밖에 없다.</p>

<p>이러한 번들링 작업을 Bundle을 동적으로 생성해주는 코드 분할을 제공하면 해결 할 수 있다. 코드 분할을 사용함으로써 Lazy Loading을 해결 할 수 있고, 필요하지 않은 코드들을 로딩하지 않아, 초기 로딩에 필요한 자원또한 줄여 줄 수 있다.</p>

<h3 id="hot-module-replacement">Hot Module Replacement</h3>

<p>HMR 이란 브라우저를 새로고침하지 않고 Webpack으로 빌드한 결과물을 실시간으로 반영시켜주는 설정이다. 즉 새로고침하지 않아도, Module을 Runtime중에 업데이트 시켜준다는 것이다.</p>

<p>즉 Webpack의 엄청나게 느린 build 과정을 더 줄여 줄 수 있다. 하지만 Vite를 쓴다면 그냥 해결이 되지 않을까…?</p>

<p><a href="https://ivorycode.tistory.com/entry/Nextjs를-사용하는-이유">참고링크1</a></p>

<p><a href="https://medium.com/@msj9121/next-js-제대로-알고-쓰자-8727f76614c9">참고링크2</a></p>

<p><a href="https://dtaxi.tistory.com/1090">참고링크2</a></p>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[NEXT 란 무엇인가?]]></summary></entry><entry><title type="html">함께 자라기</title><link href="http://localhost:4000/deep-thought/2022/04/22/grow-together.html" rel="alternate" type="text/html" title="함께 자라기" /><published>2022-04-22T00:00:00+09:00</published><updated>2022-04-22T00:00:00+09:00</updated><id>http://localhost:4000/deep-thought/2022/04/22/grow-together</id><content type="html" xml:base="http://localhost:4000/deep-thought/2022/04/22/grow-together.html"><![CDATA[<h2 id="함께-자라기">함께 자라기</h2>

<h3 id="서론">서론</h3>

<p>우선 이전글에서 다뤘던 SW Maestro <code class="language-plaintext highlighter-rouge">소마</code> 라고 하는 정부지원사업에 붙게 되었다. 320명이나 되는 연수생들을 대충 확인해보았는데, 정말 다양한 사람들이 정말 많다는것을 느꼈다. 그리고 대부분이 전공생이 였다는게 정말 놀라웠다. 현재 진행중인 42 Seoul 인 경우에는 전공생보다는 부전공 혹은 아예 다른 전공에서 다른 일을 하다 프로그래머의 길로 빠지게 된 경우도 많이 보았는데 참 색달랐다.</p>

<p>그 후 멘토링을 몇번 받게 되었고, 운 좋게 마음에 드는 두분을 만나 팀 매칭까지 끝나게 되었다. 우리는 AI, 나 어플의 CRUD 시스템같은것 보다는 조금 더 혁신적이고, 재미있는 프로젝트를 하기로 했다. 아직 정확한 기획은 없지만 아마 메타버스 혹은 그 상위의 무엇인가가 될것 같다. 조합은 웹의 정석이라 불리는 2FE 1BE 로 진행이 될 것 같다.</p>

<p>그리고 우리의 목적은 사업적으로 엄청나게 뛰어난 창업을 하겠다! 혹은 이 세계에 도움이 되는 무언가를 만들어 내겠다! 이런것은 아니다. 좀 더 우리의 가치와 실력을 높일 수 있는 기회가 되었으면 좋겠다! 에 가깝다. 그래서 우리는 최대한 다양한 기술들을 배우고 협력하는 과정을 느껴보자! 가 주제가 되었다.</p>

<p>그렇게 우리의 목적에 맞춰 우선 정한것은</p>

<ol>
  <li>Jira 를 사용해보자</li>
  <li>애자일 방법론을 채용하자</li>
</ol>

<p>였다.</p>

<p>Jira 같은 경우에는, 차차 더 알아보며 Git Confluence 와 연동해서 사용 해 볼 예정이고 애자일 방법론에 대해서는 스프린트와 스크럼 정도밖에 몰랐던 나였기에 조금 더 공부를 해보고자 하였다.</p>

<p>그렇게 애자일이 무엇인가! 항상 근본적인것을 좋아하는 나는 애자일의 뜻부터 알아보았다.</p>

<blockquote>
  <p>애자일은 민첩성을 뜻하며 소포트웨어 기업들이 도입한 개념으로 급변하는 시장에서 기민한 대응을 하기 위해 빠르고 유연한 기업 환경(조직)을 만드는 것을 목적으로 한다.</p>
</blockquote>

<p>항상 말은 참 쉽지만, 실제로 이해하기는 정말 까다롭다. 그러던 중 팀원 중 한명이 <code class="language-plaintext highlighter-rouge">함께 자라기</code> 라는 좋은 애자일 방법론에 대한 책이 있다하여 읽어 보기로 하였다.</p>

<h3 id="자라기">자라기</h3>

<p>이 책을 읽다보면 정말 단순하지만 머리를 띵! 하게 만드는 부분들이 꽤나 있다. 우선 자라기에 대한 부분이 내 입장에서 제일 생각을 많이하게 만들었다.</p>

<h4 id="가치">가치</h4>

<p>다들 <code class="language-plaintext highlighter-rouge">1만시간의 법칙</code> 을 많이들 들어보았을 것이다. 정말 단순하게 어떠한 분야의 전문가가 되려면 <code class="language-plaintext highlighter-rouge">1만시간</code> 정도가 필요하다는 뜻이다. 하지만 이 말에는 큰 함정이 빠져있다. 이 <code class="language-plaintext highlighter-rouge">1만시간</code> 에는 단순히 내가 즐기거나, 어쩔 수 없이 하는것이 아니라 피드백을 받고 공부하거나 노력하는 과정이 포함되어야 된다는 것이다. 게임을 보더라도 내가 낮은 티어에서 게임을 몇천판을 하였지만, 아직도 낮은 티어일 수 있다. 책에서는 그 이유를 피드백 혹은 노력을 하지 않는것이라고 본다. 매 판마다 분석을 하고 취약점에 대하여 고치려는 노력을 한다면, 약점에 대해서는 반복적인 훈련을 한다면, 과연 실력이 낮은채로 가만히 있을까? 당연히 실력이 개선되는 미래가 펼쳐질 것이다.</p>

<h4 id="피드백">피드백</h4>

<p>자라기에 또 매우 중요한 부분이 있다. 바로 피드백이 빨라야 된다는 것이다. 만약 우리가 어떠한 액션을 취하였을 때, 그에대한 결과가 1년후에 온다면 어떨까? 아마 1년전에 어떤 액션을 취했는지 기억도 잘 나지않아, 피드백이 제대로 이루어지지 않을것이다. 액션 직후 피드백을 바로 받고 그것을 기록 후 다음에 볼때 진정한 피드백이 완성된다고 본다. 그리고 이것은 <code class="language-plaintext highlighter-rouge">1만시간의 법칙</code> 에도 포함이 된다. 빠르고 진정성있는 피드백이 나를 발전시키는 중요한 포인트라 할 수 있다.</p>

<h4 id="실수">실수</h4>

<p>이 책은 이상하리만치 실수에 관대하다. 오히려 실수를 권장하는 모습까지 보여준다. 이건 나의 입장에서는 정말 특이한 접근이였다. 프로그래밍을 하다보면 실수를 줄여가는 것이 전문가의 덕목이라고 생각했고, 실제로 내가 처음 프로그래밍을 하던것과 비교를 해보면 실수가 정말 상당히 줄었다. 하지만 여기서 말하는 실수는 실제로 컴파일 과정을 하고 서버 배포를 해보니 앗! 에러가 있네! 이런것이 아니다. 프로그래밍을 하다 작은 오타 혹은 변수 하나 잘못 넣은것도 실수라고 본다. 그리고 이러한 소소한 실수는 얼마든지 해도 되지만 이러한 실수를 한 후 어떤식으로 대처를 하는것인가에 대해 집중한다.</p>

<p>책에서는 실수에 대한 문화를 두가지로 나누는데 <code class="language-plaintext highlighter-rouge">실수 예방</code> 과 <code class="language-plaintext highlighter-rouge">실수 관리</code> 이다. 첫번째인 <code class="language-plaintext highlighter-rouge">실수 예방</code> 을 중점으로 두는 회사같은 경우, 실수를 하는 경로를 방지하며, 실수에 대하여 비난 및 처벌이 주가 되는 반면, <code class="language-plaintext highlighter-rouge">실수 관리</code> 를 중점으로 두는 회사는, 실수를 빨리 발견 및 해결 그리고 피드백 후 다음에는 어떤식으로 대처를 하자가 주가 된다.</p>

<h3 id="함께">함께</h3>

<h4 id="and-or">AND OR</h4>

<p>여기서 AND OR 연산자로 사람을 설명한다. 정말 공대스럽지 않을 수 없다. 하지만 또 정말 이것만큼 공대생들을 이해시켜주기 편한게 없다고 생각한다. 사람이 무엇인가를 배우거나 협력을 할 떄 AND 인지 OR 인지에 대하여 진지하게 설명한다.</p>

<p>우선 우리는 AND 보다 OR 적인 사람이 되어야 된다 설명한다. 분석을 하였을 떄, AND 성향이 있는 사람은 독립 개체로 본다. 통계적으로 보면 독립사건이 되는것이다. 예를 들어, 프로그래머가 작업을 마감일에 맞춰 끝낼 확률이 0.9라 보자. 그럼 프로그래머가 5명이 모두 마감일에 맞출 확률은 0.9일까? 이건 0.9 ^ 5 의 확률이 될 것이고, 이건 0.6 밖에 되지 않는다. 즉 통계의 오류가 발생한 것이다. 하지만 팀을 꾸려 5명이서 한 작업을 같이 끝내고, 다음으로 넘어가는 식으로 한다면? 그건 OR 연산으로 오히려 한 프로젝트당 잘 끝낼 확률이 0.9보다 높아지며 효율또한 증가할것이라는 분석이다. 물론 실제로는, BE FE 등 따로 작업을 하겠지만, 그럼에도 불구하고 정말 좋은 접근이라 생각한다.</p>

<p><code class="language-plaintext highlighter-rouge">당국자미 방관자청 (當局者迷 傍觀者淸)</code> 바둑을 구경하는 이가 더 수를 잘 본다 라는 뜻이다. 이건 단순히 바둑이 아닌 프로그래밍에도 통용이 된다 생각한다. 내가 페어프로그래밍을 할 때, 실제로 타이핑을 하는 사람은 타이핑하느라 정신이 없고, 설계한 대로 구현하고 있을때, 옆에서 보조하는 사람은, 코드를 보며 오류를 손쉽게 찾을 수 있으며, 설계에서 더 흐름을 보기 쉽다고 생각을 한다. 이러한 점에서 OR 적이며 앞에서 말한 실수의 관리에도 더욱 효율이 좋을것이다.</p>

<h3 id="애자일">애자일?</h3>

<p>사실 책은 애자일 방법론에 대하여 그렇게 중점적으로 설명해주지 않는다. 오히려 애자일이 디테일해질수록 애자일에 멀어진다고 설명한다. 애자일은 애초에 민첩하게 급변하는 시장에 맞춰 발전하는 형태이기에, 정적일수록 근본적으로 맞지않다고 판단하는 것이다.</p>

<p>그럼에도, 나는 조금 더 스크럼을 하는법 혹은 스프린트를 뛰는법에 대하여 알려줬으면 좋겠다고 생각을 했지만, 그런부분은 조금 아쉬웠다. 그럼에도, 애자일을 왜 사용해야 되는지는 정말 깔끔하게 설명을 해준 것 같다. 앞에서 언급한 가치, 피드백, 실수 등 애자일 방법론을 채택하면 모두 극복이 가능한 시나리오 이다. 매일매일 스크럼과 일주일 단위의 회고로 인하여 완벽한 피드백 시스템을 구축 할 수 있으며, 이러한 과정에서 가치를 높일 수 있다 생각한다.</p>]]></content><author><name>071yoon</name></author><category term="deep-thought" /><category term="deep-thought" /><category term="book" /><summary type="html"><![CDATA[함께 자라기]]></summary></entry><entry><title type="html">SW Maestro 지원 후기</title><link href="http://localhost:4000/retrospect/2022/03/03/sw-maestro.html" rel="alternate" type="text/html" title="SW Maestro 지원 후기" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/retrospect/2022/03/03/sw-maestro</id><content type="html" xml:base="http://localhost:4000/retrospect/2022/03/03/sw-maestro.html"><![CDATA[<h2 id="intro">Intro</h2>

<p>오늘 심층면접을 끝으로 길고 길었던 소프트웨어 마에스트로의 지원이 끝났다.</p>

<p>1월애 자소서를 쓰는것부터 시작해서 무려 두달이나 걸려서 오늘 최종 면접까지 가게 되었다. 끝나고 나니 아쉬운 부분도 있지만, 우선 정말 후련하고 후회는 없다.</p>

<h2 id="1-자소서-예의는-있지">1. 자소서 [예의는 있지?]</h2>

<p>자소서를 쓰는 단계였다. 하지만 인터넷 어디를 찾아봐도 자소서에서 떨어졌다는 이야기는 없다. 하지만 자소서는 면접질문에서 부메랑처럼 날아 올 수 있기에 최대한 사실대로 솔직하게 나의 정보를 어필하는것이 좋다고 판단했다. 그래서 꾸밈없이 정말 내가 개발하고 싶은 정보나 나의 철학을 정말 아낌없이 표현했다. 그리고 당연히 합격했다…</p>

<blockquote>
  <p>하지만 자소서의 내용은 평생 쓸 일이 없었는데… 읍읍..</p>
</blockquote>

<h2 id="2-1차-코딩테스트-너-코딩할-줄-아니">2. 1차 코딩테스트 [너 코딩할 줄 아니?]</h2>

<p>1차 코딩테스트는 사실 별거 없었다. 시간만 충분했다면 웹까지 8문제 전부 어렵지 않게 풀 수 있을 수준이였다. 물론 시간이 문제여서 알고리즘 6번째 문제는 풀지 못했지만, 그래도 나쁘지 않게 보았고, 끝나자 마자 “아..! 붙겠다..!” 라는 생각을 했다.</p>

<p>결과는 당연히 붙었다. 사실 byukim 님이랑 [42서울에서 만난 같이 소마를 지원하신 저의 영혼의 파트너] 한달넘게 코딩테스트를 준비했기에, 1차에서 떨어질 걱정은 하지 않았다. 다행히 byukim님 또한 잘 붙어서 2차까지 가게 되었다.</p>

<p>자세한 코딩테스트의 문제들은 보안상의 이유로 공개 할 수 없지만, 정말 백준 실버1 급의 문제들이 대거 나왔기 때문에, 평소에 알고리즘을 1회독이라도 했다면, 어렵지 않게 합격 할 수준이다.</p>

<h2 id="3-2차-코딩테스트-응-안풀면-그만이야">3. 2차 코딩테스트 [응~ 안풀면 그만이야~]</h2>

<p>42서울에서 느꼈지만, 나는 카더라 통신에 정말 약하다. 이번 역시 카더라 통신을 신뢰했지만 결과는 처참했다. 분명히, 2차에서는 1차 코테에 문제에서 업그레이드된 문제가 나온다고해서, 이분탐색과 다익스트라를 정말 달달 외우고 갔지만 한문제도 나오지 않았다… 그리고 정말 뜬금없이 유니온 파인드와 미친난이도의 구현문제가 나왔다.</p>

<blockquote>
  <p>백준 다이아분도 구현문제는 어려워서 못푸셨다고 한다</p>
</blockquote>

<p>구현문제같은 경우는 끝나고 찾아보니, 백준 테트리미노와 비슷했지만 DP를 활용해서 푸는 문제였다. 푼 사람말로는 무슨 4차원 DP(..?) 썼다고 들었는데 이걸 두시간안에 풀 수 있을 사람이 있을까..? 싶었다. 구현문제를 제외하고는 난이도는 평이했다. 하지만 SQL에서 실수하기 정말 쉬운 함정을 파뒀고 나를 포함한 많은 참가자들이 함정에 바로 푹 빠져버렸다. 이 문제에 대해서는 추후에 면접에서 나올 예정이다.. 그리고 웹은 생각보다 쉬웠지만, 알고리즘을 풀다가 못풀어 버렸다.</p>

<p>사실 비하인드 스토리긴 하지만, 나는 웹과 알고리즘 3번을 코딩테스트 당시에 엄청 고민했다. 둘 다 풀 수 있을 수준이라고 생각했고, 아무래도 알고리즘을 최근에 엄청 열심히 했기에 조금만 더 생각해보면 풀릴거라 생각했다. 그리고 비슷한 문제를 백준에서 풀었기에 더 자신감이 있었을지도 모르겠다. 하지만 구현을 하면 할수록 개미지옥에 빠지는 느낌이였고 결국 두마리 토끼 다 놓쳐버렸다… 그냥 웹이나 할걸..</p>

<p>그렇게 총 두문제 밖에 풀지 못했지만, 운이 좋은건지 문제가 전체적으로 어려웠던건지 2차 코딩테스트까지 합격하게 됐다. 그리고 포트폴리오 준비로 넘어갔다.</p>

<h2 id="4-포트폴리오-타임어택-on">4. 포트폴리오 [타임어택 ON]</h2>

<p>2차 합격은 화요일 오후쯤 나왔고, 금요일 4시까지 포트폴리오를 제출하라고 했다. 다행인것은 기본적인 템플릿을 제공해 주어 사실 채우라는것만 채우면 됐었다. 하지만 여기서 함정이 숨어 있었는데 바로..</p>

<blockquote>
  <p>3분안에 발표할 내용을 넣어주세요</p>
</blockquote>

<p>그렇게 채워서 나름대로 시간을 재고 발표를 해보니 시간은 이미 4분이 훌쩍 넘어가 있었다. 그래서 열심히 채웠던 내용을 빼고 또 빼고 해서 3분을 채워서 제출했다. 지금와서 드는 생각이지만, 어차피 발표할 때 빼고 발표하면 되니까 맘껏 꾹꾹 눌러 담을 걸 그랬다.</p>

<p>나는 내가 정말 개발에 열정이 있고, 배포도 해봤고 협업도 잘했다..! 라고 표현하기 위해서 프로젝트 하나와, 내가 아직 제대로 개발한지는 1년밖에 되지 않았지만 그래도 정말 열심히 살았다는 증거를 보여주기 위해 자기소개 두개를 넣어서 진행했다.</p>

<h2 id="5-면접-히히-죽어라">5. 면접 [히히 죽어라]</h2>

<p>진짜 피말려서 죽는 줄 알았다… ㅋㅋㅋㅋ 끝나고 같이 면접하신 분이랑 점심을 먹고 헤어졌는데 정말 둘이서 실소를 했다가 아쉬워했다가 미친사람들처럼 밥을 먹었다…</p>

<p>우선 3분 포트폴리오 발표부터 했는데, 이거부터 문제였다. 2번인 나는 1번 다음 발표여서 아..! 1번님 하는거보고 바로 전략을 세워야겠다..! 생각을 했는데 웬걸 1번님이 안오셔서 내가 1번이 되어버렸다.. 그래서 질문같은것도 내가 항상 1번으로 대답해야했다… ㅜㅜㅜㅜ 이렇게 운이 안좋을 수 있나…!!</p>

<p>사실 발표를 준비 할 때 제일 걱정됐던게 3분을 넘기면 무슨일이 일어날지였다. 그런데 발표를 시작하자마자, 관계자분이 오셔서 스탑와치를 탁 두고 가셨다. 뭔가 보고 있으니 이미 시간이 2:59… 2:58… 이렇게 가고 있었다. 그래서 아차! 싶어서 빠르게 발표를 시작했다.</p>

<p>발표연습을 꽤 했었기에 대충 3분 나오는것을 알고 있었지만, 면접관들 얼굴한번 화면한번 조작한번 하다보니 생각보다 시간적으로 오차가 생겼다. 그래서 딱 마지막으로 ‘저를 이러이러한 지원자로 기억해주셨으면 좋겠습니다~’ 라는 멘트를 하려고 했는데 3분이 딱 걸려버렸다. 처음에 무시하고 에이 5초정도는 봐주겠지 라고 생각했지만 타이머는 기계였다. 한치의 오차 없이 ‘띠…띠…띠…’ 소리가 면접실에 울렸고 나는 ‘넵 감사합니다’ 하고 끝이나버렸다… 그래도 거의 할말을 다 했기에 아쉬움은 없지만 그래도 마지막 멋진 멘트를 할 기회를 뺐겼다는것이 아쉬웠다.</p>

<p>면접을 진행하다 보니 면접관들은 프로그래밍의 신이기 때문에 함부로 까불면 안된다는것을 배웠다. 다행히 나는 그렇게 어려운 API 나 Open Source 를 쓴것도 아니고, 그냥 React 로 프로젝트를 만들어 봤고 내가 아는선에서 발표를 진행했기에 그렇게 공격(?) 받지는 않았다. 하지만 나를 제외하고 3명은 전부 AI 를 활용했다고 발표했기에 엄청난 공격을 받으셨다.</p>

<blockquote>
  <p>근데 공격 받은게 좋은건지 그냥 관심없어서 넘어간게 좋은건지는 모르겠다</p>
</blockquote>

<p>나는 최대한 나에게 질문오는 것을 열심히 대답했다고 생각은 하는데, 면접관들이 보기엔 어떻게 생각할지 모르겠다. 하지만 면접은 자신감이라고 했다. 나는 모르든 맞든 내 대답이 앞뒤가 맞는 안맞든 그냥 자신감있게 뱉고 봤다. 지금 생각해보니 정말 막 대답을 해서 면접관 분들이 알아 들으셨을지도 잘 모르겠다.. ㅜㅜ</p>

<p>그리고 꼬리질문은 정말 매서웠다. 내가 쓴 기술들을 정말로 알고 있는지 확인을 정말 많이하셨고, 나는 특별히 어려운 기술을 안써서 잘 넘어갔다고 생각한다. 그리고 개발론에대해서도 대뜸 물어보시는 면접관이 계셨는데, 한명만 제대로 답할 수 있었다…</p>

<h2 id="후기">후기</h2>

<p>그렇게 한시간의 5:5 면접을 끝내고 나의 소프트웨어 마에스트로 지원이 끝이났다. 솔직히 1월부터 현재까지 프로젝트 진행하랴, 알고리즘 준비하랴, 발표 및 면접 준비하랴 정말 열심히 살았다. 그렇게 좋아하는 게임도 단 한판도 못할정도로 바쁘게 살았고 농도가 짙은 방학을 보냈다고 생각한다. 솔직히 결과가 어떻게 될지는 예상하기 어렵다. 나의 열정과 잠재력은 충분히 보여줬다고 생각은 들지만, 면접관들이 보시기에 내 진심이 잘 통했는지 모르겠다. 나는 기술적인 스택이 부족한것을 알기에 애초에 중점을 팀워크를 잘하고 포텐셜이 충만한것으로 갔었는데, 내 전략이 잘 먹혔기를 기도할 뿐이다.</p>

<p>앞으로 1주반 후에 결과가 나올텐데, 다음글이 소프트웨어 마에스트로 관련 글이라면 아마 합격을 했을것이고, 아예 딴 글이거나 올라오지 않는다면 떨어졌을것이다.</p>

<p>이렇게 열심히 무언가를 위해서 준비한것은 정말 수능 이후로 처음인것 같았다. 열심히 준비한만큼 좋은 결과가 있기를 바라지만, 그렇지 않더라도 값진 경험을 했다고 생각하고 더 발전하는 계기가 되었다고 생각할것이다.</p>]]></content><author><name>071yoon</name></author><category term="retrospect" /><category term="me" /><category term="retrospect" /><summary type="html"><![CDATA[Intro]]></summary></entry><entry><title type="html">서버 맛보기</title><link href="http://localhost:4000/server/2022/02/23/server.html" rel="alternate" type="text/html" title="서버 맛보기" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/server/2022/02/23/server</id><content type="html" xml:base="http://localhost:4000/server/2022/02/23/server.html"><![CDATA[<h2 id="what-is-nodejs">What is Node.js</h2>

<p>Javscript는 알다시피 HTML 을 활용하기 위해서 만들어진 언어이며, 컴파일은 브라우저가 담당한다.</p>

<blockquote>
  <p>Chrome 은 V8, FireFox 는 SpiderMonkey ..</p>
</blockquote>

<p>그리고 Chrome V8 해석엔진이 워낙 좋아서, 해당 엔진을 사용하여 자체를 따로 출시하여 만든것이 Node.js 즉 크롬의 자바스크립트 엔진</p>

<p>자바스크립트를 브라우저 내에서 사용하는것이 아닌 다른 환경에서도 실행을 할 수 있게 도와주기 위한 도구, 즉 런타임 실행환경이라 볼 수 있다</p>

<p>이제 Node.js 덕분에 JavaScript를 프로그래밍 언어처럼 만들 수 도 있고, 서버도 쉽게 만들 수 있음!!</p>

<p>그리고 Node.js 의 가장 큰 장점은 Non-blocking I/O 를 활용한다는점!!</p>

<h2 id="nodejs의-특징">Node.js의 특징</h2>

<ol>
  <li>Event Driven</li>
  <li>Non-blocking I/O</li>
</ol>

<p>일반적인 서버와 Node.js Non-Blocking 의 특징을 알아보면 일반 서버라면, 요청을 처리하는 과정이 FIFO 으로 제일 먼저 들어온 요청부터 처리하지만, Node.js 라면 일단 I/O 를 다 받아보고 빨리 완료될 것 부터 확인을 해서 처리를 가능하게 해준다.</p>

<p>Node.js의 강점을 보여주는 부분</p>

<ol>
  <li>SNS</li>
  <li>Chatting</li>
  <li>WebServer</li>
</ol>

<p>으로 볼 수 있다.</p>

<p>즉 간단한 서비스나 프로토 타입을 만들기에 정말 좋지만, 처리속도가 타 서버들보다 떨어 질 수 있으며, Node.js의 특징인 Non-Blocking 처리방식 또한, 다른 언어에서도 구현 할 수 있다.</p>

<h2 id="rest-api">REST API</h2>

<h3 id="api">API</h3>

<p>API 란 무엇인가.</p>

<p>Application Programming Interface 라고 부르며, 간단한 통신 규약이라 볼 수 있다. 간단하게 말하면 다른 프로그램들 간에 소통을 할 수 있게 데이터를 가져오는 방법이다.</p>

<h3 id="rest-api-1">REST API</h3>

<p>Representational State Transfer</p>

<p>서버를 RESTFUL 하게 짠다는건 무엇일까??</p>

<p>HTTP 의 4가지 요청 (GET, POST, PUT, DELETE) 를 REST 원칙에 대하여 써보자!</p>

<blockquote>
  <p>대표적으로 6가지의 특징이 있다</p>
</blockquote>

<ol>
  <li>Uniform Interface
    <ol>
      <li>인터페이스는 일관성이 있어야 된다</li>
      <li>하나의 URL 로는 하나의 Data만 가져와야된다</li>
      <li>간결하고 예측가능해야된다</li>
      <li>URL 이름짓기 관습을 따라야한다</li>
    </ol>
  </li>
  <li>Client-Server 역할을 구분한다
    <ol>
      <li>URL 하나만 알면 서버에 있는 자료를 사용</li>
      <li>고객에게 서버의 역할을 맡기거나 DB 를 꺼내오게 하면 안된다</li>
    </ol>
  </li>
  <li>Stateless
    <ol>
      <li>요청들은 각각 독립적으로 처리되어야 한다</li>
      <li>요청1이 성공하면 요청2를 보내주고 하는 식의 요청은 안된다</li>
      <li>요청하나 만으로 자료를 가져올 수 있게 설정</li>
    </ol>
  </li>
  <li>Cacheable
    <ol>
      <li>요청을 통해 보내는 자료들은 캐싱이 되어야 한다</li>
    </ol>
  </li>
  <li>Layered System
    <ol>
      <li>요청을 처리하는곳, DB에 저장하는곳 이런 여러가지 단계를 거쳐 요청을 처리해도 된다</li>
      <li>여러개의 레이어를 거쳐 요청을 처리하게 만들자</li>
    </ol>
  </li>
  <li>Code on Demand
    <ol>
      <li>서버는 고객에게 실제 실행 가능한 코드를 전송 할 수 있다</li>
    </ol>
  </li>
</ol>

<p>다음에는 실제로 Node.js 와 Express 를 사용해 MongoDB 와 연동을 해보자</p>]]></content><author><name>071yoon</name></author><category term="server" /><category term="server" /><category term="TIL" /><summary type="html"><![CDATA[What is Node.js]]></summary></entry></feed>