<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-01T12:51:18+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YeongGi’s tech blog</title><subtitle>This is YeongGi's tech blog. I post IT related items.</subtitle><author><name>071yoon</name></author><entry><title type="html">Socket.io 연결 에러</title><link href="http://localhost:4000/til/2022/06/30/socket-error.html" rel="alternate" type="text/html" title="Socket.io 연결 에러" /><published>2022-06-30T00:00:00+09:00</published><updated>2022-06-30T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/06/30/socket-error</id><content type="html" xml:base="http://localhost:4000/til/2022/06/30/socket-error.html"><![CDATA[<h2 id="socket-통신시-에러나는-경우">Socket 통신시 에러나는 경우</h2>

<p>최근에 WebRTC를 사용하며 소켓 통신을 해야할 일이 생겼는데, 웬걸 자꾸 연결에서 실패를 하였다.</p>

<p>우선 결론은 dependency 확인이다. Front에서 연결을 하려는 소켓 통신인 경우 <code class="language-plaintext highlighter-rouge">socket.io-client</code>라는 module을 사용하는데, 이게 Back에 기다리고 있는 <code class="language-plaintext highlighter-rouge">socket.io</code> 모듈에서의 Server와 Socket의 dependency를 맞춰야 된다. 내가 Front 에서 사용하던 모듈은 ^4.3 이였고 백에서는 ^2에서 주었기 때문에 당연히 오류가 났다… 결국 둘 다 최근 모듈인 4세대로 바꾼 후 잘 작동하였다 ㅎㅎ
<img width="305" alt="image" src="https://user-images.githubusercontent.com/66371206/176819682-9a5fe411-e64c-4152-88dd-0c7c6d303155.png" /></p>

<p>백엔드와 소통을 열심히 하자~</p>

<h3 id="공식-document와-stackoverflow를-보며-했던-tries">공식 document와 StackOverflow를 보며 했던 tries</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">io</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">socket.io-client</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">io</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">socket.io-client</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">io</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">socket.io-client</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>등 버전에 따라 import 하는 방식도 다른 것 같았다.</p>

<h3 id="유의사항">유의사항</h3>

<blockquote>
  <p>Backend에서 줄 때는 CORS에러에 유의하자.</p>
</blockquote>

<blockquote>
  <p>ES6의 React StrictMode를 꺼야지 Socket통신을 한번만 받는다. 켜두면 두번 받아서 한번은 잘 받고, 한번은 제대로 못받아서 오류가 났었다.</p>
</blockquote>]]></content><author><name>071yoon</name></author><category term="TIL" /><category term="TIL" /><category term="Javascript" /><summary type="html"><![CDATA[Socket 통신시 에러나는 경우]]></summary></entry><entry><title type="html">Mac 초기 세팅</title><link href="http://localhost:4000/mac/2022/06/05/mac-setting.html" rel="alternate" type="text/html" title="Mac 초기 세팅" /><published>2022-06-05T00:00:00+09:00</published><updated>2022-06-05T00:00:00+09:00</updated><id>http://localhost:4000/mac/2022/06/05/mac-setting</id><content type="html" xml:base="http://localhost:4000/mac/2022/06/05/mac-setting.html"><![CDATA[<h2 id="나만의-맥북-셋업">나만의 맥북 셋업</h2>

<p>이번에 새로운 Mac m1 pro 를 갖게 되면서, 설치하다보니 뭐를 설치해야되고 어떤거를 동기화 해야되고 생각보다 기억이 잘 안났다. 그래서 이번 기회에 나의 맥이라면 이런걸 해야하는 TODO List를 만들어 보았다.</p>

<h3 id="개발자-도구"><a href="#개발자도구">개발자 도구</a></h3>

<ul>
  <li><a href="#iterm-setting">iTerm2</a></li>
  <li><a href="#web-programming">Web</a></li>
  <li><a href="#blog">Blog</a></li>
</ul>

<h3 id="어플"><a href="#applications">어플</a></h3>

<ul>
  <li><a href="#chrome">Chrome</a></li>
  <li><a href="#visual-stuido-code">Visual Stuido Code</a></li>
  <li><a href="#discord">Discord</a></li>
  <li><a href="#kakaotalk">KakaoTalk</a></li>
  <li><a href="#webex">Webex</a></li>
  <li><a href="#slack">Slack</a></li>
  <li><a href="#notion">Notion</a></li>
  <li><a href="#terminus">Terminus</a></li>
</ul>

<h3 id="위젯"><a href="#Widgets">위젯</a></h3>

<ul>
  <li><a href="#alt-tab">Alt-Tab</a></li>
  <li><a href="#fig">Fig</a></li>
  <li><a href="#runcat">RunCat</a></li>
  <li><a href="#unicorn">Unicorn</a></li>
  <li><a href="#hidden-bar">Hidden-Bar</a></li>
  <li><a href="#magnet">Magnet</a></li>
  <li><a href="#karabiner">Karabiner</a></li>
  <li><a href="#amphetamine">Amphetamine</a></li>
</ul>

<h2 id="개발자도구">개발자도구</h2>

<h3 id="iterm-setting">iTerm Setting</h3>

<p>나는 내장 terminal보다 iTerm을 주로 쓴다. 하이라이트, 복사, 붙여넣기, 히스토리 등 다양한 기능이 많아서 더 편함</p>

<ul>
  <li>
    <h4 id="oh-my-zsh">Oh-my-zsh</h4>

    <p>기왕 Terminal 쓰는김에 이쁘면 좋잖아요?</p>

    <p><a href="https://ohmyz.sh">공식문서</a></p>
  </li>
  <li>
    <h4 id="powerlevel10k">Powerlevel10k</h4>

    <p>마찬가지로 zsh shell을 더 이쁘게 만들어준다.</p>

    <p>설치 끝내고, VSC Terminal에서도 폰트 적용을 해서 깨지는걸 방지하자</p>

    <p><a href="https://github.com/romkatv/powerlevel10k">공식문서</a>
<a href="https://velog.io/@boms2/Mac-Powerlevel10k로-Zsh-터미널-꾸미기-M1">도움받은 블로그</a></p>

    <p>완성된 모습
<img width="681" alt="스크린샷 2022-06-09 오후 2 00 03" src="https://user-images.githubusercontent.com/66371206/172768037-5da27996-7652-42ff-874b-f84c55648b32.png" /></p>
  </li>
  <li>
    <h4 id="brew">brew</h4>

    <p>당연히 깔아야 하는 맥주</p>

    <p><a href="https://brew.sh/index_ko">공식문서</a></p>
  </li>
  <li>
    <h4 id="git-setup">git setup</h4>

    <p>git login을 미리미리 해두자</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git config <span class="nt">--global</span> user.name <span class="s2">"John Doe"</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> user.email johndoe@example.com
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="web-programming">Web Programming</h3>

<p>명색이 프론트엔드이기에 깔아야 하는 기본적인 세팅</p>

<ul>
  <li>
    <h4 id="node">node</h4>

    <p>맥주가 있어 행복하다</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>node
node <span class="nt">--version</span>
npm <span class="nt">--version</span>
</code></pre></div>    </div>
  </li>
  <li>
    <h4 id="yarn">yarn</h4>

    <p>npm보다 더 안전하고 오류를 잘 잡아준다</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>yarn <span class="nt">--ignore-dependencies</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="blog">Blog</h3>

<p>해당 깃허브 블로그 또한 jekyll 로 관리하기에 ruby, bundle, jekyll설치가 필수적이다</p>

<ul>
  <li>
    <h4 id="ruby">Ruby</h4>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>rbenv ruby-build
rbenv <span class="nb">install</span> <span class="nt">-l</span> <span class="c">#버전은 알아서 선택! 근데 3.0.0 부터 잘 안됐던거 같음</span>
rbenv <span class="nb">install </span>2.7.2
rbenv global 2.7.2
</code></pre></div>    </div>

    <p>zsh 적용하기</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim ~/.zshrc
</code></pre></div>    </div>

    <p>들어가서 환경변수 추가</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/.rbenv/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>
<span class="nb">eval</span> <span class="s2">"</span><span class="si">$(</span>rbenv init -<span class="si">)</span><span class="s2">"</span>
</code></pre></div>    </div>
  </li>
  <li>
    <h4 id="bundle--jekyll">Bundle &amp;&amp; Jekyll</h4>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>bundler
bundle add jekyll
bundle <span class="nb">install
</span>gem <span class="nb">install </span>jekyll
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="applications">Applications</h2>

<p>내가 최초로 설치했던 어플리케이션 목록</p>

<h3 id="chrome">Chrome</h3>

<p>사파리 대체용품</p>

<h3 id="visual-stuido-code">Visual Stuido Code</h3>

<ul>
  <li>
    <h4 id="code-runner">Code Runner</h4>

    <p>작성한 코드를 빠르게 실행시켜주게 도와주는 확장</p>
  </li>
  <li>
    <h4 id="discord-presence">Discord Presence</h4>

    <p>Discord 에서 내가 어떤 작업하고 있는지 보여주는 확장
<img width="353" alt="스크린샷 2022-06-09 오후 2 02 14" src="https://user-images.githubusercontent.com/66371206/172768189-80f3ab3c-8d3a-4ff7-98ff-a30175ceed47.png" /></p>
  </li>
  <li>
    <h4 id="eslint">ESLint</h4>

    <p>ESLint 규칙 적용해주는 확장</p>
  </li>
  <li>
    <h4 id="git-graph">Git-Graph</h4>

    <p>VSC Git Page에서 Git-Kraken 처럼 어떤 브랜치에서 어떤 작업하는지 보여주는 확장</p>
  </li>
  <li>
    <h4 id="live-share">Live Share</h4>

    <p>VSC를 쓰는 주된 이유</p>
  </li>
  <li>
    <h4 id="live-server">Live Server</h4>

    <p>VSC를 쓰는 주된 이유2 -&gt; Live share 호스트 컴퓨터에서 서버 올릴 때 접속한 사람들도 같은 localhost로 접속 할 수 있음</p>
  </li>
  <li>
    <h4 id="prettier">Prettier</h4>

    <p>Lint 혹은 일반적인 코드 포맷팅 도와주는 포매터
기본 foramtter를 prettier로 설정 및 format on save 등록하는걸 까먹지 말자.</p>

    <p><img src="https://user-images.githubusercontent.com/66371206/172768418-1d71bd54-8a8d-4faf-8a08-0aef05dc6d74.png" alt="image" /></p>

    <p><img src="https://user-images.githubusercontent.com/66371206/172768450-f4fc69bc-5ba7-4a13-8cf4-e3788dfd480d.png" alt="image" /></p>
  </li>
  <li>
    <h4 id="styled-components">Styled-Components</h4>

    <p>styled에서 주석처럼 안달리고, 코드처럼 사용가능. 훨씬 쉽다.
심지어 추천도 해준다
<img src="https://user-images.githubusercontent.com/66371206/172768289-34e830cd-3a5b-472e-87a0-e2e6dd12f0d1.png" alt="image" /></p>
  </li>
  <li>
    <h4 id="material-icon">Material Icon</h4>

    <p><img src="https://user-images.githubusercontent.com/66371206/172767754-dee7ea7e-5c56-485d-aae3-8cce8d3cf2af.png" alt="image" /></p>

    <p>옆에 아이콘들 이쁘게 보임</p>
  </li>
  <li>
    <h4 id="markdown-all-in-one">Markdown All in One</h4>

    <p>블로그 쓸 일이 많다면, 마크다운 쓸 때 도움 받을 수 있다</p>
  </li>
  <li>
    <h4 id="markdown-preview">Markdown Preview</h4>

    <p>마크다운 미리보기 지원</p>

    <p><img src="https://user-images.githubusercontent.com/66371206/172768531-8acc01b2-0d48-4926-81b1-c780fa316a20.png" alt="image" /></p>
  </li>
</ul>

<h3 id="discord">Discord</h3>

<h3 id="kakaotalk">KakaoTalk</h3>

<h3 id="webex">Webex</h3>

<h3 id="slack">Slack</h3>

<h3 id="notion">Notion</h3>

<h3 id="terminus">Terminus</h3>

<h2 id="widgets">Widgets</h2>

<h3 id="alt-tab">Alt-Tab</h3>

<p>보통 맥북을 사용하다보면, Cmd + Tab을 주로 사용하는데, 사파리 창이 여러개 띄워져 있는 경우에 상당히 불편하다. 윈도우처럼 쓰는 창들이 전부 분할해서 나오면 참 좋겠다~ 싶을 때 사용하는 위젯</p>

<p><img width="1215" alt="image" src="https://user-images.githubusercontent.com/66371206/172768969-3022bcc2-c7d9-42ff-ae94-ad978e8af522.png" /></p>

<h3 id="fig">Fig</h3>

<p>터미널을 쓰다보면, 단축키가 뭐였는지 까먹을 때가 많다. 올바른 명령어를 추천해주기도 하고, cd 에서 어디로 가야할 지 모를 때, ls로 안찾고 gui처럼 쉽게 찾을 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/66371206/172769368-c464cf70-019b-4216-8baa-ec91a1d90111.png" alt="스크린샷 2022-06-09 오후 2 12 43" /></p>

<p><img src="https://user-images.githubusercontent.com/66371206/172769373-95a150b5-d293-4589-af72-9cb13196ba90.png" alt="스크린샷 2022-06-09 오후 2 12 58" /></p>

<p><img src="https://user-images.githubusercontent.com/66371206/172769378-86ed108d-4a26-492c-a47d-b90ba30a515b.png" alt="스크린샷 2022-06-09 오후 2 13 10" /></p>

<h3 id="runcat">RunCat</h3>

<p>상태바에 CPU 속도만큼 뛰는 고양이</p>

<p>나는 주로 귀여운 슬라임과 WIFI 다운로드 및 업로드 속도를 켜둔다</p>

<p><img src="https://user-images.githubusercontent.com/66371206/172769669-0f0e2982-bf7f-4395-8fd8-a8fe1384ead2.gif" alt="화면-기록-2022-06-09-오후-2 14 41" /></p>

<h3 id="unicorn">Unicorn</h3>

<p>사파리 광고차단 위젯.</p>

<p>유료인데 값어치를 한다고 생각한다</p>

<h3 id="hidden-bar">Hidden-Bar</h3>

<p>상태바에 너무 많아서 정리하고 싶을 때 사용.</p>

<p>보통 상태바에서 정말 빠져도 괜찮다~ 싶은데, 필수록 달아둬야 하는게 많은데, 그런것들 빼놓을 수 있다</p>

<h3 id="magnet">Magnet</h3>

<h3 id="karabiner">Karabiner</h3>

<p>윈도우 키보드를 맥용으로 사용할 수 있게 도와준다.</p>

<p>나는 Cmd와 Option 키만 바꿔서 사용한다.</p>

<h3 id="amphetamine">Amphetamine</h3>]]></content><author><name>071yoon</name></author><category term="Mac" /><category term="Mac" /><category term="Setting" /><summary type="html"><![CDATA[나만의 맥북 셋업]]></summary></entry><entry><title type="html">CSS의 역사</title><link href="http://localhost:4000/css/2022/05/31/css-history.html" rel="alternate" type="text/html" title="CSS의 역사" /><published>2022-05-31T00:00:00+09:00</published><updated>2022-05-31T00:00:00+09:00</updated><id>http://localhost:4000/css/2022/05/31/css-history</id><content type="html" xml:base="http://localhost:4000/css/2022/05/31/css-history.html"><![CDATA[<center>CSS 트렌드</center>

<p><img src="https://user-images.githubusercontent.com/66371206/171093573-f5758d9a-6ff3-44e8-aa86-8c52ad983c93.png" alt="image" /></p>

<center>(출처: oliverturner's twitter)</center>

<h2 id="traditional-css">Traditional CSS</h2>

<p>가장 전통적인 CSS 방식에는 크게 3가지 방식이 존재한다.</p>

<ul>
  <li><a href="#inline-css">Inline CSS</a></li>
  <li><a href="#internal-css">Internal CSS</a></li>
  <li><a href="#external-css">External CSS</a></li>
</ul>

<h3 id="inline-css">Inline CSS</h3>

<blockquote>
  <p>일반적으로 간단하게 태그안에 style을 적용하는 방법</p>
</blockquote>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1</span> <span class="na">style=</span><span class="s">"color:white;padding:30px;"</span><span class="nt">&gt;</span>Inline CSS<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;p</span> <span class="na">style=</span><span class="s">"color:white;"</span><span class="nt">&gt;</span>HTML 안에서 직접 스타일 적용.<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<h4 id="inline-css-장점">Inline CSS 장점</h4>

<ul>
  <li>HTML 페이지에 쉽고 빠르게 CSS 룰을 삽입할 수 있다.
    <ul>
      <li>변경에 대한 미리보기, 그리고 빠르게 고칠 수 있는 성능에 유용하다.</li>
    </ul>
  </li>
  <li>별도의 문서로 외부 스타일을 만들거나 업로드 할 필요가 없다.</li>
</ul>

<h4 id="inline-css-단점">Inline CSS 단점</h4>

<ul>
  <li>CSS룰을 모든 HTML 엘리먼트에 추가하는 것은 시간 낭비이며 HTML 구조를 복잡하게 만든다.</li>
  <li>여러 엘리먼트에 스타일을 적용하는 것은 웹페이지 사이즈가 커지고 다운로드 시간이 걸리게 된다.</li>
</ul>

<h3 id="internal-css">Internal CSS</h3>

<blockquote>
  <p>CSS Object Model처럼 사용하는 방법.</p>
</blockquote>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;style </span><span class="na">type=</span><span class="s">"text/css"</span><span class="nt">&gt;</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nt">h1</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
    <span class="nl">padding</span><span class="p">:</span> <span class="m">60px</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nt">&lt;/style&gt;</span>
</code></pre></div></div>

<h4 id="internal-css-장점">Internal CSS 장점</h4>

<ul>
  <li>스타일시트에 클래스와 ID 선택자를 사용할 수 있다.</li>
  <li>동일한 HTML 파일 내에서만 코드를 추가하여 여러 파일을 업로드할 필요가 없다.</li>
</ul>

<h4 id="internal-css-단점">Internal CSS 단점</h4>

<ul>
  <li>HTML 문서에 코드를 추가하는 것은 페이지의 사이즈와 로딩 시간을 증가시킬 수 있다.</li>
</ul>

<h3 id="external-css">External CSS</h3>

<blockquote>
  <p>외부에 .css 파일을 따로 빼서 만드는 방법.</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* external.css */</span>
<span class="nc">.xleftcol</span> <span class="p">{</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">33%</span><span class="p">;</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#809900</span><span class="p">;</span>
<span class="p">}</span>
<span class="nc">.xmiddlecol</span> <span class="p">{</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">34%</span><span class="p">;</span>
  <span class="nl">background</span><span class="p">:</span> <span class="m">#eff2df</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- head --&gt;</span>
<span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span> <span class="na">href=</span><span class="s">"external.css"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h4 id="external-css의-장점">External CSS의 장점</h4>

<ul>
  <li>CSS 코드가 별도의 문서로 있기 때문에 HTML 파일 구조가 깔끔해지고, 사이즈가 작아진다.</li>
  <li>여러 페이지들에 같은 .css 파일을 사용할 수 있다.</li>
</ul>

<h4 id="external-css의-단점">External CSS의 단점</h4>

<ul>
  <li>외부 CSS 파일이 로드되기 전까지 페이지가 올바르게 표시되지 않는다.</li>
  <li>여러 CSS 파일을 업로드 하거나 연결하면 사이트 다운로드 시간이 증가할 수 있다.</li>
</ul>

<h2 id="sassscss">SASS/SCSS</h2>

<blockquote>
  <p>SCSS와 SASS는 CSS를 편리하게 이용할 수 있도록 도와주며 추가 기능도 있는 확장판이다</p>
</blockquote>

<p>간단하게 css 스타일의 코드 차이를 보며 이해해보자</p>

<h3 id="일반적인-css">일반적인 CSS</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.list</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">li</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
  <span class="nl">background</span><span class="p">:</span> <span class="sx">url("./image.jpg")</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">li</span><span class="nd">:last-child</span> <span class="p">{</span>
  <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-10px</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="scss">SCSS</h3>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.list</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span><span class="p">;</span>
  <span class="nt">li</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
    <span class="nl">background</span><span class="p">:</span> <span class="sx">url("./image.jpg")</span><span class="p">;</span>
    <span class="k">&amp;</span><span class="nd">:last-child</span> <span class="p">{</span>
      <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-10px</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sass">SASS</h3>

<div class="language-sass highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.list</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100px</span>
  <span class="nl">float</span><span class="p">:</span> <span class="nb">left</span>
  <span class="nt">li</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span>
    <span class="nl">background</span><span class="p">:</span> <span class="sx">url("./image.jpg")</span>
    <span class="k">&amp;</span><span class="nd">:last-child</span>
      <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-10px</span>
</code></pre></div></div>

<h3 id="왜-쓰는가">왜 쓰는가</h3>

<blockquote>
  <p>CSS가 복잡한 언어는 아니지만 작업이 크고 고도화 될수록 불편하다!</p>
</blockquote>

<p>SCSS나 SASS는 선택자를 많이 남발하거나 프로젝트가 커지면서 점점 복잡해지게 되는데, 이러한 부분에서 가독성과 재사용성을 높여주며 유지보수를 쉽게 만들어준다. 여기서 도움을 주는 도구는 다음과 같다.</p>

<ul>
  <li>변수의 사용</li>
  <li>조건문과 반복문</li>
  <li>Import</li>
  <li>Nesting</li>
  <li>Mixin</li>
  <li>Extend/Inheritance</li>
</ul>

<h3 id="scss-vs-sass">SCSS vs SASS</h3>

<p>SCSS = (Sassy CSS) -&gt; 지리는 CSS</p>

<p>SASS = (Syntactically Awesome Style Sheets) -&gt; 문법적으로 엄청난 CSS</p>

<blockquote>
  <p>SASS는 들여쓰기 기반, SCSS는 {} 기반</p>
</blockquote>

<p>일반적으로 SCSS가 더 넓은 범용성과 CSS의 호환성 등의 장점으로 SCSS를 사용하기를 권장하고 있다!</p>

<h2 id="bem">BEM</h2>

<blockquote>
  <p>Blcok, Element, Modifier</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.header__navigation--navi-text</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>여기서 header는 <code class="language-plaintext highlighter-rouge">Block</code>, naviagtion은 <code class="language-plaintext highlighter-rouge">Element</code>, navi-text는 <code class="language-plaintext highlighter-rouge">Modifier가</code> 된다.</p>

<p>BEM은 기본적으로 ID를 사용하지 않으며, class만을 사용하며, 이름을 연결할 때는 block-name과 같이 하이픈 하나만 써서 연결한다.</p>

<h3 id="block">Block</h3>

<blockquote>
  <p>재사용 가능한 기능적으로 독립적인 페이지 컴포넌트</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/66371206/171098198-40127e9b-c070-4c13-8a33-4198472d5d28.png" alt="9977B24F5C7BF67802" /></p>

<p>즉 위 사진처럼 떼어내서, 재사용이 가능한 컴포넌트를 부른다. 어디에서나 종속되지 않고, 독립적으로 사용할 수 있으며 특징으로는 블럭은 블럭으로 감쌀 수 있다는 점이 있다.</p>

<h3 id="element">Element</h3>

<blockquote>
  <p>블럭을 구성하는 단위</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/66371206/171098520-fe2f8dac-867e-45e3-85d3-9979e60e5647.png" alt="993FCF4A5C7BF68F27" /></p>

<p>자신이 속한 블럭 내에서만 의미를 가지기 때문에 블럭 안에서 떼어다 다른 데 쓸 수 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">form</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">search-form</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">input</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">search-form__input</span><span class="dl">"</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="nx">button</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">search-form__button</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">Search</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span></code></pre></div></div>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">.search-form</code>은 블럭이고, <code class="language-plaintext highlighter-rouge">.search-form__input</code>과 <code class="language-plaintext highlighter-rouge">.search-form__button</code>은 엘리먼트이다.
저 search-form이란 블럭은 떼어내서 마음껏 붙여도 된다.
하지만 내부의 input과 button은 검색을 위한 인풋창이자 버튼이기 때문에, search-form 안에서만 존재 의미가 있는 엘리먼트이다.</p>

<h3 id="modifier">Modifier</h3>

<blockquote>
  <p>블럭이나 엘리먼트의 속성을 담당</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/66371206/171098735-bb4930fb-7ee3-4bfd-82e5-de42bd017a50.png" alt="992F5E4A5C7BF68F33" /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">ul</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">li</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab__item tab__item--focused</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">탭</span> <span class="mi">1</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">li</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab__item</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">탭</span> <span class="mi">2</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">li</span> <span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">tab__item</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">탭</span> <span class="mi">3</span><span class="o">&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span></code></pre></div></div>

<p>위 코드에서 –focused가 수식어에 해당한다. 저렇게 작성된 걸 불리언(boolean) 타입이라고 하는데, 그 값이 true라고 가정하고 사용하며, <code class="language-plaintext highlighter-rouge">key-value</code>로도 사용할 수 있다.</p>

<h2 id="css-module">CSS Module</h2>

<blockquote>
  <p>리액트 프로젝트에서 컴포넌트를 스타일링 할 때 CSS Module 이라는 기술을 사용하면, CSS 클래스가 중첩되는 것을 완벽히 방지할 수 있다.</p>
</blockquote>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*box.css*/</span>
<span class="nc">.Box</span> <span class="p">{</span>
  <span class="nl">background</span><span class="p">:</span> <span class="no">black</span><span class="p">;</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">2rem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//box.js</span>
<span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">styles</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Box.module.css</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Box</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">Box</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">Box</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Box</span><span class="p">;</span>
</code></pre></div></div>

<p>그럼 다른 css 파일에서 동일한 css className을 만들어야 된다는 부담감에 필요없이 만들 수 있다.</p>

<h2 id="css-in-js">CSS in JS</h2>

<blockquote>
  <p>마지막으로 CSS in JS에서 제일 유명한 styled components 를 보며 알아보자</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Box4.js</span>
<span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">styled</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">styled-components</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Box</span><span class="p">({</span> <span class="nx">size</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isBig</span> <span class="o">=</span> <span class="nx">size</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">big</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">label</span> <span class="o">=</span> <span class="nx">isBig</span> <span class="p">?</span> <span class="dl">"</span><span class="s2">큰 박스</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">작은 박스</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">BoxCommon</span> <span class="nx">isBig</span><span class="o">=</span><span class="p">{</span><span class="nx">isBig</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">label</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/BoxCommon&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="kd">const</span> <span class="nx">BoxCommon</span> <span class="o">=</span> <span class="nx">styled</span><span class="p">.</span><span class="nx">div</span><span class="s2">`
  width: </span><span class="p">${(</span><span class="nx">props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">isBig</span> <span class="p">?</span> <span class="mi">200</span> <span class="p">:</span> <span class="mi">100</span><span class="p">)}</span><span class="s2">px;
  height: 50px;
  background-color: #aaaaaa;
`</span><span class="p">;</span>
</code></pre></div></div>

<p>다음과 같이 진행했던 CSS를 module 처럼 뺄 필요도 없이, 한 페이지에서 관리할 수 있다. 즉 CSS코드를 자바스크립트 파일안에서 하므로, 내부응집도가 올라가고, 동적으로 CSS를 변경하기도 쉽다.</p>

<p>출처</p>

<p><a href="https://latte-is-horse.tistory.com/38">https://latte-is-horse.tistory.com/38</a></p>

<p><a href="https://velog.io/@jch9537/CSS-SCSS-SASS">https://velog.io/@jch9537/CSS-SCSS-SASS</a></p>

<p><a href="https://nykim.work/15">https://nykim.work/15</a></p>

<p><a href="https://react.vlpt.us/styling/02-css-module.html">https://react.vlpt.us/styling/02-css-module.html</a></p>]]></content><author><name>071yoon</name></author><category term="CSS" /><category term="CSS" /><category term="SASS" /><category term="SCSS" /><category term="styled-components" /><category term="CSS-Moduler" /><summary type="html"><![CDATA[CSS 트렌드]]></summary></entry><entry><title type="html">Jira와 깃허브 연동</title><link href="http://localhost:4000/jira/2022/05/30/jira-github-%EC%97%B0%EB%8F%99.html" rel="alternate" type="text/html" title="Jira와 깃허브 연동" /><published>2022-05-30T00:00:00+09:00</published><updated>2022-05-30T00:00:00+09:00</updated><id>http://localhost:4000/jira/2022/05/30/jira-github-%EC%97%B0%EB%8F%99</id><content type="html" xml:base="http://localhost:4000/jira/2022/05/30/jira-github-%EC%97%B0%EB%8F%99.html"><![CDATA[<h2 id="jira와-깃허브-연동하기">Jira와 깃허브 연동하기</h2>

<h3 id="1-깃허브앱-등록">1. 깃허브앱 등록</h3>

<p>Jira와 연동을 하려면 우선 깃허브앱을 등록을 해야된다.
<img width="428" alt="image" src="https://user-images.githubusercontent.com/66371206/170931557-3de22400-fb72-4f72-9c0a-55c9d665ef1e.png" /></p>

<p>등록에 가서 평점이 조금 낮지만 공식 앱인 <code class="language-plaintext highlighter-rouge">Github for Jira</code>를 설치한다.</p>

<p><img width="823" alt="image" src="https://user-images.githubusercontent.com/66371206/170931899-d48cf6c9-57e0-47e7-891d-ce68ac0dc18d.png" /></p>

<p>그 후 Authorize를 하고 원하는 Organization 혹은 Repository를 등록하며 진행한다</p>

<p><img width="574" alt="image" src="https://user-images.githubusercontent.com/66371206/170932096-0d8481f1-b06c-449a-b66d-5a1d1cf658c8.png" /></p>

<p>다음과 같이 해당 깃허브 Repository에 Jira 앱이 설치되어 있고, 마찬가지로 Jira에도 앱 추가가 되어있으면 준비가 되었다.</p>

<p><img width="1156" alt="image" src="https://user-images.githubusercontent.com/66371206/170932363-abe6fda2-4380-4e63-a9d7-01e893ec950d.png" /></p>

<p><img width="1362" alt="image" src="https://user-images.githubusercontent.com/66371206/170932432-2458d419-37dd-479a-9cdb-fc594ce2b415.png" /></p>

<h3 id="2-이슈-만들기">2. 이슈 만들기</h3>

<p>우선 이슈를 만들려면 스프린트부터 작성을 해야된다. 해당 지라앱에서 새로운 에픽을 만들어보자.</p>

<p><img width="410" alt="image" src="https://user-images.githubusercontent.com/66371206/170931358-38c9357e-4599-4387-acb9-fc7569394184.png" /></p>

<p>스프린트를 만들었다면, 좌측에 백로그에서 해당 스프린트에 대한 이슈를 만들 수 있다.</p>

<p><img width="1165" alt="image" src="https://user-images.githubusercontent.com/66371206/170932860-c7c291ae-877a-4a49-86ca-fc6eee95eb64.png" /></p>

<p>간단하게 이슈를 하나 만든 후 스프린트 시작을 누르면 시작할 수 있고, 방금 만든 이슈에 대한 내용은 스프린트 페이지에서 하위 이슈로 확인 할 수 있다.</p>

<p><img width="1174" alt="image" src="https://user-images.githubusercontent.com/66371206/170933380-46979990-b58c-4bf9-b028-68f2912af333.png" /></p>

<h3 id="3-브랜치-및-커밋-작성">3. 브랜치 및 커밋 작성</h3>

<p>방금 만든 이슈에 대해서 커밋 만들기, 혹은 브랜치 만들기를 보면 다음과 같이 키를 알려준다.</p>

<p><img width="411" alt="image" src="https://user-images.githubusercontent.com/66371206/170933552-1f99d427-18ef-4178-8bd4-a61e736f4780.png" /></p>

<p><img width="428" alt="image" src="https://user-images.githubusercontent.com/66371206/170933605-1b00262d-cbae-43b1-869f-3a1bafa70660.png" /></p>

<p>여기서 해당하는 키를 가지고 브랜치를 만들고, 커밋을 하면 자동으로 jira 가 해당하는 커밋을 track 해서 연동을 해준다.</p>

<p>그렇게 해서 완성된 이슈를 보면 다음과 같다.</p>

<p>만들기 위해 커밋을 4번, 풀 리퀘스트를 진행 후 merge를 한 이슈이다.</p>

<p><img width="1169" alt="image" src="https://user-images.githubusercontent.com/66371206/170933764-2d136f8b-36d1-4246-bd46-90dd5682e870.png" /></p>

<p>해당하는 FIRE-44에 대한 커밋을 깃허브에서 보면 다음과 같이 설정되어있다.</p>

<p><img width="1264" alt="image" src="https://user-images.githubusercontent.com/66371206/170933985-8987738a-f687-49a1-af61-dfd22402a387.png" /></p>

<p>깃허브와 Jira 연동 끗!!</p>]]></content><author><name>071yoon</name></author><category term="Jira" /><category term="Jira" /><category term="Agile" /><category term="Github" /><category term="study" /><summary type="html"><![CDATA[Jira와 깃허브 연동하기]]></summary></entry><entry><title type="html">NEXT-API</title><link href="http://localhost:4000/next.js/2022/05/15/next-api.html" rel="alternate" type="text/html" title="NEXT-API" /><published>2022-05-15T00:00:00+09:00</published><updated>2022-05-15T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/15/next-api</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/15/next-api.html"><![CDATA[<h2 id="api-routes">API Routes</h2>

<h3 id="intro">Intro</h3>

<p><code class="language-plaintext highlighter-rouge">pages/api</code> 안에 있는 어떤 파일이든 전부 <code class="language-plaintext highlighter-rouge">/api/*/</code>로 접근 할 수 있으며, <code class="language-plaintext highlighter-rouge">page</code> 대신 API 최종점으로 여겨진다. 이 API들은 전부 server-side 전용이며, Client-side의 번들 사이즈를 증가시키지는 않는다.</p>

<p>예를들어, 다음과 같이 <code class="language-plaintext highlighter-rouge">pages/api/users.js</code>가 리턴하는 <code class="language-plaintext highlighter-rouge">json</code>같응ㄴ 경우는 status 200으로 소통한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">YeongGi Yoon</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이러한 API route가 작동하려면, 함수를 default 로 export 해야하며, 다음과 같은 인자들을 받는다</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">req</code>: http.IncomingMessage의 객체 중 하나 + pre-built middleware</li>
  <li><code class="language-plaintext highlighter-rouge">res</code>: http.ServerResponse의 객체 중 하나 + helper functions</li>
</ul>

<p>다양한 HTTP API route를 처리하기 위해, request handler에 다음과 같이 <code class="language-plaintext highlighter-rouge">req.method</code>를 활용할 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">method</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">POST) {
		//POST에 해당하는 req
	}
	else {
		//그 외
	}
}
</span></code></pre></div></div>

<h4 id="use-cases">Use Cases</h4>

<p>새로운 프로젝트들을 위해서, 모든 API 와 API route를 만들 수 있다. 만약 존재하는 API가 있따면, API Route를 통한 forward call을 하지 않아도 된다. 다양한 API Route의 활용법은 다음과 같다.</p>

<ul>
  <li>외부 서비스의 URL를 마스킹 하는것 (<code class="language-plaintext highlighter-rouge">https://company.com/secret-url</code> 대신 <code class="language-plaintext highlighter-rouge">/api/secret</code>을 사용하게 하는 것)</li>
  <li>서버에서 환경변수를 사용하여 더욱 안전하게 외부 서비스를 접근하는 법</li>
</ul>

<h4 id="caveats">Caveats</h4>

<p>API Routes는 <code class="language-plaintext highlighter-rouge">CORS header</code>를 특정화하지 않는다. 즉, 일반적으로 같은 근간이라 할 수 있다. 이와같은 행동은 <code class="language-plaintext highlighter-rouge">CORS middleware</code>에서 정의 할 수 있다.
API Route는 <code class="language-plaintext highlighter-rouge">next export</code>와 같이 사용될 수 없다.</p>

<h3 id="dynamic-api-routes">Dynamic API Routes</h3>

<p>API Route같은 경우에 <code class="language-plaintext highlighter-rouge">Dynamic Routes</code>를 바로 지원하며, 즉 <code class="language-plaintext highlighter-rouge">pages</code> 안에 파일 이름 규칙이 있다면 가져 올 수 있다. 예를들어 <code class="language-plaintext highlighter-rouge">pages/api/post/[pid].js</code> 와 같은 API Route가 존재한다면 코드로는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">pid</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">;</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">`Post: </span><span class="p">${</span><span class="nx">pid</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 되면, <code class="language-plaintext highlighter-rouge">/api/post/abc</code>에 해당하는 request가 <code class="language-plaintext highlighter-rouge">Post: abc</code>에서 응답을 받을 수 있다.</p>

<p>RESTful한 방식으로 routes를 만들면 다음과 같다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GET api/posts</code> : 모든 포스트에 대한 list를 가져온다</li>
  <li><code class="language-plaintext highlighter-rouge">GET api/posts/12345</code> : 12345에 대한 포스트 정보만 가져온다</li>
</ul>

<p>그럼 모델을 두가지 분류로 나눌 수 있다.</p>

<ol>
  <li>1번 옵션
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/api/posts.js</code></li>
      <li><code class="language-plaintext highlighter-rouge">/api/posts/[postId].js</code></li>
    </ul>
  </li>
  <li>2번 옵션
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/api/posts/index.js</code></li>
      <li><code class="language-plaintext highlighter-rouge">/api/posts/[postId].js</code></li>
    </ul>
  </li>
</ol>

<p>두가지 다 동일하지만, 세번째 옵션 <code class="language-plaintext highlighter-rouge">/api/posts/[postId].js</code> 같은 경우에는 Dynamic Routes가 <code class="language-plaintext highlighter-rouge">undefined</code>한 상태가 없기에 유효하지 않다.</p>

<h4 id="catch-all-api-routes">Catch all API routes</h4>

<p>API Route는 <code class="language-plaintext highlighter-rouge">...</code>을 추가하여 모든 루트를 추가할 수 있다. 예를 들어 <code class="language-plaintext highlighter-rouge">pages/api/post/[...slug].js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/a</code>와 매칭되며, <code class="language-plaintext highlighter-rouge">/api/post/a/b</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a/b/c</code> 모두 매칭이 된다. 이렇게 매칭된 인자들은 query parameter로 넘겨지며, 항상 배열이 된다. 즉 <code class="language-plaintext highlighter-rouge">/api/post/a</code>라는 루트는 <code class="language-plaintext highlighter-rouge">{ "slug": ["a"]}</code> 라는 <code class="language-plaintext highlighter-rouge">query object</code>를 가지게 된다. 만약 <code class="language-plaintext highlighter-rouge">/api/post/a/b</code> 라면 <code class="language-plaintext highlighter-rouge">{ "slug": ["a", "b"]}</code> 처럼 가지게 된다.</p>

<p>종합하여 보면 <code class="language-plaintext highlighter-rouge">pages/api/post/[...slug].js</code> 라는 API Route 는 다음과 같이 생겼다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">slug</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">;</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">`Post: </span><span class="p">${</span><span class="nx">slug</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2">, </span><span class="dl">"</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그럼 <code class="language-plaintext highlighter-rouge">/api/post/a/b/c</code> 라는 request는 <code class="language-plaintext highlighter-rouge">Post: a, b, c</code>로 응답을 받게된다.</p>

<h4 id="optional-catch-all-api-routes">Optional catch all API routes</h4>

<p>이중괄후를 사용하여 모든 루트를 찾는 방법또한 사용 할 수 있다. <code class="language-plaintext highlighter-rouge">[[...slug]]</code> 처럼 사용하면 되며 <code class="language-plaintext highlighter-rouge">pages/api/post[[...slug]].js</code> 가 <code class="language-plaintext highlighter-rouge">/api/post</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a/b</code> 모두 매칭 된다고 볼 수 있다.</p>

<h4 id="caveats-1">Caveats</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pages/api/post/create.js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/create</code> 과 매칭된다.</li>
  <li><code class="language-plaintext highlighter-rouge">pages/api/post/[pid].js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/1</code>, 와 <code class="language-plaintext highlighter-rouge">/api/post/abc,</code> 과 매칭되며 <code class="language-plaintext highlighter-rouge">/api/post/create</code> 과는 매칭되지 않는다.</li>
  <li><code class="language-plaintext highlighter-rouge">pages/api/post/[...slug].js</code> 는 <code class="language-plaintext highlighter-rouge">/api/post/1/2</code> 와 <code class="language-plaintext highlighter-rouge">/api/post/a/b/c</code>와 매칭되며 <code class="language-plaintext highlighter-rouge">/api/post/create</code> 나 <code class="language-plaintext highlighter-rouge">/api/post/abc</code>와는 매칭되지 않는다.</li>
</ul>

<h3 id="api-middlewares">API Middlewares</h3>

<h3 id="response-helpers">Response Helpers</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[API Routes]]></summary></entry><entry><title type="html">NEXT-Others-2</title><link href="http://localhost:4000/next.js/2022/05/08/next-others-2.html" rel="alternate" type="text/html" title="NEXT-Others-2" /><published>2022-05-08T00:00:00+09:00</published><updated>2022-05-08T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/08/next-others-2</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/08/next-others-2.html"><![CDATA[<h2 id="environment-variables">Environment Variables</h2>

<h3 id="loading-environment-variables">Loading Environment Variables</h3>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 우선 내부적으로 <code class="language-plaintext highlighter-rouge">.env.local</code> 과 <code class="language-plaintext highlighter-rouge">process.env</code> 같은 환경변수를 제공해준다. 예를들어 <code class="language-plaintext highlighter-rouge">.env.local</code> 같은 경우에는 다음과 같이 사용한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DB_HOST</span><span class="o">=</span>localhost
<span class="nv">DB_USER</span><span class="o">=</span>myuser
<span class="nv">DB_PASS</span><span class="o">=</span>mypassword
</code></pre></div></div>

<p>해당 환경변수들은 Node.js에서 자동으로 <code class="language-plaintext highlighter-rouge">Next.js</code>의 데이터를 가져오는 방식으로 사용하게 된다. 예를들어 해당 환경변수를 가지고 ` getStaticProps`를 사용하는 방식을 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">getStaticProps</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">db</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">myDB</span><span class="p">.</span><span class="nx">connect</span><span class="p">({</span>
    <span class="na">host</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_HOST</span><span class="p">,</span>
    <span class="na">username</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_USER</span><span class="p">,</span>
    <span class="na">password</span><span class="p">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_PASS</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>서버가 민감한 정보들을 안전하게 다루기 위해 Next.js는 <code class="language-plaintext highlighter-rouge">process.env.*</code> 파일을 빌드 시간에 맞는 경로로 전달한다. 즉 <code class="language-plaintext highlighter-rouge">process.env</code>는 자바스크립트에서의 표준이 아니며, object destructuring을 사용할 수 없다는 뜻이다. 즉 환경 변수는 <code class="language-plaintext highlighter-rouge">const { PUBLISHABLE_KEY } = process.env</code> 처럼 사용하는 것이 아닌 <code class="language-plaintext highlighter-rouge">process.env.PUBLISHABLE_KEY</code> 처럼 사용해야 된다.</td>
    </tr>
  </tbody>
</table>

<p>또한 Next.js는 (<code class="language-plaintext highlighter-rouge">$VAR</code>) 과 같은 변수들은 자동적으로 <code class="language-plaintext highlighter-rouge">.env*</code> 파일에서 연장하여 사용한다. 변수를 사용한 방법은 다음과 같다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># .env</span>
<span class="nv">HOSTNAME</span><span class="o">=</span>localhost
<span class="nv">PORT</span><span class="o">=</span>8080
<span class="nv">HOST</span><span class="o">=</span>http://<span class="nv">$HOSTNAME</span>:<span class="nv">$PORT</span>
</code></pre></div></div>

<p>만약 <code class="language-plaintext highlighter-rouge">$</code> 를 그대로 쓰고싶다면 <code class="language-plaintext highlighter-rouge">\$</code> 과 같이 백슬래쉬를 넣어 사용해야된다.</p>

<h3 id="exposing-environment-variables-to-the-browser">Exposing Environment Variables to the Browser</h3>

<p>일반적인 환경변수들은 <code class="language-plaintext highlighter-rouge">Node.js</code> 환경에서만 사용가능하므로, 브라우저에 유출이 되진 않는다. 만약 브라우저에서 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC</code> 으로 시작하는 변수를 외부로 유출시키고 싶다면, 다음과 같이 사용하면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NEXT_PUBLIC_ANALYTICS_ID</span><span class="o">=</span>abcdefghijk
</code></pre></div></div>

<p>이렇게 사용하게 되면, <code class="language-plaintext highlighter-rouge">process.env.NEXT_PUBLIC_ANALYTICS_ID</code>가 로드되어, Node.js 환경으로 자동으로 들어가 코드 어디에서도 사용 할 수 있게 된다. 즉 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_</code>과 같은 접두사를 사용하게 된다면, 자바스크립트가 브라우저에게 바로 값을 넘겨주게 된다. 이러한 인라인은 빌드시간에 일어나며, 다음과 같은 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_</code>의 환경변수들은 프로젝트가 빌드가 끝난 후 사용된다. 코드에서 사용되는 예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/index.js</span>
<span class="k">import</span> <span class="nx">setupAnalyticsService</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../lib/my-analytics-service</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// NEXT_PUBLIC_ANALYTICS_ID can be used here as it's prefixed by NEXT_PUBLIC_</span>
<span class="nx">setupAnalyticsService</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NEXT_PUBLIC_ANALYTICS_ID</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">HomePage</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">World</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span><span class="err">;
</span><span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">HomePage</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="default-envrionment-variables">Default Envrionment Variables</h3>

<p>일반적으로는 하나의 <code class="language-plaintext highlighter-rouge">.env.local</code>파일만이 필요하다. 하지만 가끔 <code class="language-plaintext highlighter-rouge">development</code>나 <code class="language-plaintext highlighter-rouge">production</code>에 따라 다른 환경 변수들을 사용 할 수 있다. 그래서 <code class="language-plaintext highlighter-rouge">Next.js</code> 는 <code class="language-plaintext highlighter-rouge">.env</code>, <code class="language-plaintext highlighter-rouge">.env.development</code>, <code class="language-plaintext highlighter-rouge">.env.production</code>과 같은 환경변수 또한 지원하며 <code class="language-plaintext highlighter-rouge">.env.local</code>을 항상 표준으로 둔다.</p>

<table>
  <tbody>
    <tr>
      <td>주의사항으로는 <code class="language-plaintext highlighter-rouge">.env</code>, <code class="language-plaintext highlighter-rouge">.env.development</code>, <code class="language-plaintext highlighter-rouge">.env.production</code> 과 같은 파일들은 <code class="language-plaintext highlighter-rouge">.env*.local</code>에 정의되어 있어야 하고 <code class="language-plaintext highlighter-rouge">.gitignore</code>에 포함시켜 안전하게 보관해야된다.</td>
    </tr>
  </tbody>
</table>

<h3 id="test-envrionment-variables">Test Envrionment Variables</h3>

<p><code class="language-plaintext highlighter-rouge">development</code>와 <code class="language-plaintext highlighter-rouge">production</code> 환경변수외로, <code class="language-plaintext highlighter-rouge">text</code>라는 세번째 옵션이 또 존재한다. 앞선 방법들과 마찬가지로 <code class="language-plaintext highlighter-rouge">.env.teest</code>에서 <code class="language-plaintext highlighter-rouge">testing</code> 환경을 구축하여 사용 할 수 있다.</p>

<p>이러한 방법은 <code class="language-plaintext highlighter-rouge">jest</code>나 <code class="language-plaintext highlighter-rouge">cypress</code>와 같은 테스팅 툴을 사용할 때 유용하게 사용 할 수 있다. 이러한 테스트 방식은 <code class="language-plaintext highlighter-rouge">NODE_ENV</code>가 <code class="language-plaintext highlighter-rouge">test</code>로 되어있다면, 테스트의 표준 환경을 사용 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">test</code> 가 <code class="language-plaintext highlighter-rouge">development</code> 와 <code class="language-plaintext highlighter-rouge">production</code> 와 다른점이 있다면, 테스트 환경은 <code class="language-plaintext highlighter-rouge">.env.local</code>에 로딩이 안된다는 것이다. 이러한 방식으로 실행되어야 매번 같은 환경을 사용할 수 있기 때문이다.</p>

<p>unit test 를 하는 동안에는 <code class="language-plaintext highlighter-rouge">@next/env</code> 패키지를 사용하여 <code class="language-plaintext highlighter-rouge">loadEnvConfig</code>를 해야함에 주의한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The below can be used in a Jest global setup file or similar for your testing set-up</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">loadEnvConfig</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@next/env</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">projectDir</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">cwd</span><span class="p">();</span>
  <span class="nx">loadEnvConfig</span><span class="p">(</span><span class="nx">projectDir</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>env의 우선순위는 다음과 같다.</p>

<h4 id="node_envproduction">NODE_ENV=production</h4>

<ol>
  <li>.env.production.local</li>
  <li>.env.local</li>
  <li>.env.production</li>
  <li>.env</li>
</ol>

<h4 id="node_envdevelopment">NODE_ENV=development</h4>

<ol>
  <li>.env.development.local</li>
  <li>.env.local</li>
  <li>.env.development</li>
  <li>.env</li>
</ol>

<h4 id="node_envtest">NODE_ENV=test</h4>

<ol>
  <li>.env.test.local</li>
  <li>.env.test</li>
  <li>.env</li>
</ol>

<h2 id="supported-browsers-and-features">Supported Browsers and Features</h2>

<h2 id="script-component">Script Component</h2>

<p>Image를 NEXT 에서 제공했던것 처럼, Script같은 경우에도 따로 지정해주는걸 사용하는것이 효율과 성능면에서 더 좋다. 해당 Script 컴포넌트는 <code class="language-plaintext highlighter-rouge">next/script</code>에서 가져올 수 있으며 기본적인 HTML <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>의 연장선이다. 해당 <script></script>는 <code class="language-plaintext highlighter-rouge">next/head</code> 밖에서 개발자들에게 로딩하는 우선순위를 지정할 수 있게 해주어 로딩 효율을 높여준다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Script</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/script</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://www.google-analytics.com/analytics.js</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="overview">Overview</h3>

<p>웹사이트는 가끔 통계, 광고, 위젯등을 사용할 때 써드파티의 스크립트를 사이트에서 사용하게 된다. 하지만 이러한 스크립트를 가져오는것이 보통 유저와 개발 입장에서 둘 다 문제를 일으키게 된다.</p>

<ul>
  <li>어떠한 써드파티의 스크립트 같은경우 너무 무거워서 로딩효율이 안좋고, UX 관점에서 되게 안좋을 수 있다. 특히나, render-block 혹은 딜레이가 생길 수 있다.</li>
  <li>개발자들은 어떠한 써드파티의 스크립트를 어디에 두어야 효율적인 로딩이 될지 고민하게 된다.</li>
</ul>

<p>이러한 문제들을 Next 에서 제공하는 <code class="language-plaintext highlighter-rouge">Script</code>를 사용하여 해결 할 수 있다.</p>

<h3 id="usage">Usage</h3>

<p>이러한 <code class="language-plaintext highlighter-rouge">Script</code>를 사용시에, <code class="language-plaintext highlighter-rouge">strategy</code>란 속성을 두어서 관리를 할 수 있다. 간단한 예제를 보면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://connect.facebook.net/en_US/sdk.js</span><span class="dl">"</span> <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">lazyOnload</span><span class="dl">"</span> <span class="o">/&gt;</span>
</code></pre></div></div>

<p>속성들을 보면 다음과 같다.</p>

<ul>
  <li><a href="#beforeinteractive">beforeInteractive</a></li>
  <li><a href="#afterinteractive">afterInteractive</a></li>
  <li><a href="#lazyonload">lazyOnload</a></li>
  <li><a href="#worker">worker</a></li>
</ul>

<h4 id="beforeinteractive">beforeInteractive</h4>

<p><code class="language-plaintext highlighter-rouge">beforeInteractive</code>속성이 있는 스크립트 같은 경우에는 최초의 HTML에 들어가, 서버가 바로 실행하여 self-bundle된 Javascript가 실행되기 전에 돌아간다. 이러한 방법은 페이지가 상호작용을 하기도전에, fetch하여 실행을 해야될 경우 주로 사용된다. 이러한 방법은 메인 페이지인 <code class="language-plaintext highlighter-rouge">_document.js</code>에서 동작하며, 보통 모든 사이트에서 로딩이 필요한 script인 경우에 들어가서 실행된다.</p>

<p>이러한 <code class="language-plaintext highlighter-rouge">beforeInteractive</code>한 방법이 사용되는 이유는, 오직 <code class="language-plaintext highlighter-rouge">_document.js</code>에서만 동작하게 하여 스티리밍과 Suspense functionality를 지원하기 위함이다. 즉 <code class="language-plaintext highlighter-rouge">_document.js</code> 의 밖에서는 <code class="language-plaintext highlighter-rouge">beforeInteractive</code>의 방식이 우선순위를 잘 두어 실행된다는 보장을 할 수 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In _document.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Html</span><span class="p">,</span> <span class="nx">Head</span><span class="p">,</span> <span class="nx">Main</span><span class="p">,</span> <span class="nx">NextScript</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/document</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Script</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/script</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Document</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Head</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">Script</span>
          <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js</span><span class="dl">"</span>
          <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">beforeInteractive</span><span class="dl">"</span>
        <span class="o">&gt;&lt;</span><span class="sr">/Script</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>보통 이러한 속성을 띄는 예는 다음과 같다.</p>

<ul>
  <li>Bot detectors</li>
  <li>Cookie consent managers</li>
</ul>

<h4 id="afterinteractive">afterInteractive</h4>

<p><code class="language-plaintext highlighter-rouge">afterInteractive</code> 방법을 쓰는 Script같은 경우에는 클라이언트 딴에서 삽입되어, Next.js가 hydration 작업을 마친 후에 동작한다. 이러한 방식은 제일빨리 실행될 필요가 없으며 우선순위가 낮을 때 사용하게 된다.</p>

<p>이러한 방식의 스크립트는 다음과 같은 상황에 많이 사용된다.</p>

<ul>
  <li>Tag managers</li>
  <li>Analytics</li>
</ul>

<h4 id="lazyonload">lazyOnload</h4>

<p><code class="language-plaintext highlighter-rouge">lazyOnload</code>의 속성을 띄는 Script 같은 경우에는, 모든 리소스들이 로딩된 후 <code class="language-plaintext highlighter-rouge">idle</code> 한 시간에 fetch되어 정보를 가져올 떄 사용된다. 이러한 방식은 background 나 낮은 우선순위를 가진 스크립트들이 주로 사용된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Script</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://connect.facebook.net/en_US/sdk.js</span><span class="dl">"</span> <span class="nx">strategy</span><span class="o">=</span><span class="dl">"</span><span class="s2">lazyOnload</span><span class="dl">"</span> <span class="o">/&gt;</span>
</code></pre></div></div>

<p>이러한 방식을 사용하는 스크립트는 주로 다음과 같다.</p>

<ul>
  <li>Chat support plugins</li>
  <li>Social media widgets</li>
</ul>

<h4 id="worker">worker</h4>

<p>해당 속성 같은 경우에는, 메일 쓰레드를 정해주어 효율을 높여주는 방식이지만, 아직 테스트 환경이라 안전하지 않다.</p>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Environment Variables]]></summary></entry><entry><title type="html">NEXT-Others-1</title><link href="http://localhost:4000/next.js/2022/05/05/next-others-1.html" rel="alternate" type="text/html" title="NEXT-Others-1" /><published>2022-05-05T00:00:00+09:00</published><updated>2022-05-05T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/05/next-others-1</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/05/next-others-1.html"><![CDATA[<h2 id="static-file-serving">Static File Serving</h2>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>는 파일을 <code class="language-plaintext highlighter-rouge">public</code>에서 이미지처럼 정적으로 활용 할 수 있다. <code class="language-plaintext highlighter-rouge">public</code>은 root 안에 있어야 하며, <code class="language-plaintext highlighter-rouge">public</code> 안에서는 <code class="language-plaintext highlighter-rouge">/</code>로 시작하는 base URL을 따라가야된다.</p>

<p><code class="language-plaintext highlighter-rouge">public/me.png</code>를 삽입하는 과정은 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Avatar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Image</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span> <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">me</span><span class="dl">"</span> <span class="nx">width</span><span class="o">=</span><span class="dl">"</span><span class="s2">64</span><span class="dl">"</span> <span class="nx">height</span><span class="o">=</span><span class="dl">"</span><span class="s2">64</span><span class="dl">"</span> <span class="o">/&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Avatar</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">next/img</code>의 대한 내용은 <a href="2022-05-04-next-optimization.md">NextOptimization</a> 를 참고.</p>

<p>이러한 폴더는 <code class="language-plaintext highlighter-rouge">robots.txt</code> 혹은 <code class="language-plaintext highlighter-rouge">favicon.ico</code> 에서도 사용이 될 수 있으며, Google Site Verification 등에도 활용될 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>주의사항! <code class="language-plaintext highlighter-rouge">public</code>이란 명명은 다른곳에서 사용하면 안된다. 해당 폴더는 정적인 asset만 포함되어야 된다!</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>주의사항2! 마찬가지로 정적 파일을 <code class="language-plaintext highlighter-rouge">pages/</code>라는 폴더 안에 넣게되면 에러가 난다!</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>주의사항3! <code class="language-plaintext highlighter-rouge">public</code> 폴더 안에 들어간 assets 들 만이 빌드 타임에서 Next.js로 넘겨진다. 런타임중에서는 추가가 되어도 활용되지 않으므로, <code class="language-plaintext highlighter-rouge">AWS S3</code>과 같은 third party를 사용하는 것이 좋다.</td>
    </tr>
  </tbody>
</table>

<h2 id="fast-refresh">Fast Refresh</h2>

<p>Fast Refresh는 React component에 편집을 한 즉시 피드백을 주는 기능이다. 이러한 기능은 Next.jsdml 9.4 이상에서 자동으로 작동하며, 켜져있다면 component 의 상태정보를 잃지 않고 바로 확인을 할 수 있다.</p>

<h3 id="how-it-works">How It Works</h3>

<ul>
  <li>
    <p>만약 <code class="language-plaintext highlighter-rouge">React component</code>만 export하는 환경이라면, Fast Refresh는 오직 그 한 파일만 업데이트를 하며, 컴포넌트를 다시 렌더링 해준다. 해당 파일 안에서는 style, logic, handler, effects 등 아무거나 편집을 해도 된다!</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">React component</code>가 아닌 파일을 편집한다면, Fast Refresh는 두 파일 모두와 import 된 다른 파일들을 재실행 할 것이다. 예를들어, <code class="language-plaintext highlighter-rouge">Button.tsx</code>와 <code class="language-plaintext highlighter-rouge">Modal.tsx</code>가 <code class="language-plaintext highlighter-rouge">theme.tsx</code>를 import 한다면, <code class="language-plaintext highlighter-rouge">theme.tsx</code>를 편집하게 되면, 두 컴포넌트 다 업데이트가 된다.</p>
  </li>
  <li>
    <p>만약 React 구조에서 벗어난 import 파일을 편집하게 된다면, Fast Refresh는 full reload를 어쩔 수 없이 하게된다. 예를들어, 만약 상수 component를 export 하지만, non-React utility file이 import 되어 있다면 파일의 위치를 바꾸어야된다.</p>
  </li>
</ul>

<h3 id="error-resillience">Error Resillience</h3>

<h4 id="syntax-errors">Syntax Errors</h4>

<p>만약 개발중에 syntax error가 나온다면, 수정 후 파일을 저장하면 바로 적용이 된다. 오류는 자동으로 없어지고, 앱을 재로딩할 필요도 없다.</p>

<table>
  <tbody>
    <tr>
      <td>컴포넌트의 상태정보 또한 잃지 않는다.</td>
    </tr>
  </tbody>
</table>

<h4 id="runtime-errors">Runtime Errors</h4>

<p>만약 런타임 에러가 나는 코드를 짜버렸다면, contextual overlay가 나온다. 에러를 고치면 바로 overlay가 없어지면서 앱이 재로딩이 된다.</p>

<p>컴포넌트의 상태정보는 렌더링을 하지 않았을 시 저장된다. 만약 렌더링 중에 에러가 나왔다면, 리액트는 업데이트된 코드로 재구동 한다.</p>

<p>만약 앱에 <code class="language-plaintext highlighter-rouge">error boundaries</code>가 설정 되어있다면, 렌더링 에러 이후 렌더링하려고 바로 재시도를 한다. 즉 <code class="language-plaintext highlighter-rouge">error boundary</code>가 설정되어 있다면, 루트의 앱 상탲정보를 항상 재설정 해주는 수고를 겪지 않아도 된다. 하지만, <code class="language-plaintext highlighter-rouge">error boundary</code>가 너무 세분화되면 안된다. 보통 React production에 많이 사용되고, 의도적으로 사용되어야 한다.</p>

<h3 id="limitations">Limitations</h3>

<p>Fast Refresh는 컴포넌트를 수정시에도 local React state를 유지하려고 노력한다.</p>

<table>
  <tbody>
    <tr>
      <td>안전하다고 판단될떄만 사용해야됨!</td>
    </tr>
  </tbody>
</table>

<p>local state가 자주 재설정 되는 이유는 다음과 같다.</p>

<ul>
  <li>
    <p>Local State는 클래스 컴포넌트에서 예약되어지지 않는다.</p>
  </li>
  <li>
    <p>편집하려는 파일이 다른 export된 리액트 컴포넌트를 사용하고 있을 수 도 있다.</p>
  </li>
  <li>
    <p>파일이 <code class="language-plaintext highlighter-rouge">HOC</code>같은 상위의 컴포넌트를 export 할 수 있다. 만약 리턴된 형태가 class라면 상태는 리셋된다.</p>
  </li>
  <li>
    <p>익명 화살표함수는 Fast Refresh를 local component state에 저장하지 않는다. 더 큰 코드인 경우에는 <code class="language-plaintext highlighter-rouge">name-default-component</code>를 사용 할 수 있다.</p>
  </li>
</ul>

<h3 id="tips">Tips</h3>

<p>Fast Refresh는 React local state를 함수 컴포넌트로 예약한다</p>

<table>
  <tbody>
    <tr>
      <td>만약 강제로 상태를 초기화하고 싶을 수가 있다. <code class="language-plaintext highlighter-rouge">// @refresh reset</code>과 같이 초기화 할 수 있다.</td>
    </tr>
  </tbody>
</table>

<h3 id="fast-refresh-and-hooks">Fast Refresh and Hooks</h3>

<p>가능하다면 Fast Refresh는 수정중에 컴포넌트에 상태 정보를 저장한다. 특히 <code class="language-plaintext highlighter-rouge">useState</code> 와 <code class="language-plaintext highlighter-rouge">useRef</code> 같은 경우에, 인자나 Hook call을 하지 않는 이상 이전값을 저장하고 있다.</p>

<p><code class="language-plaintext highlighter-rouge">useEffect</code>, <code class="language-plaintext highlighter-rouge">useMemo</code>, <code class="language-plaintext highlighter-rouge">useCallback</code> 같은 의존성이 있는 Hook 같은 경우에는, Fast Refresh중에 항상 update 된다. 이러한 의존성들은 Fast Refresh가 일어나고 있는중에 무시된다. 예를들어, <code class="language-plaintext highlighter-rouge">useMemo(() =&gt; x * 2, [x])</code> 가 <code class="language-plaintext highlighter-rouge">useMemo(() =&gt; x * 10, [x])</code> 로 변환다면, x가 변하지 않았음에도 불구하고 재실행 된다.</p>

<p>위와 같은 방법은 예상치못한 결과를 낳을 수 있다. 예를들어 <code class="language-plaintext highlighter-rouge">uesEffect</code>가 빈 배열을 줄 수 도 있다. 하지만, 이런 탄력적인 코드를 사용하는것은 좋은 연습이 된다.</p>

<h2 id="typescript">TypeScript</h2>

<h3 id="typescript로-npx-설정하는법">TypeScript로 npx 설정하는법</h3>

<p>새로 설정하는것이라면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx create-next-app@latest <span class="nt">--ts</span>
<span class="c"># or</span>
yarn create next-app <span class="nt">--typescript</span>
<span class="c"># or</span>
pnpm create next-app <span class="nt">--</span> <span class="nt">--ts</span>
</code></pre></div></div>

<p>이미 있는 프로젝트에 삽입한다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">touch </span>tsconfig.json
</code></pre></div></div>

<h3 id="static-generation--server-side-rendering">Static Generation &amp; Server-side Rendering</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">GetStaticProps</span><span class="p">,</span> <span class="nx">GetStaticPaths</span><span class="p">,</span> <span class="nx">GetServerSideProps</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStaticProps</span><span class="p">:</span> <span class="nx">GetStaticProps</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getStaticPaths</span><span class="p">:</span> <span class="nx">GetStaticPaths</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getServerSideProps</span><span class="p">:</span> <span class="nx">GetServerSideProps</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="api-routing">API Routing</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">NextApiResponse</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">(</span><span class="nx">req</span><span class="p">:</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">NextApiResponse</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John Doe</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>혹은</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">NextApiResponse</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">(</span><span class="nx">req</span><span class="p">:</span> <span class="nx">NextApiRequest</span><span class="p">,</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">NextApiResponse</span><span class="o">&lt;</span><span class="nx">Data</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">John Doe</span><span class="dl">"</span> <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p>와 같이 사용 할 수 있다.</p>

<h3 id="custom-app">Custom <code class="language-plaintext highlighter-rouge">App</code></h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">AppProps</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/app</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">}:</span> <span class="nx">AppProps</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="ignoring-typescript-errors">Ignoring TypeScript Errors</h3>

<p>Next.js는 TypeScript 에러가 존재 할 시 build 에서 오류를 낸다.</p>

<p>만약 이러한 오류에도 불구하고 사용을 하고 싶다면 다음과 같이 사용하면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">next.config.js</code>에서 <code class="language-plaintext highlighter-rouge">ignoreBuildErrors</code>를 켜주면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//next.config.js</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">typescript</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// !! WARN !!</span>
    <span class="c1">// Dangerously allow production builds to successfully complete even if</span>
    <span class="c1">// your project has type errors.</span>
    <span class="c1">// !! WARN !!</span>
    <span class="na">ignoreBuildErrors</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Static File Serving]]></summary></entry><entry><title type="html">NEXT-Optimization</title><link href="http://localhost:4000/next.js/2022/05/04/next-optimization.html" rel="alternate" type="text/html" title="NEXT-Optimization" /><published>2022-05-04T00:00:00+09:00</published><updated>2022-05-04T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/05/04/next-optimization</id><content type="html" xml:base="http://localhost:4000/next.js/2022/05/04/next-optimization.html"><![CDATA[<h2 id="image-component-and-image-optimization">Image Component and Image Optimization</h2>

<p><code class="language-plaintext highlighter-rouge">next/image</code> 에서의 Next의 이미지 컴포넌트는 HTML에서 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 의 연장선이라 볼 수 있다. 더 좋은 Web 환경을 위해 더 좋은 효율과 압축성을 보여준다. 이러한 효율성은 웹사이트 사용에 있어 UX 적으로 도움이 된다.</p>

<blockquote>
  <p>SEO 측면에서도 도움이 된다</p>
</blockquote>

<p>이러한 효율성은 크게 4가지로</p>

<ol>
  <li>
    <p>Improve Perforamce : 모든 장치마다 최신 이미지 포맷을 사용하여 정확한 사이즈를 전달한다</p>
  </li>
  <li>
    <p>Visual Stability : CLS(Cumulative Layout Shift)를 방지한다</p>
  </li>
</ol>

<blockquote>
  <p>CLS란 누적 레이아웃 변경으로, 웹페이지를 보는 사용자에게 예상치 못한 화면 변환이 나타나는 빈도 수</p>
</blockquote>

<ol>
  <li>
    <p>Faster Page Loads : 이미지가 <code class="language-plaintext highlighter-rouge">viewport</code>에 접근 시 로딩되어, 빠르고, 로딩 전 blur-up placeholder 를 설정 할 수 있다.</p>
  </li>
  <li>
    <p>Asset Flexibility : 다른 서버에 이미지가 있는 경우에도, 원하는대로 이미지 리사이징이 자유롭다</p>
  </li>
</ol>

<h3 id="local-images">Local Images</h3>

<p>이미지의 예제는 다음과 같다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">profilePic</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../public/me.png</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="p">{</span><span class="nx">profilePic</span><span class="p">}</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="c1">// width={500} automatically provided</span>
        <span class="c1">// height={500} automatically provided</span>
        <span class="c1">// blurDataURL="data:..." automatically provided</span>
        <span class="c1">// placeholder="blur" // Optional blur-up while loading</span>
      <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">import</code> 하는 과정이 정적이 되어야 build 과정에서 분석이 되기에 <code class="language-plaintext highlighter-rouge">await import()</code> 혹은 <code class="language-plaintext highlighter-rouge">require()</code>같은 동적인 행동은 지원하지 않는다.</p>

<table>
  <tbody>
    <tr>
      <td>width 와 height 가 자동으로 고정 된 이유는 CLS를 방지하기 위함이다</td>
    </tr>
  </tbody>
</table>

<h3 id="remote-images">Remote Images</h3>

<p>외부에 있는 이미지를 사용하기 위해서는 <code class="language-plaintext highlighter-rouge">src</code>로 위치를 잘 가져와야한다. Next.js같은 경우 build 과정에서 외부로 접근 할 권한이 없으므로 아까 전과는 달리 <code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, <code class="language-plaintext highlighter-rouge">blurDataURL</code> 을 넣어 줘야한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="nx">width</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">height</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
      <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="domains">Domains</h3>

<p>가끔 외부의 이미지를 사용하면서도 Next.js의 최적화 기법을 사용하고 싶을 수 있다. <code class="language-plaintext highlighter-rouge">loader</code>를 기본으로 두고, <code class="language-plaintext highlighter-rouge">src</code>에 절대경로 URL을 넣어 사용 할 수 있다.</p>

<p>어플을 외부로부터 보호하기 위해 아래와 같이 <code class="language-plaintext highlighter-rouge">next.config.js</code>파일을 사용하여 외부 도메인으로 바로 접근하는것을 막을 수 있다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="k">export</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">images</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">domains</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">071yoon.github.io</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">github.com/071yoon</span><span class="dl">"</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="loaders">Loaders</h3>

<p>앞서 <a href="#remote-images">Remote Images</a> 에서처럼 URL의 부분만 쓰는 경우 (<code class="language-plaintext highlighter-rouge">'/me.png'</code>) 는 <code class="language-plaintext highlighter-rouge">next/image</code> 의 loader의 구조상 가능한 부분이다.</p>

<p><code class="language-plaintext highlighter-rouge">Loader</code>는 이미지의 URL을 만들어 주는 기능을 한다. 제공된 <code class="language-plaintext highlighter-rouge">src</code>에 root domain 까지 추가 후 image를 다른 사이즈로 여러 URL을 만들어 연결 요청을 보낸다. 이러한 URL들은 srcset을 만들어내고, 방문자는 각자 <code class="language-plaintext highlighter-rouge">viewport</code>에 맞는 사이즈의 이미지를 볼 수 있게 된다.</p>

<p><code class="language-plaintext highlighter-rouge">Next.js</code>의 default loader는 <code class="language-plaintext highlighter-rouge">built-in Image Optimization API</code>를 사용했고, 웹의 어디에서나 이미지를 최적화 할 수 있었고, 바로 Next.js의 웹 서버에 보냈다. 만약 이미지를 CDN 이나 이미지 서버에 바로 보내고 싶다면, <code class="language-plaintext highlighter-rouge">built-in loader</code>를 사용하거나, 자바스크립트에서 따로 추가를 해야된다.</p>

<p>이러한 로더는 Application Level 에서 이미지당 하나씩 정의가 된다.</p>

<h3 id="priority">Priority</h3>

<p>이미지에 <code class="language-plaintext highlighter-rouge">priority</code>란 속성을 넣어 매 페이지마다 LCP element를 가지게 할 수 있다. 즉 Next.js가 이미지 로딩의 우선순위를 둘 수 있다.</p>

<blockquote>
  <p>LCP : Largest Contentful Paint로 페이지의 메인 컨텐츠가 로드되었을 가능성이 있을 때 페이지 로드 타임라인에 해당 시점을 표시하여 사용자가 감지하는 로드 속도를 측정할 수 있는 메트릭스 -&gt; LCP가 빠르다 = 해당 페이지를 사용할 수 있다</p>
</blockquote>

<p>LCP element는 보통 viewport 에서 가장 큰 이미지거나 텍스트로 본다. <code class="language-plaintext highlighter-rouge">next dev</code> 실행시에, <code class="language-plaintext highlighter-rouge">&lt;Image&gt;</code> 에 <code class="language-plaintext highlighter-rouge">priority</code>가 설정되어 있지 않다면, Next는 자체적으로 경고창을 띄운다. 예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">My</span> <span class="nx">Homepage</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Image</span>
        <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">/me.png</span><span class="dl">"</span>
        <span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">Picture of the author</span><span class="dl">"</span>
        <span class="nx">width</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">height</span><span class="o">=</span><span class="p">{</span><span class="mi">500</span><span class="p">}</span>
        <span class="nx">priority</span>
      <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Welcome</span> <span class="nx">to</span> <span class="nx">my</span> <span class="nx">homepage</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="image-sizing">Image Sizing</h2>

<p>이미지가 성능에 영향을 미치는 경우는 보통 <code class="language-plaintext highlighter-rouge">layout shift</code>가 일어났을 때 이다. 이러한 <code class="language-plaintext highlighter-rouge">layout shift</code>는 이미지가 로딩되면서 다른 요소들을 밀치고 삽입되는 경우이다. 이런 문제는 Client 입장에서 매우 불편하고 <code class="language-plaintext highlighter-rouge">CLS</code>를 일으킨다. 이러한 문제를 해결하는법은 언제나 이미지의 사이즈를 조정하는것이다. 그럼으로써 브라우저딴에서 항상 로딩되기 전에 이미지의 자리를 예약 할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">next/image</code>가 항상 좋은 성능을 위해 디자인 되었으므로, <code class="language-plaintext highlighter-rouge">layout shift</code> 현상은 일어나서는 안된다. 즉 아래 세가지 규칙중 하나를 사용해야 된다.</p>

<ol>
  <li>
    <p>static import를 사용</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">width</code> 와 <code class="language-plaintext highlighter-rouge">height</code> 요소를 사용</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout="fill"</code>을 사용</p>
  </li>
</ol>

<p>3번 같은 경우 내 이미지의 사이즈를 모를 때 사용한다. parent element 사이즈만큼 image가 사이즈될 수 있게 설정하게 된다. 그럼 <code class="language-plaintext highlighter-rouge">objectFit property</code> 를 <code class="language-plaintext highlighter-rouge">fill</code>, <code class="language-plaintext highlighter-rouge">contain</code>, <code class="language-plaintext highlighter-rouge">cover</code>, <code class="language-plaintext highlighter-rouge">objectPosition property</code>와 함께 사용하여 얼마나 이미지가 차지해야되는지 알 수 있다.</p>

<p>만약 내가 아는 소스에서 이미지를 가져오는 것이라면, image의 pipeline을 일반화 하는것이 좋다.</p>

<p>만약 API call 을 사용하여 이미지를 가져온다면, API call 을 중간에 수정하여 URL과 함께 이미지의 크기를 리턴하는것이 가능하다.</p>

<p>만약 위 3가지의 방법을 사용하지 않는다면 <code class="language-plaintext highlighter-rouge">next/image</code>는 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>와 차이가 없다.</p>

<h2 id="styling">Styling</h2>

<p>Styling 같은 경우에 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>와 크게 다를것 없지만, 주의사항이 몇가지 존재한다.</p>

<ol>
  <li>
    <p>올바른 layout mode 설정하기</p>
  </li>
  <li>
    <p>이미지를 className으로 지정하기 (DOM 구조에 맞추지 말것)</p>
  </li>
</ol>

<p>보통 layout에서 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> 는 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>에 둘러싸여 있다. 이러한 추가적인 <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>은 layout shift를 만드는 주된 원인이다. 즉 <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code>에 <code class="language-plaintext highlighter-rouge">className</code>을 붙여 CSS Module을 사용하는것이 일반적이다. 혹은, <code class="language-plaintext highlighter-rouge">className</code>을 사용하여 <code class="language-plaintext highlighter-rouge">global stylesheet</code>를 사용할 수 도 있다.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout='fill'</code>을 한다면 <code class="language-plaintext highlighter-rouge">position:relative</code> 도 함께 사용해야된다</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">layout='responsive'</code>를 사용할 시 <code class="language-plaintext highlighter-rouge">display:block</code>을 같이 사용할 것</p>
  </li>
</ol>

<h2 id="font-optimization">Font Optimization</h2>

<p>버전 <code class="language-plaintext highlighter-rouge">10.2</code> 부터 Next.js 는 built-in web font optimization 을 지원하게 되었다.</p>

<p>일반적으로 Next.js는 자동으로 CSS를 빌드타임에 넣어, 추가적인 반복작업을 피한다. 이렇게 함으로써 FCP 와 LCP에 도움이 된다.</p>

<table>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">FCP(First Contentful Paint)</code>란 페이지가 로드되기 시작한 시점부터 컨텐츠의 일부가 화면에 렌더링 될 때까지의 시간 <code class="language-plaintext highlighter-rouge">LCP(Largest Contentful Paint)</code>란 페이지가 로드되기 시작한 시점부터 뷰포트 내부의 가장 큰 이미지 또는 텍스트의 렌더링까지 걸리는 시간</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before</span>
<span class="o">&lt;</span><span class="nx">link</span>
  <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span>
  <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">stylesheet</span><span class="dl">"</span>
<span class="o">/&gt;</span>

<span class="c1">// After</span>
<span class="o">&lt;</span><span class="nx">link</span> <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">preconnect</span><span class="dl">"</span> <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.gstatic.com</span><span class="dl">"</span> <span class="nx">crossorigin</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">style</span> <span class="nx">data</span><span class="o">-</span><span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span><span class="o">&gt;</span>
  <span class="p">@</span><span class="nd">font</span><span class="o">-</span><span class="nx">face</span><span class="p">{</span><span class="nx">font</span><span class="o">-</span><span class="nx">family</span><span class="p">:</span><span class="dl">'</span><span class="s1">Inter</span><span class="dl">'</span><span class="p">;</span><span class="nx">font</span><span class="o">-</span><span class="nx">style</span><span class="p">:</span><span class="nx">normal</span><span class="p">...</span>
<span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span></code></pre></div></div>

<h3 id="usage">Usage</h3>

<p>Webfont 를 Next.js에 넣으려면 <code class="language-plaintext highlighter-rouge">Document</code>안에 폰트를 삽입하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/_document.js</span>

<span class="k">import</span> <span class="nx">Document</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Html</span><span class="p">,</span> <span class="nx">Head</span><span class="p">,</span> <span class="nx">Main</span><span class="p">,</span> <span class="nx">NextScript</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/document</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">MyDocument</span> <span class="kd">extends</span> <span class="nx">Document</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Html</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">Head</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">link</span>
            <span class="nx">href</span><span class="o">=</span><span class="dl">"</span><span class="s2">https://fonts.googleapis.com/css2?family=Inter&amp;display=optional</span><span class="dl">"</span>
            <span class="nx">rel</span><span class="o">=</span><span class="dl">"</span><span class="s2">stylesheet</span><span class="dl">"</span>
          <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="sr">/Head</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">Main</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">NextScript</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/Html</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">MyDocument</span><span class="p">;</span>
</code></pre></div></div>

<p>특이한점은 해당 폰트는 특정한 페이지에만 사용되므로 <code class="language-plaintext highlighter-rouge">next/head</code>를 사용하지 않는다는 점이다. 현재 Automatic Webfont Optimization 은 Google Fonts에 의해 지원된다.</p>

<h3 id="disabling-optimization">Disabling Optimization</h3>

<p>Font Optimization 을 끄는 방식은 아래와 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// next.config.js</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">optimizeFonts</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Image Component and Image Optimization]]></summary></entry><entry><title type="html">NEXT-Layouts</title><link href="http://localhost:4000/next.js/2022/04/28/next-layouts.html" rel="alternate" type="text/html" title="NEXT-Layouts" /><published>2022-04-28T00:00:00+09:00</published><updated>2022-04-28T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/28/next-layouts</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/28/next-layouts.html"><![CDATA[<h2 id="layouts">Layouts</h2>

<p>React는 페이지를 컴포넌트로 나누는것이 가능하다. 이러한 컴포넌트들은 페이지간에 재사용이 가능하고, 예를 들어, 모든 페이지마다 같은 네비게이션바를 사용한다.</p>

<h3 id="single-shared-layout-with-custom-app">Single Shared Layout with Custom App</h3>

<p>만약 전체 어플에 대하여 하나의 레이아웃만 사용한다면, Custom App 을 만들어, 해당 레이아웃으로 둘러 쌀 수 있다. 해당 컴포넌트가 모든 페이지마다 재사용되므로, 이러한 컴포넌트의 상태정보는 계속 유지된다.</p>

<table>
  <tbody>
    <tr>
      <td>예를 들어, input value가 들어와도 고정된다</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Layout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/layout</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="per-page-layout">Per-Page Layout</h3>

<p>만약 여러 레이아웃이 필요한 경우에, <code class="language-plaintext highlighter-rouge">getLayout</code> 이라는 property를 사용 할 수 있다. 컴포넌트안에 getLayout을 사용해서, 표현할지 안할지로 정해서 사용 가능하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Layout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/layout</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">NestedLayout</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../components/nested-layout</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Page</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="cm">/** Your content */</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="nx">Page</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">getLayout</span><span class="p">(</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">NestedLayout</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">page</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/NestedLayout</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이렇게 선언 후 실제로 사용할 때는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Use the layout defined at the page level, if available</span>
  <span class="kd">const</span> <span class="nx">getLayout</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">||</span> <span class="p">((</span><span class="nx">page</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">page</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">getLayout</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<p>타입스크립트를 이용하면 Props의 type에 주의해야된다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">}:</span> <span class="nx">AppPropsWithLayout</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Use the layout defined at the page level, if available</span>
  <span class="kd">const</span> <span class="nx">getLayout</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">getLayout</span> <span class="o">??</span> <span class="p">((</span><span class="nx">page</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">page</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">getLayout</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="data-fetching">Data Fetching</h3>

<p>레이아웃안에, Client-Side에서 <code class="language-plaintext highlighter-rouge">useEffect</code>로 데이터를 가져올 수 도 있고, 라이브러리를 활용하여 <code class="language-plaintext highlighter-rouge">SWR</code>(React Query와 유사)로 가져올 수 도 있다. 하지만, Page가 아니기에, <code class="language-plaintext highlighter-rouge">getStaticProps</code>나 <code class="language-plaintext highlighter-rouge">getServerSideProps</code>를 사용 할 수는 없다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">useSWR</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">swr</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Navbar</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./navbar</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Footer</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./footer</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Layout</span><span class="p">({</span> <span class="nx">children</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useSWR</span><span class="p">(</span><span class="dl">"</span><span class="s2">/api/navigation</span><span class="dl">"</span><span class="p">,</span> <span class="nx">fetcher</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Failed</span> <span class="nx">to</span> <span class="nx">load</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">Navbar</span> <span class="nx">links</span><span class="o">=</span><span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">links</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">main</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/main</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Layouts]]></summary></entry><entry><title type="html">NEXT-Built-In CSS</title><link href="http://localhost:4000/next.js/2022/04/27/next-built-in-css.html" rel="alternate" type="text/html" title="NEXT-Built-In CSS" /><published>2022-04-27T00:00:00+09:00</published><updated>2022-04-27T00:00:00+09:00</updated><id>http://localhost:4000/next.js/2022/04/27/next-built-in-css</id><content type="html" xml:base="http://localhost:4000/next.js/2022/04/27/next-built-in-css.html"><![CDATA[<h2 id="global-stylesheet">Global Stylesheet</h2>

<p>프로젝트에 <code class="language-plaintext highlighter-rouge">stylesheet</code>를 추가하려면, <code class="language-plaintext highlighter-rouge">pages/_app.js</code> 라는 CSS 파일을 import 해야된다.</p>

<p>우선 다음과 같이 <code class="language-plaintext highlighter-rouge">style.css</code>를 만들었다 보면</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">body</span> <span class="p">{</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="nb">sans-serif</span><span class="p">;</span>
  <span class="nl">padding</span><span class="p">:</span> <span class="m">20px</span> <span class="m">20px</span> <span class="m">60px</span><span class="p">;</span>
  <span class="nl">max-width</span><span class="p">:</span> <span class="m">680px</span><span class="p">;</span>
  <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span> <span class="nb">auto</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 실제 page 에서 import 하면 된다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="dl">'</span><span class="s1">../style.css</span><span class="dl">'</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span><span class="o">&gt;</span> <span class="sr">/</span><span class="err">&gt;
</span><span class="p">}</span>
</code></pre></div></div>

<p>그럼 스타일이 위에서 선언한 <code class="language-plaintext highlighter-rouge">style.css</code> 처럼 적용이 된다.</p>

<table>
  <tbody>
    <tr>
      <td>global한 문제가 있기에 오직 하나만 import 해야 된다! 여기서는 <code class="language-plaintext highlighter-rouge">pages/_app.js</code></td>
    </tr>
  </tbody>
</table>

<h2 id="import-styles-from-node_modules">Import styles from <code class="language-plaintext highlighter-rouge">node_modules</code></h2>

<p>Next.js 9.5.4 버전부터는 <code class="language-plaintext highlighter-rouge">node_modules</code>에 CSS 파일을 넣는것이 가능해졌다. 만약 <code class="language-plaintext highlighter-rouge">bootstrap</code>이나 <code class="language-plaintext highlighter-rouge">nprogress</code> 같은 global stylesheet를 사용한다면, <code class="language-plaintext highlighter-rouge">pages/_app.js</code> 에서 import를 미리 해두어야 한다.</p>

<p><code class="language-plaintext highlighter-rouge">Third Party</code> 컴포넌트를 사용한다면, 다음과 같이 정의 할 수 있다.</p>

<table>
  <tbody>
    <tr>
      <td>Third Party란 프로그래밍시 도와주는 플러그인 혹은 라이브러리를 만드는 회사</td>
    </tr>
  </tbody>
</table>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// components/ExampleDialog.js</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Dialog</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reach/dialog</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">VisuallyHidden</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reach/visually-hidden</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">"</span><span class="s2">@reach/dialog/styles.css</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">ExampleDialog</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">showDialog</span><span class="p">,</span> <span class="nx">setShowDialog</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">open</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setShowDialog</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">close</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setShowDialog</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">open</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Open</span> <span class="nx">Dialog</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">Dialog</span> <span class="nx">isOpen</span><span class="o">=</span><span class="p">{</span><span class="nx">showDialog</span><span class="p">}</span> <span class="nx">onDismiss</span><span class="o">=</span><span class="p">{</span><span class="nx">close</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">close-button</span><span class="dl">"</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">close</span><span class="p">}</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">VisuallyHidden</span><span class="o">&gt;</span><span class="nx">Close</span><span class="o">&lt;</span><span class="sr">/VisuallyHidden</span><span class="err">&gt;
</span>          <span class="o">&lt;</span><span class="nx">span</span> <span class="nx">aria</span><span class="o">-</span><span class="nx">hidden</span><span class="o">&gt;</span><span class="err">×</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Hello</span> <span class="nx">there</span><span class="p">.</span> <span class="nx">I</span> <span class="nx">am</span> <span class="nx">a</span> <span class="nx">dialog</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/Dialog</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="component-level-css">Component-Level CSS</h2>

<p>Next.js는 <code class="language-plaintext highlighter-rouge">[name].module.css</code> 이라는 파일 컨벤션을 이용하여 CSS Module을 공식적으로 지원한다. CSS 모듈은 자동으로 unique class 이름을 만들어 생성하며, 이는 충돌을 방지하기 위함이다. 즉 이런식으로 사용하면, component-level 에서 사용하기 더욱 쉬워진다. 그리고 이러한 CSS Module은 파일 어디에서 import 되어도 사용 가능해진다!</p>

<p>예를들어, 재사용 가능한 <code class="language-plaintext highlighter-rouge">Button</code> 이라는 컴포넌트가 <code class="language-plaintext highlighter-rouge">components/</code>안에 있다 가정하고 다음을 보자.</p>

<p>우선 <code class="language-plaintext highlighter-rouge">components/Button.module.css</code>를 만든다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.error</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="no">white</span><span class="p">;</span>
  <span class="nl">background-color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>후, <code class="language-plaintext highlighter-rouge">components/Button.js</code>를 만들어, 방금 제작한 CSS를 import 하면 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">styles</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./Button.module.css</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">Button</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">button</span>
      <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">button</span><span class="dl">"</span>
      <span class="c1">// Note how the "error" class is accessed as a property on the imported</span>
      <span class="c1">// `styles` object.</span>
      <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">styles</span><span class="p">.</span><span class="nx">error</span><span class="p">}</span>
    <span class="o">&gt;</span>
      <span class="nx">Destroy</span>
    <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이러한 CSS Module을 사용하는것은 추가적인 기능이고, 편히 global CSS를 사용하여도 무방하다.</p>

<p>정적 build시에, 이러한 모든 CSS Module 들이 자동으로 분할되어지는데, 최종적으로 프로그램 딴에서 css 파일의 무게를 줄이기 위함이다.</p>

<h2 id="sass-support">Sass Support</h2>

<p>Next.js는 Sass도 물론 지원한다. <code class="language-plaintext highlighter-rouge">.scss</code> 와 <code class="language-plaintext highlighter-rouge">.sass</code> 둘 다 지원하며, 마찬가지로 모듈화를 하여 <code class="language-plaintext highlighter-rouge">.module.scss</code> 와 <code class="language-plaintext highlighter-rouge">.module.sass</code> 로 사용할 수 있다.</p>

<p>간단한 Sass의 예제로 보면 다음과 같다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* variables.module.scss */</span>
<span class="err">$</span><span class="nt">primary-color</span><span class="o">:</span> <span class="err">#64</span><span class="nt">FF00</span>

<span class="nd">:export</span> <span class="p">{</span>
  <span class="py">primarycolor</span><span class="p">:</span> <span class="err">$</span><span class="n">primary-color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pages/_app.js</span>
<span class="k">import</span> <span class="nx">variables</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../styles/variables.module.scss</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">MyApp</span><span class="p">({</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">pageProps</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span> <span class="nx">color</span><span class="o">=</span><span class="p">{</span><span class="nx">variables</span><span class="p">.</span><span class="nx">primaryColor</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">Component</span> <span class="p">{...</span><span class="nx">pageProps</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/Layout</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="css-in-js">CSS in JS</h2>

<p>내가 주로 사용하는 방식인 CSS-in-JS 방식이다.</p>

<p>우선 사용하려면 <code class="language-plaintext highlighter-rouge">styled-jsx</code> 파일을 번들해야하며, 목적은 <code class="language-plaintext highlighter-rouge">shadow CSS</code>를 지원하여 마치 웹 컴포넌트처럼 사용하기 위함이다. 아쉽게도 SSR를 지원하지 않고, JS만 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">styled jsx</code>의 예제는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">HelloWorld</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="nx">Hello</span> <span class="nx">world</span>
      <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">scoped</span><span class="o">!&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">style</span> <span class="nx">jsx</span><span class="o">&gt;</span><span class="p">{</span><span class="s2">`
        p {
          color: blue;
        }
        div {
          background: red;
        }
        @media (max-width: 600px) {
          div {
            background: blue;
          }
        }
      `</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">style</span> <span class="nb">global</span> <span class="nx">jsx</span><span class="o">&gt;</span><span class="p">{</span><span class="s2">`
        body {
          background: black;
        }
      `</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">HelloWorld</span><span class="p">;</span>
</code></pre></div></div>]]></content><author><name>071yoon</name></author><category term="next.js" /><category term="next.js" /><category term="javascript" /><category term="web" /><category term="study" /><summary type="html"><![CDATA[Global Stylesheet]]></summary></entry></feed>