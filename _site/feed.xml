<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-04-01T14:03:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YeongGi’s tech blog</title><subtitle>This is YeongGi&apos;s tech blog. I post IT related items.</subtitle><author><name>071yoon</name></author><entry><title type="html">Github Action starter 오류 수정 이야기</title><link href="http://localhost:4000/til/2024/04/01/opensource-github-action.html" rel="alternate" type="text/html" title="Github Action starter 오류 수정 이야기" /><published>2024-04-01T00:00:00+09:00</published><updated>2024-04-01T00:00:00+09:00</updated><id>http://localhost:4000/til/2024/04/01/opensource-github-action</id><content type="html" xml:base="http://localhost:4000/til/2024/04/01/opensource-github-action.html"><![CDATA[<h2 id="서론">서론</h2>

<p>github action 의 starter workflows는 github의 기본적으로 page를 deploy 할 시 등 가장 기본적으로 사용되는 workflow이다. 아마 많은 FE 개발자 혹은 github pages를 통하여 블로그를 만드시는 분들은 많이들 사용해 봤을 것이라 생각된다.</p>

<p>보통 이러한 workflow는 보통, github deploy 페이지에서 GUI로 선행되어 repository 까지 갈 일이 보통 없다. 그런데, 꽤나 예전에 평소처럼 github page에서 Next.js deploy를 하였는데 문제가 생겼던 경험이 있다. 해당 문제를 타고보니 starter-workflows 에서 최신 Next.js를 지원하지 않아서 문제가 발생했고, 현재 수정이 되었는데, 해결과정을 서술해보도록 하겠다.</p>

<h2 id="문제-파악">문제 파악</h2>

<p>우선 문제는 크게 두가지였다.</p>

<ol>
  <li>Next.js v.14에서는 node 버전을 공식적으로 node v.18 이상을 사용해야된다 &gt; <a href="https://nextjs.org/docs/pages/building-your-application/upgrading/version-14">참고</a></li>
  <li>next config 에서 default output을 export로 지정하고, static HTML export를 따로 실행하지 않는것으로 바뀌었다 &gt; <a href="https://nextjs.org/docs/app/building-your-application/deploying/static-exports">참고</a></li>
</ol>

<p>해당 두 가지 문제를 해결하기 위해서는 next.config.js 파일도 수정해야 하지만 github action workflow에도 수정이 필수적으로 필요했다.</p>

<p>5개월 전 삽질의 흔적을 보니 로컬에서는 변경 후 잘 작동 했던것으로 보인다.</p>

<p><img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/4d74aac6-1196-4e46-98ed-708d89d34171" alt="image" /></p>

<p>여기서 나의 문제는 해결 되었지만, 아무래도 공식 workflow 에서 수정하지 않으면 나와 비슷한 사람들이 많을 것 같아 repository 까지 들어가보며 확인을 해 보았다.</p>

<h2 id="공식적으로-해결해보기">공식적으로 해결해보기</h2>

<p>우선 꽤나 많은 사람들이 사용하는 workflow template 인데, 나만 문제가 생겼을거라 생각하지 않아 pull request 를 살펴보니 비슷한 문제들이 많이 있었다.</p>

<blockquote>
  <p>문제를 기술 및 해결한 <a href="https://github.com/actions/starter-workflows/pull/2204">PR LINK</a></p>
</blockquote>

<p>여기서는 앞서 문제 파악에서의 2번 문제 즉 yaml 에서 static HTML export를 하는 부분을 삭제 해주기는 하였지만, node 버전 수정을 하지는 않았다. 이 부분은 편하게 댓글을 달아 수정 요청사항을 추가해서 반영토록 도와주웠다.</p>

<p><img width="933" alt="image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/e43305c9-5436-4e79-849d-ba99e51a33ad" /></p>

<p>그리고 무려 PR이 올라간지 5개월이 지난 현재 잘 수정되었다고 메일이 왔다.</p>

<p><img width="952" alt="image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/6af5eb93-4eec-4c66-a4c9-e5c73f0fb430" /></p>

<p>한가지 아쉬웠던 점은, 따로 PR로 빼서 날렸으면 나도 contributor badge를 받을 수 있었을텐데, 귀찮아서 댓글만 남기고 넘어갔던 것 정도,,</p>

<blockquote>
  <p>그리고 진짜 간단한 PR인데, 되게 여유롭게 일 하시는듯</p>
</blockquote>

<p>여튼 좋은 일 하나 하기 성공</p>]]></content><author><name>071yoon</name></author><category term="TIL" /><category term="TIL" /><summary type="html"><![CDATA[서론]]></summary></entry><entry><title type="html">Firebase JWT 에러</title><link href="http://localhost:4000/web/2024/03/28/firebase-jwt.html" rel="alternate" type="text/html" title="Firebase JWT 에러" /><published>2024-03-28T00:00:00+09:00</published><updated>2024-03-28T00:00:00+09:00</updated><id>http://localhost:4000/web/2024/03/28/firebase-jwt</id><content type="html" xml:base="http://localhost:4000/web/2024/03/28/firebase-jwt.html"><![CDATA[<h2 id="문제-확인">문제 확인</h2>

<p>최근 운영하고 있던 서버 중 하나에 정말 큰 문제가 생겼다. 갑자기 모든 화면이 보이지 않는다는것.</p>

<p>현재 DB를 Firebase를 쓰고 있었는데, 혹시나 firebase DB를 너무 많이 써서 초기화를 시켜버리거나 하지는 않았을까? 백업을 안한지 오래됐는데 혹시 파일이 날라가면 어떡하지 두근두근 거리며 확인을 했더니 데이터는 다행히 살아있었고, 즉 firebase 문제는 아니였다.</p>

<p>모든 데이터가 보이지 않고, 작성/수정/삭제 등 모든 기능이 정지되었다. 흠,, 그렇게 되면 사실 데이터를 가져오는 곳에서 문제가 생겼다는 것이고 높은 확률로 fetch 부분이였기에 그부분을 자세히 살펴보았다. 그러던 중 이러한 코드를 발견</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">auth</span> <span class="o">=</span> <span class="p">(</span><span class="nx">token</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">decoded</span> <span class="o">=</span> <span class="nx">jwtDecode</span><span class="p">(</span><span class="nx">token</span><span class="p">,</span> <span class="p">{</span> <span class="na">header</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
  <span class="k">if</span> <span class="p">(</span>
    <span class="nx">decoded</span><span class="p">.</span><span class="nx">kid</span> <span class="o">===</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NEXT_PUBLIC_FIREBASE_CERT_ONE</span> <span class="o">||</span>
    <span class="nx">decoded</span><span class="p">.</span><span class="nx">kid</span> <span class="o">===</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NEXT_PUBLIC_FIREBASE_CERT_TWO</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>꽤나 최근에 작성된 코드였는데, jwt 인증 토큰을 가지고 kid 를 비교해서 올바른 token인지 확인하는 과정이였다.</p>

<p>해당 코드를 작성하게된 계기는 웹사이트 인증수단이 필요했고, 모든 get/update/delete 등 firebase api를 활용할 때 인가를 주기 위해서였다.</p>

<p>그리고 firebase website 내에서도 <code class="language-plaintext highlighter-rouge">마지막으로, 토큰의 kid 클레임에 해당하는 비공개 키로 ID 토큰이 서명되었는지 확인합니다.</code> 이렇게 작성이 되어 있어, 서명 확인을 조금 단순하게 kid key 값을 가져와 env로 설정하여 진행했었는데, 바로 이 부분에서 문제가 생겼다.</p>

<h2 id="해결">해결</h2>

<p>앞 코드의 <code class="language-plaintext highlighter-rouge">NEXT_PUBLIC_FIREBASE_CERT_ONE/TWO</code> 같은 경우는 <a href="https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com">google api 사이트</a>에서 직접 가져온 kid 코드였다.</p>

<p>작성 당시에는 문제가 없을거라 생각했는데, google api가 똑똑한것인지 kid 코드를 주기적으로 변경하여 생긴 문제였다. 임시방편으로 웹사이트에 들어가 새로운 kid로 env를 수정하니 생긴 오류는 막을 수 있었다.</p>

<p>다음은 주기적으로 같은 문제가 재발하지 않기위한 코드 수정이 남았다.</p>

<p>수정사항은 간단하다. google api 서버에 접속하여 kid를 실시간으로 가져온 후 jwt decode를 한 kid와 매칭시켜본다. 여기서 추가되는 부분은 <code class="language-plaintext highlighter-rouge">매번 google api 서버에 요청하기보다 한번 가져온 후 재사용할 수 있었으면 좋겠다</code> 였다.</p>

<p>나 혼자 작성해도 크게 문제될 것 없는 쉬운 문제이지만 reference는 언제나 좋으니 github을 뒤적거리다 좋은 소스를 발견했다.
바로 이름부터 신뢰가 가는 <a href="https://github.com/kriasoft/web-auth-library/blob/42a722e4cedc09ea2a86f92fe5aed73b19e5de94/google/credentials.ts#L43">web-auth-library</a>.</p>

<p>대충 보아하니, auth 인증이 된 유저 instance를 만들어 사용하는 방법인것 같은데, 내 서비스와 살짝 상황이 달랐다. 그래도, 싱글톤 instance로 관리하면 재요청 하지 않고 계속 쓰일 수 있을 것 같아 FirebaseCert Class를 만들어 관리하기로 했다.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">async</span> <span class="nx">getCertificateFromServer</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">CLIENT_AUTH_URL</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">setCert</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>대충 이런식으로 initialize를 1회 해주는 class를 만들어</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">firebaseCert</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FirebaseCert</span><span class="p">();</span>

<span class="kd">const</span> <span class="nx">auth</span> <span class="o">=</span> <span class="p">(</span><span class="nx">token</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">decoded</span> <span class="o">=</span> <span class="nx">jwtDecode</span><span class="p">(</span><span class="nx">token</span><span class="p">,</span> <span class="p">{</span> <span class="na">header</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">firebaseCert</span><span class="p">.</span><span class="nx">getCert</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="nx">decoded</span><span class="p">.</span><span class="nx">kid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">firebaseCert</span><span class="p">.</span><span class="nx">getCert</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">decoded</span><span class="p">.</span><span class="nx">kid</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>이렇게 사용하도록 수정했다.</p>

<p>테스트해보니 fetch도 최초 1회만 하고, 페이지 전환을 하여도 client 세션이 만료되거나 새로고침 전에는 재 요청 하지 않음을 확인할 수 있었다.</p>

<p>오늘의 문제 해결 끝</p>]]></content><author><name>071yoon</name></author><category term="web" /><category term="web" /><summary type="html"><![CDATA[문제 확인]]></summary></entry><entry><title type="html">SQL 함수 알아보기</title><link href="http://localhost:4000/sql/2024/03/02/sql-functions.html" rel="alternate" type="text/html" title="SQL 함수 알아보기" /><published>2024-03-02T00:00:00+09:00</published><updated>2024-03-02T00:00:00+09:00</updated><id>http://localhost:4000/sql/2024/03/02/sql-functions</id><content type="html" xml:base="http://localhost:4000/sql/2024/03/02/sql-functions.html"><![CDATA[<h2 id="sql-함수-알아보기">SQL 함수 알아보기</h2>

<p>평소에 SELECT, INSERT, ALTER, CREATE 등 일반적인 DML, DDL문법만 사용하였는데 일을 하면서 다양한 문법들을 마주하고 공부하고 필요함이 느껴져 조금이나마 정리를 해보자고 한다</p>

<h2 id="coalesce">COALESCE</h2>

<blockquote>
  <p>NULl이 아닌 첫번째 값을 반환하는 함수</p>
</blockquote>

<p>행을 보고 COALESCE(col1, col2, col3) 이라면, 차례대로 col1, col2, col3 값을 보며 제일 먼저 null이 아닌 값을 반환하게 된다.</p>

<p>마지막 값에 static한 값을 넣어두면, NVL과 비슷한 형태로 사용할 수 있다.</p>

<h2 id="rollup">ROLLUP</h2>

<blockquote>
  <p>합계를 쉽게 사용하기 위해 사용</p>
</blockquote>

<ul>
  <li>GROUP BY ROLLUP</li>
  <li>GROUP BY GROUP_COLUMN WITH ROLLUP</li>
</ul>

<p>두가지 형태로 사용 가능하며, <code class="language-plaintext highlighter-rouge">GROUP BY</code> 를 하여 합계에 대한 새로운 row를 생성해준다.</p>

<h2 id="decode">DECODE</h2>

<p>ORACLE에서 사용하는 CASE WHEN 문법</p>

<p><code class="language-plaintext highlighter-rouge">DECODE(GENDER, 'M', 'Male', 'F', 'Female', 'others')</code></p>

<p>라 하면, GENDER가 ‘M’ 이면 ‘Male’, ‘F’면 ‘Female’, 둘 다 아니면 ‘others’인 문법</p>

<h2 id="character--varchar">CHARACTER / VARCHAR</h2>

<p>CHAR인 경우 크기가 고정되며, 만약 부족하다면 우측에 공백을 넣어 사이즈를 무조건 맞춘다.</p>

<p>VARCHAR인 경우, 가변 길이기에 공백을 넣는 방식이 아님.</p>

<h2 id="connect-by">CONNECT BY</h2>

<blockquote>
  <p>CONNECT BY, LEVEL, PRIOR 등 다양한 문법 세트
https://vaert.tistory.com/166 이사람의 블로그를 보면 쉽게 이해가 가능하다</p>
</blockquote>

<p>헷갈리는걸 정리 한번만 하자면 PRIOR 순서.</p>

<p><code class="language-plaintext highlighter-rouge">connect by 직속상사 = prior 직원</code> 이라면 <code class="language-plaintext highlighter-rouge">방금 전 행의 직원 값이 현재 행의 직속상사 값인 모든 행을 찾아라</code>
즉 이 순서라면 직속상사가 상위 계층(LEVEL 1) 으로 뻗어져가는 노드의 형태가 되고,</p>

<p><code class="language-plaintext highlighter-rouge">connect by prior 직속상사 = 직원</code> 이라면 <code class="language-plaintext highlighter-rouge">방금 전 행의 직속상사 값이 현재 행의 직원 값인 모든 행을 찾아라</code>
이 순서라면 제일 아래 직급이 상위의 계층이 되는 형태로 정렬이 된다.</p>

<h2 id="rank">RANK</h2>

<p>RANK는 <code class="language-plaintext highlighter-rouge">RANK() OVER()</code> 형태로 사용되며, 순위를 지정하는데 사용된다.
RANK 자체가 순위를 지정하기에, OVER 구문에 ORDER BY 로 순서를 지정해주어야 한다.</p>

<blockquote>
  <p>ex. RANK() OVER(ORDER BY SOMETHING DESC) as rank</p>
</blockquote>

<p>일반 RANK는 중복값이 들어갔을 경우, (1, 1, 3, 4, 5..) 이런 방향이라면 DENSE_RANK는 (1, 1, 2, 3, 4) 이렇게 중복과 순위의 측정 방식에 따라 다르다.</p>

<p>공부하다 새로운것이 생기면 더 정리할 것</p>]]></content><author><name>071yoon</name></author><category term="sql" /><category term="sql" /><summary type="html"><![CDATA[SQL 함수 알아보기]]></summary></entry><entry><title type="html">객체지향의 사실과 오해</title><link href="http://localhost:4000/book/2024/01/28/essence-of-oop.html" rel="alternate" type="text/html" title="객체지향의 사실과 오해" /><published>2024-01-28T00:00:00+09:00</published><updated>2024-01-28T00:00:00+09:00</updated><id>http://localhost:4000/book/2024/01/28/essence-of-oop</id><content type="html" xml:base="http://localhost:4000/book/2024/01/28/essence-of-oop.html"><![CDATA[<h2 id="객체지향의-사실과-오해">객체지향의 사실과 오해</h2>

<p>약 2년전에 사두고 시간이 없다는 핑계로 읽지 않았던 책을 이제야 읽게 되어 남기는 후기. (AKA 토끼책)</p>

<p>워낙 유명한 책인탓에, 내용을 정리하거나 분석해놓은 글은 정말 많기에, 읽으면서 느꼈던 나의 생각과 후기를 정리해보려고 한다.</p>

<h3 id="책에-관하여">책에 관하여</h3>

<p>이 책에서는 역할, 책임, 협력 그리고 객체의 자율성에 대한 개념을 끊임없이 강조하고 객체지향에 대해서 굉장히 추상적으로 정리한다.</p>

<p>객체란 클래스와 동의어가 아니며, 실세계와 일치시키려는 노력을 버리고 객체지향은 이런거야!를 설명한다. 이는, 전공생 기준 1학년 때 배우는 객체지향의 설명의 잘못된 점을 지적하고 개념을 새로이 정립하려는 의도로 보였다.</p>

<p>주로 1학년 때 배웠던 것은, 객체는 클래스에서 만든 instance이며, class라 함은 상속등을 통하여 다형성을 만족할 수 있다고 배운다. 무려 7년전 기억을 끄집어 내어 현재 내가 생각하는 객체지향과 한번 비교를 해보자.</p>

<h3 id="객체지향은-붕어빵인가">객체지향은 붕어빵인가</h3>

<p>생각해보면, 1학년 때는 객체지향을 붕어빵틀과 붕어빵, 혹은 다양한 종류의 피자들로 배웠던 기억이 난다. 실제로 1학년 때 교재의 첫장에는 이러한 글이 적혀있다.</p>

<blockquote>
  <p>클래스와 객체는 붕어빵틀과 붕어빵의 관계와 유사하다.</p>

  <p>클래스는 붕어빵을 찍어내는 틀이며, 객체는 붕어빵이다.</p>
</blockquote>

<p>이러한 비유법은 사실 나는 크게 나쁘다고 생각하지는 않는다. 처음 배우는 학생들에게 객체지향에 대한 진입장벽을 낮추고 쉽게 이해를 시킬 수 있는 좋은 수단이라고 생각한다.</p>

<p>하지만, 토끼책의 저자는 객체란 자율성을 부여받고 request와 response 관계가 있어야 한다는 점에서 이러한 예시는 정답이 아니라고 이야기한다.</p>

<p>이를 설명하기 위해 책에서는 커피의 주문을 예시로 둔다. 손님의 역할은 주문할 책임을 지는것으로, 바리스타에게 주문을 <code class="language-plaintext highlighter-rouge">request</code>하고 바리스타의 역할은 커피를 만들 책임을 지는것으로, 커피를 <code class="language-plaintext highlighter-rouge">response</code>로 전달한다.</p>

<p>즉 객체지향은 기능이 우선이 아닌, 이러한 <code class="language-plaintext highlighter-rouge">협력의 구조</code>가 우선시 되고 기능이 나오기에 붕어빵의 예시는 옳지 않다는 뜻이다. 또한, 현실 사물과 비교를 했을때의 문제는, 객체는 자율성을 가지고 판단을 할 수 있어야 하지만, 사물을 예시로 드는 순간, 사물이 판단을 해야 한다는 현실과의 괴리감이 생겨 오히려 이해가 어려울 수 있다는 말을 전달한다.</p>

<p>1학년 때 만약, 이 책을 읽었다면 오히려 이해가 되지 않거나 굉장히 객체지향은 복잡하다고 생각했을 것 같다. 하지만, 개발을 꽤나 해보고 항상 개발을 하기 전 구조를 작성하고 진행을 해서인지 교양책처럼 공감을 하며 읽었던것 같다.</p>

<h3 id="후기">후기</h3>

<p>해당 책에는 예시를 코드로 들지 않는다. 대신 그림이나 UML 다이어그램등을 잘 활용하여 표현한다. 이러한 부분을 오히려 이해하기 어렵다고 부정적으로 생각하는 사람도 있었지만, 나는 오히려 다이어그램이 저자가 말하고 싶은 협력의 부분을 더 강조하고 이해를 도와주어 이해하기가 편리했다.</p>

<p>사실 개발을 하다보면, 자연스럽게 책에서 말하고자 하는 바가 모두의 코드에 녹아들어 있을 수 밖에 없다고 생각한다. 하지만, 해당 책은 이러한 알고는 있지만, 말 혹은 글로 표현하기 어려운 점들을 글로 정말 잘 풀어 냈다고 생각한다. 그리고 개발을 하며 설계에 대해 한번쯤은 더 생각하게 만들어 주는 책이라 생각한다.</p>

<p>사실 해당 책은 객체지향을 하기전 무조건 읽어야된다! 혹은 객체지향의 바이블! 이런 느낌 보다는 이렇게 해야 확장성 혹은 누구나 쉽게 이해할 수 있는 코드가 되지 않을까? 에 가깝다고 생각한다.</p>

<p>개발트렌드가 있고 TDD, 함수형 프로그래밍이 뜨고 있는 시대 개발이론에 옳고그름은 없다 생각한다. 하나의 개발 교양도서로 한번쯤은 읽어보면 좋은 책이라 생각한다.</p>]]></content><author><name>071yoon</name></author><category term="book" /><category term="book" /><summary type="html"><![CDATA[객체지향의 사실과 오해]]></summary></entry><entry><title type="html">자바스크립트 메모리관리</title><link href="http://localhost:4000/javascript/2024/01/02/js-memory-management.html" rel="alternate" type="text/html" title="자바스크립트 메모리관리" /><published>2024-01-02T00:00:00+09:00</published><updated>2024-01-02T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2024/01/02/js-memory-management</id><content type="html" xml:base="http://localhost:4000/javascript/2024/01/02/js-memory-management.html"><![CDATA[<h2 id="메모리란">메모리란</h2>

<p>우선 간단하게 메모리 관리에 대한 이야기를 해보자.</p>

<p>메모리란 개념은 컴퓨터 공학을 처음 배울 때 부터 배우기 시작하여 끝도 없이 공부하며, 아직까지도 많은 프로그래머들을 괴롭힌다. C언어 같은 언어는 allocation 함수들(<code class="language-plaintext highlighter-rouge">malloc()</code>, <code class="language-plaintext highlighter-rouge">calloc()</code> 등)을 활용하여 동적으로 메모리를 사용하고 <code class="language-plaintext highlighter-rouge">free()</code>함수를 활용하여 메모리를 해제한다. 하지만, JS 혹은 Java같은 언어는 runtime에 객체가 생성 시 자동으로 메모리를 할당하고 필요하지 않을 때 해제하게 된다. 여기서 <code class="language-plaintext highlighter-rouge">필요하지 않을 때</code>의 시점이 컴퓨터가 판단하기에, 개발자가 메모리 관리에 대한 고민을 할 필요는 없지만 오히려 관리를 하지 않아 문제를 발생시킬 수 있다는 점에 유의해야 한다. 이를 더 깊이 이해하기 위해 <code class="language-plaintext highlighter-rouge">Javascript</code>의 메모리 관리에 대해 공부해보자.</p>

<h2 id="메모리의-생존주기">메모리의 생존주기</h2>

<p>메모리의 생존주기는 <code class="language-plaintext highlighter-rouge">할당 -&gt; 사용 -&gt; 해제</code>로 매우 간단하다.</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">사용</code> 부분은 모든 언어에서 명시적으로 사용하지만, 앞서 말했던 것 처럼 <code class="language-plaintext highlighter-rouge">할당</code>과 <code class="language-plaintext highlighter-rouge">해제</code>는 Javascript와 같은 고수준 언어에서는 암묵적으로 작동한다.</p>

<h3 id="할당">할당</h3>

<p>아래는 다양한 js의 메모리 할당방법들이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
<span class="p">};</span> <span class="c1">// object가 아닌 literal도 비슷하게 할당할 수 있다</span>

<span class="c1">// 함수식 또한 오브젝트를 담기 위한 메모리를 할당한다.</span>
<span class="nx">someElement</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
  <span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">someElement</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundColor</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="kc">false</span>
<span class="p">);</span>

<span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span> <span class="c1">// new를 활용해 새로운 객체 할당</span>

<span class="kd">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// DOM 엘리먼트를 위해 메모리를 할당</span>

<span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">azerty</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 문자열은 immutable하기에, 새로운 메모리가 아닌 [0,3] 만 할당</span>
</code></pre></div></div>

<h3 id="사용">사용</h3>

<p>일반적으로 js에서 variable을 가지고 읽고 쓰는것을 의미한다.</p>

<h3 id="해제">해제</h3>

<p><code class="language-plaintext highlighter-rouge">Javascript</code>가 <code class="language-plaintext highlighter-rouge">필요하지 않다</code>고 판단이 되면, 메모리를 해제한다. Python, Java, Javascript와 같은 언어들은 각 언어만의 Garbage Collection(GC)이 동작하며 메모리 관리를 하게된다. GC의 목적은 할당된 메모리들을 추적하여 더 이상 필요하지 않을 떄 회수하는 것이지만, 이를 판단하는것이 비결정적이기 때문에 우리도 GC에 대한 이해가 필요하다.</p>

<h2 id="garbage-collection">Garbage Collection</h2>

<p>Garbage Collection은 주로 두가지의 알고리즘을 사용한다. (단순 JS에 국한되는게 아님)</p>

<h3 id="reference-counting">Reference Counting</h3>

<p>정말 간단한 방법으로, 아무도 해당 객체를 참조하고 있지 않을 때 필요없다고 간주되어 해제해 버리는 방법이다.</p>

<p>간단한 예시와 함께 살펴보자.</p>

<blockquote>
  <p>원래 js는 object에 저장될 때 obj의 주소값으로 저장하고, 해당 obj에서 변수에 대한 값 또한 주소로 저장하지만, 간편하게 도식화 하였다.</p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</code></pre></div></div>

<p>2개의 객체가 생성되어, 변수 x에 저장되고, y또한 x를 참조하고 있으므로 가비지는 없다는게 명확하다.
<img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/6ba565c5-976b-49c3-93fc-74af9ba1f4ea" alt="rc1" /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>x에 대한 값을 immutable한 값으로 바꾸며 원래 객체에 대한 참조를 y만 하게 되었다
<img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/ef8edbaf-6330-4854-bc2d-abf9dfa27ba1" alt="rc2" /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>

<span class="nx">y</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">mozilla</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>y의 값을 immutable한 값으로 바꾸고, z의 값을 a를 참조하도록 수정하였으므로, 아직 객체의 a 속성이 z에 대해 참조되어 메모리를 해제할 수 없다.
<img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/8b3b5d4c-8e8a-4fff-8fe1-f95ffa4a2658" alt="rc3" /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">z</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div>

<p>이제 원래 x가 참조했던 객체의 모든 속성에, 참조하고 있는 변수가 없으므로 가비지 콜렉션이 수행되어, 메모리의 해제가 이루어진다.
<img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/2d606e85-02d6-495a-89d9-3439be9e1509" alt="image" /></p>

<p>하지만, 이런 단순한 방법에는 서로 참조하는 <code class="language-plaintext highlighter-rouge">순환 참조</code>가 이루어질 때 문제가 생긴다. 서로 참조하는 속성이 있는 경우, 함수 호출이 끝났음에도, 서로 참조하고 있기에 메모리가 해제되지 않고 메모리 누수가 일어날 수 있다. 순환참조의 예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="nx">x</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// x -&gt; y 참조</span>
  <span class="nx">y</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// y -&gt; x 참조</span>

  <span class="k">return</span> <span class="dl">"</span><span class="s2">nothing</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="mark-and-sweep">Mark and Sweep</h3>

<p>해당 방법은 <code class="language-plaintext highlighter-rouge">필요 없는 객체</code> 를 <code class="language-plaintext highlighter-rouge">도달할 수 없는 객체</code>로 인식한다.</p>

<p>우선 <code class="language-plaintext highlighter-rouge">roots</code>라는 객체 시작하여, roots를 참조하는 객체들을 찾으며, 도달할 수 없는 객체들을 탐색 및 수집하는 방식이다.</p>

<blockquote>
  <p>js는 전역 객체</p>
</blockquote>

<p>이러한 방식은, 이전처럼 <code class="language-plaintext highlighter-rouge">순환 참조</code>가 일어나더라도 도달할 수 없음을 판단하고, 메모리를 회수할 수 있고, 실제로 js의 최신 엔진은 해당 방법으로 메모리 관리를 하게된다.</p>

<p>단점으로는, garbage collection을 수동으로 조작할 수 없고, 공식적으로 코어 언어에서도 지원하지 않을 예정이라 한다.</p>

<h2 id="v8-엔진의-메모리-구조">v8 엔진의 메모리 구조</h2>

<p>v8 메모리 구조는 우선, 메모리의 Resident Set이라는 공간에서 시작된다. 해당 영역에서 스택과 힙 공간으로 나누어져 메모리를 할당하게 된다. Operating System에서 배웠듯, Stack 공간은 함수호출이 끝난 후 삭제되지만, 동적인 힙 메모리는 그렇지 않기에, 메모리 누수에 취약하며 주의깊게 봐야한다.</p>

<p><img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/914c8119-239e-4d13-adc0-1662ead4b693" alt="v8-memory-structure" /></p>

<p>힙 공간은 위 그림에서 Stack을 제외한 모든 부분이며, 여러 공간들로 나누어져 있지만 실제로, GC가 일어나는 New Space와 Old Space를 주의깊게 보자.</p>

<ul>
  <li>New Space: 새로 만들어지는 Object가 할당</li>
  <li>
    <p>Old Space: New Space에서 Minor GC가 2번 일어날 동안 살아남는 경우 저장된다</p>

    <ul>
      <li>Old Pointer Space: 다른 객체를 참조하는 객체 (다른 객체에 대한 포인터를 가지는 경우)</li>
      <li>Data Space: 문자열/실수 등 데이터만 가지고 있는 객체</li>
    </ul>
  </li>
  <li>Large Object Space: mmap 메모리를 가지는 객체들이 있으며, GC의 대상이 아니다.</li>
  <li>Code space: JIT 컴파일러가 컴파일된 코드들을 저장하여, 실행 가능한 메모리가 있는 영역이다.</li>
  <li>Rest: 이 영역들은 각각 Cells, PropertyCells, Maps이며, 각 영역은 모두 같은 크기의 객체들을 포함하며, 어떤 종류의 객체를 참조하는지에 대한 제약이 있어서 수집을 단순하게 만든다.</li>
</ul>

<h2 id="v8-엔진의-gc">v8 엔진의 GC</h2>

<p>v8 엔진의 GC는 Java의 GC와 사뭇 비슷하다.</p>

<blockquote>
  <p>Java에서 갓 생성된 객체를 Eden이라고 따로 관리했던 것을 제외하면 매우 유사하다고 생각함</p>
</blockquote>

<p>JS의 Garbage Collection은 <code class="language-plaintext highlighter-rouge">Generational Hypothesis</code> 이론을 중점으로 이루어지는데, 이는 새로운 객체가 오래된 객체보다 쓸모 없어질 가능성이 높다, 즉 일회성 데이터들이 많다는 이론에 의거하여 동작한다.</p>

<p>그렇게 Garbage Collection을 Minor GC와 Major GC 둘로 나누어 관리하게 된다.</p>

<h3 id="minor-gc">Minor GC</h3>

<p>Minor GC는 New Space의 Garbage를 수집하는 역할을 한다. 앞서 다이어그램에서 보았듯, New Space에는 두개의 Semi Space가 존재한다. 여기서 한 Semi Space는 항상 비워두며, Mark and Sweep 알고리즘을 통해 삭제되지 않는 객체들을 옮기고, 다시 한 Space를 비우는 방식으로 작동한다. 만약 다음 Minor GC에도 해당 객체들이 살아있다면, 이들은 Old Space로 이동하게 된다.</p>

<p>이를 간단히 도식화 하면 다음과 같다.</p>

<p><img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/cfcfe251-94d4-4563-a570-a62f5f2204b7" alt="minor_gc" /></p>

<h3 id="major-gc">Major GC</h3>

<p>이제 Old Space에서의 Garbage Collection을 알아보자. Major GC는 Mark and Sweep Compact 와 Tri-Color Algorithm을 사용하며, 크게 마킹 -&gt; 스위핑 -&gt; 압축 으로 이루어진다.</p>

<ol>
  <li>
    <p>마킹</p>

    <p>우선 어떤 객체들이 할당 해제가 되어야 되는 객체들인지 판단을 하기 위해, 전역객체부터 시작하여 DFS로 순회하며 Tri Color Algorithm으로 마킹을 한다.</p>

    <p>Tri Color는 3가지 색으로 node를 나타내며</p>

    <ul>
      <li>white: 아직 탐색을 하지 못한 노드</li>
      <li>gray: 탐색을 했지만, 객체가 참조하고 있는 노드까지는 탐색을 완료하지 못한 노드</li>
      <li>black: 참조하고 있는 개체까지 확인을 완료한 노드</li>
    </ul>

    <p>해당 알고리즘을 마치고 나면, 모든 노드들은 white / black인 형태로 남게 되어, white인 경우 도달할 수 없는 노드로 판단할 수 있다.</p>
  </li>
  <li>
    <p>스위핑</p>

    <p>white 인 노드들은 도달할 수 없으므로, 필요없는 객체라 판단되어 할당된 메모리 공간을 해제한다.</p>
  </li>
  <li>
    <p>압축</p>

    <p>메모리 단편화가 심한 페이지들을 재배치하여 메모리 공간을 확보한다. 이는 Fragmentation과 Segmentation을 검색해보면 더 자세히 알 수 있다.</p>
  </li>
</ol>

<h2 id="orinoco">Orinoco</h2>

<p>Garbage Collection을 수행하는 동안에는 Stop The World가 일어나며, 모든 프로세스가 멈추어 UX 적으로 많은 문제가 생긴다. 이를 v8 엔진은 우아하게 처리하기 위한 Orinoco 프로젝트를 알아보자.</p>

<h3 id="incremental-marking">Incremental Marking</h3>

<p>2011년에 나온 stop the world의 해결방안으로 나온 incremental marking 이다.
<img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/4544a7bf-de1e-44d1-ae0c-4a3a7eb0647e" alt="incremental marking" /></p>

<p>다이어그램에서 보이듯, 짧은 GC로 쪼개어 프로그램의 반응속도 및 UX를 개선하려함을 볼 수 있다. 하지만, 프로그램이 동작함에 따라, object graph에 대한 변동사항이 생길 때 마다 Garbage Collection에 알려야 하기 때문에, idle time이 없는 경우 cost가 굉장히 높다.</p>

<p>여기서 idle time이란, 크롬 자체에서 프로그램이 쉬는 기간을 미리 알 수 있다는 것이다. 이를 활용하면, 예를 들어, 1 프레임에 필요한 연산을 16ms안에 해결한다면, 남는 시간동안 idle GC를 활용하여, GC를 미리 할 수 있다.</p>

<h3 id="parallel--concurrent">Parallel &amp; Concurrent</h3>

<p>해당 방식은, Helper Thread를 두어, 병렬 혹은 동시적으로 Garbage Collection을 수행하여 stop the world를 최소한을 줄이는 방식이다.</p>

<p>그래서 모든 GC의 기술들을 합치면 현재는 이러한 형태를 띄게 된다.</p>

<p><img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/fd27a383-cf71-4110-bc83-d044750b76e5" alt="v8-gc-graph" /></p>

<h2 id="참조">참조</h2>

<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_management">mozilla</a></p>

<p><a href="https://deepu.tech/memory-management-in-v8/">memory-management-in-v8</a></p>

<p><a href="https://v8.dev/blog/trash-talk">v8-dev-trash-talk</a></p>

<p><a href="https://v8.dev/blog/concurrent-marking">v8-concurrent-marking</a></p>]]></content><author><name>071yoon</name></author><category term="javascript" /><category term="javascript" /><category term="til" /><summary type="html"><![CDATA[메모리란]]></summary></entry><entry><title type="html">2023년 회고</title><link href="http://localhost:4000/retrospect/2023/12/27/2023-retrospect.html" rel="alternate" type="text/html" title="2023년 회고" /><published>2023-12-27T00:00:00+09:00</published><updated>2023-12-27T00:00:00+09:00</updated><id>http://localhost:4000/retrospect/2023/12/27/2023-retrospect</id><content type="html" xml:base="http://localhost:4000/retrospect/2023/12/27/2023-retrospect.html"><![CDATA[<p>되게 바빴지만, 동시에 여유로웠던 한해였다.</p>

<p>작년이나 재작년처럼 열심히 개발 역량을 키우기 위해 달리기 보다 다른 업무나 일을 보기위해 바빴던 것 같다.</p>

<h2 id="상반기">상반기</h2>

<p>토스에서 일해보았다. Interaction Team에 UX Engineer Assistant로 6개월 근무를 하였는데, 정말 많은 경험을 해보며 재미있었던 기간이였다. 단순히 React만 적당히 끄적일 수 있고, 딱 컴퓨터 전공자만큼의 지식을 알고있던 무지한 상태에서 나름 실무적인 경험을 해보며 다양한 경험들을 할 수 있었다.</p>

<p>물론, 처음에는 나의 기술을 통해 돈을 보넌 행위를 함에 부담도 많이 됐다. 내가 돈을 받고 일을 하는데, 나 때문에 일을 못하거나 병목이 생기는 상황이 오면 어떡하지..? 라는 생각때문에 입사 초반에는 걱정이 많았다. 검토를 정말 많이 하고, 항상 슬랙을 보는 버릇이 생겼던 것 같은데, 당연히 그렇듯 입사하고 시간이 지나니 점차 괜찮아졌다 ㅎㅎ</p>

<p>토스에 입사하고, 당연히 기술적으로 프론트엔드 Toss Design System등을 유지보수 및 토스 사내 Animation Library인 Rally도 어깨너머로 배우며 많이 성장했다 생각한다. 특히, Web에서의 Animation은 정말 제대로 다뤄본 경험이 없었는데, Interaction Team에 들어가며 많이 배울 수 있어서 정말 좋은 경험이라 생각한다. 단순히 Web에서의 Interaction, CSS가 아닌 Interaction에 대한 고찰을 해볼 수 있는 시간이였어서 더 값진 경험이라 생각한다. 그리고, 기술적으로 말고도 Framer등 디자이너 툴도 제대로 사용해보며 어떤식으로 디자이너와 일을 하는지 시스템을 배울 수 있었는데, 많은 미팅에 들어가며 스타트업에 대한 프로세스를 배울 수 있는게 좋았다.</p>

<p>이러한 프로세스들을 직접 몸으로 느껴보며, 애자일함이란 이런 것이구나를 제대로 느낄 수 있었다. 검증에 최소한의 비용을 사용하며 테스트를 진행하는것이 제일 신기했다. 이론으로만 배웠던 빠른 실패란 어떤것인지 실제로 보고 겪을 수 있었다. 이를 통해, 개발에 집중할 수 있어 일에 대한 집중도가 높아져 사람들이 정말 열심히 일 할 수 있는 동기부여가 되었던 것 같다. 또한, 배경뿐만이 아니라 프론트엔드의 전반적으로 테스트나 배포등에 있어 시스템이 정말 잘 갖추어져 있어 정말 개발에만 집중할 수 있는 시스템이 갖추어 져 있는것 또한 좋았다. 한가지 아쉬웠던 점은, 토스팀은 Silo나 스쿼드로 팀을 구성해서 같이 프로젝트를 하는걸로 유명하지만, Design Platform Team에 소속되어 서비스나 사일로를 경험해보지 못한것이 조금 안타깝다.
그리고,이런 개발 친화적이고 빠른 기업도 좋지만, 대기업은 어떤식으로 동작하는지도 궁금해져 대기업도 한번 가보고 싶은 생각이 좀 커져갔던 것 같다.</p>

<p>한가지 또 생각나는건, IT기업의 복지가 정말 잘 갖추어져 있다는 것이다. 예를 들어 커피 사일로가 존재해서 매일매일 정말 좋은 퀄리티의 커피를 부담없이 즐길 수 있다는것, 혹은 1인1법카를 활용하여 정말 밥을 고민없이 먹을 수 있는점, 사내 편의점이 존재하여 과자 혹은 음료수를 원할 때 막 먹을 수 있는점 등 IT의 복지의 끝판왕이라고 생각한다. 그리고, 보통 유연 근무제라고 하면 코어타임이 10-15등 정해져 있는 경우가 많은데, 토스같은 경우 아예 자율근무를 지향하기에, 완전 재택으로 일해도 아무도 신경쓰지 않을정도로 정말 유연했다.</p>

<blockquote>
  <p><img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/7e61e1bb-bcf2-4238-94e0-93faff2da768" width="200" />
사내 바리스타분이 매일 내려주는 오늘의 커피의 바리에이션 내일의 커피</p>
</blockquote>

<p>토스에 있었던 경험은 개발자로서의 커리어나 성장빼고도 정말 값진 경험이라 생각한다. 정말 좋은사람들도 많이 만나고 내 실력의 한계도 느낄 수 있었다. 더불어 내가 어디가 부족하고, 내가 진정으로 원하는건 무엇인지에 대한 깊은 고민을 할 수 있는 시간이여 더 좋았다.</p>

<h2 id="하반기">하반기</h2>

<p>앞서 토스를 퇴사하고, 많은 고민을 했다. 개발, 특히 프론트엔드를 하며 항상 재미있었고, 성장하고 싶다는 욕심이 있었는데, 막상 일을 하며 돈을 버는 행위를 하다보니 내가 정말 이걸 평생 할 수 있을까? 란 고민을 하게 됐다. 아직 백엔드도 제대로 해보지 못하고, 다양한 직군 혹은 분야를 해보지도 않았는데, 앞으로의 커리어를 이렇게 이어가는게 맞을까? 란 많은 생각이 들었다. 그래서 생각정리를 할 겸 친구와 제주도 종주를 기획하고 떠났다.
하지만,,, 생각보다 너무 힘든 종주길에 생각은 커녕 몸만 지치고 돌아왔다. 하지만 정말 친구와 처음 떠난 긴 여행에 정말 재미있었고 퇴사 후 노트북 혹은 컴퓨터 자체를 보지 않고 일주일 넘게 있던 경험자체에 힐링을 할 수 있었다.</p>

<p>그리고 학교 4-2를 마무리하며, 취준을 제대로 시작하였다.</p>

<p>사실 나는 4-2 복학을 하기가 싫었다. 빠르게, 취업을 해서 취업계를 내고 졸업을 하고 싶었지만,, 학교의 이상한 시스템 때문에 취준은 취준대로 하며 학교는 학교대로 다녀야되는 상황에 놓이게 되었다. 사실은 원래 2023 상반기도 취업을 하고 싶었지만, 학교시스템상 취업계가 되지 않아 억지로 휴학 후 계약직을 했다.</p>

<p>나는 이번 학기에는 취준과 학교생활을 병행하기 위해 정말 최소한의 학점인 11학점만 들었다. 3학년에 전과를 하여, 타 4학년들과 비교하였을 때 꽤나 많은 학점을 들었지만, 사실 그렇게 바쁘지는 않았다. 하지만, 코로나가 끝남에 따라 대면과 비대면 수업을 병행하고, 대면의 비중이 높아 일주일 중 4일이나 학교를 가게 되어 조금 이동시간이 많아서 체감상 바빴다. 그리고 막상 학교 공부를 하려고 해도, 내일 면접, 그 다음날 코딩 테스트, 그 다음날 자소서 등 취준관련하여 신경을 써야되는게 많아 제대로 집중하기 쉽지가 않았다. 이번에는 서류만 한 30개 가까이 제출했던 것 같고, 최종은 4개정도 붙었다. 물론, 처음에 한 기업을 붙고나서 면접이나 다음 채용과정을 많이 취소해서 더 붙었을 수 도 있긴하다. 결국, 채용 취소를 죄송하게도 두번이나 하게 되었다.</p>

<p>취준에 대하여 고찰을 해보자면, 내가 너무 만만하게 봤던것 같다. 다들 이번에 채용시장이 불바다라고 하긴 했지만, 그럼에도 서류가 떨어질 때 마다 나름 충격의 연속이였다. 나름 2년간 정말 열심히 살아왔다고 생각을 하였는데, 탈락 메일을 받는건 아무리 받아도 적응이 되지 않았다. 그리고 여기서 조금 실수를 하게 되는데, 처음에 서류의 탈락들을 보고 너무 겁을 먹어, 스타트업과 중소/중견을 가리지 않고 막 쓰기 시작했다. 그래서 정말 붙었을 때 갈 회사들만 작성을 했어야 됐는데, <code class="language-plaintext highlighter-rouge">면접도 경험이지 뭐~</code> 라는 생각에, 정말 많이 작성하는 바람에 면접과 코딩테스트 등을 수습하느라 하나에 대해서 제대로 준비도 못하고 시간도 없고 그랬다. 그리고 인적성이나 NCS등을 한번도 공부해본 적이 없는데, 너무 만만하게 보고 있다가 여기서 정말 많이 떨어졌다.. 아쉽아쉽..</p>

<p>그리고 취준을 하면서 정말 많은 생각들을 하게 되었다. 대기업 같은 경우 지원을 하면서, 내가 쌓아오던 커리어(프론트엔드)가 아닌 크게 IT 직무로 많이 뽑았는데, 만약 이런곳 가서 내가 잘 알지도 못하는 도메인에 잘 알지도 못하는 일을 하게 되었을 때 정말 행복할까 라는 생각을 하게 되었다. 내가 처음 전과를 한 이유가 개발과 컴퓨터가 재미있어서 였는데, 결국에는 내가 좋아하는걸 못하게 될까봐 두렵기도 했다. 물론 대기업 혹은 금융권을 가면 돈도 좋고 워라밸도 챙길 수 있겠지만, 어떤 내가 더 삶에 만족을 할 수 있을까에 대한 고민이 계속 생겨났다.
물론 운이 좋게도, 나름 IT대기업에 내가 원하는 직무에 합격을 하게 되어 여기서 경험을 더 해보기로 결정하게 되었지만, 아마 평생을 고민하며 살게 될 것 같다.</p>

<p>취준기간 동안, 시간이 남아 <code class="language-plaintext highlighter-rouge">공정하다는 착각</code>을 읽은 적이 있다. 여기서, 요새 사람들은 남의 시선과 인식에 대해 겁을 많이 먹는다는 이야기가 나오게 된다. 어쩌면 내가 대기업에 들어가고 싶어했던 이유도, 사회적으로 인정을 받고 싶어서 였을까?</p>

<blockquote>
  <p><img src="https://github.com/071yoon/071yoon.github.io/assets/66371206/64c81581-5f0c-42c5-8c71-612d613145a3" width="200" />
내 방을 지켜주는 숲의 요정들</p>
</blockquote>

<h2 id="회고">회고</h2>

<p>뭔가 개발적으로 성장하지 않으면 시간이 아깝고 버려지는것 같은 기분이 든다. 아마 재작년에 개발을 시작하며 늦었다는 생각이 들며, 계속 개발적으로 성과를 내야하고 공부를 해야한다는 강박이 나도모르게 있었던 것 같다. 그래서 취업을 준비하면서도, 전공 지식, 실무 면접, 코딩테스트는 열심히 하였지만 대기업 회사의 NCS 혹은 인적성은 시간이 아깝다는 생각이 들어 소홀했던 것 같다.</p>

<p>또한, 예전에는 교양 공부가 흥미롭고 재미있었는데, 이번 학기에는 그 시간에 면접 준비를 더 하거나 자소서를 쓰는것에 더 집중한다는 생각에(그렇다고 제대로 한것도 아니다), 제대로 하지도 못하고 공부를 할 때도 재미가 없었던 것 같다.</p>

<p>이제는 나름 대기업에 들어가, 정규직 직원으로서 나의 직무가 명확하기에 앞서 말했던 성장에 대한 갈망이나 강박을 조금 벗어날 수 있지 않을까 생각한다. 이제는 내가 무엇 때문에 전과를 하였는지, 나는 왜 개발자가 되고 싶었는지 초심으로 돌아가 여러 공부와 다양한 인사이트를 얻는 시간을 보내고 싶다.</p>

<h2 id="짧온-메모">짧온 메모</h2>

<p>다소 건방진 이야기일 수 도 있지만, 다들 취업이 힘들다 하는것은 내가 원하는 회사에 들어가지 못해 계속 도전하고 불합격에 좌절하기 때문이라 생각한다. 하지만, 원하는 회사가 정말 본인이 원하는 회사인지 혹은 사회적으로 형성된 좋은 회사인지 모두가 고민해 보는 시간을 가졌으면 좋겠다. 단순히 모두가 <code class="language-plaintext highlighter-rouge">우아</code> 소리가 나오는 회사를 갔다고 해서 내가 행복할지, 혹은 그곳에 꿈이 있어 나의 비전과 미래를 이룰 수 있는 곳이기에 가고 싶은지.. 나 또한 평생 고민할 숙제라고 생각한다.</p>]]></content><author><name>071yoon</name></author><category term="retrospect" /><category term="retrospect" /><summary type="html"><![CDATA[되게 바빴지만, 동시에 여유로웠던 한해였다.]]></summary></entry><entry><title type="html">firebase 정보 백업하기 (export)</title><link href="http://localhost:4000/til/2023/12/04/export-firebase.html" rel="alternate" type="text/html" title="firebase 정보 백업하기 (export)" /><published>2023-12-04T00:00:00+09:00</published><updated>2023-12-04T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/12/04/export-firebase</id><content type="html" xml:base="http://localhost:4000/til/2023/12/04/export-firebase.html"><![CDATA[<h2 id="배경">배경</h2>

<p>firebase를 활용해서 개인 프로젝트를 잘 하고 있었는데, 문득 백업이 하고싶어졌다.</p>

<p>google이 갑자기 내 data를 날려버리거나 하지는 않겠지만 내가 실수로 table을 날렸을 경우 복구도 되지 않을 것 같고 (가뜩이나 무료 버전을 쓰고 있기에) 점점 traffic이 올라감에 한번은 백업이 필요하다 생각이 들었다.</p>

<h2 id="firebase-둘러보기">Firebase 둘러보기</h2>

<p>솔직히 firebase에 backup 혹은 export 기능이 없을리가 없다</p>

<p><img width="1155" alt="firebase-export-import-icon" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/a367acb2-37b7-4cdc-a7cb-98d1dc4defc3" /></p>

<p>당연히 있다..!</p>

<p>하지만 아니나 다를까 결제 정보를 입력하고 돈을 내야 가능하는것 처럼 보인다.</p>

<p><img width="542" alt="firebase-export-card-image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/fb30b9c5-a7ca-4155-b30a-46c868cff91f" /></p>

<p>(사실 GCP와 연결하는것 같아 당연히 결제 정보가 필요한것이고 실제로 돈이 필요한지는 모르겠음.. 그냥 혹시나 카드정보 입력해 두었다가 firebase traffic이 폭주해서 지갑이 털릴까봐 조금 무서웠다)</p>

<p>그래서 다른 방법을 찾아 나서기로…!</p>

<h2 id="github-돌아다니기">github 돌아다니기</h2>

<p>솔직히 firebase는 문서화가 잘 되어 있기도 하고, query를 통해 data를 읽기/쓰기가 매우 쉬워 손쉽게 코드로 export 하는 기능을 찾는것도 어렵지 않다고 생각한다. 하지만,, 누군가 더 깔끔하게 만들어 두었다면..? 굳이 내가 만들 필요가 있을까? 라는 생각에 뒤적 뒤적,.. firebase export를 찾아보기 시작했다..</p>

<h3 id="node-firestore-import-export">node-firestore-import-export</h3>

<p>기가 막힌 library를 찾아내고야 말았다. 바로 이름부터 직관 그 자체인 <a href="https://github.com/jloosli/node-firestore-import-export">node-firestore-import-export</a>!</p>

<p>두가지 활용 방법이 존재한는데</p>

<ol>
  <li>npm 으로 전역으로 library를 설치 후 export하여 json 형태로 받기</li>
  <li>코드로 export/import 기능을 구현하여 web application 내부에서 활용</li>
</ol>

<p>나는 굳이 export나 import를 web으로 할것이 아니기에 1번 방법으로 수동으로 백업을 하였다.</p>

<p>워낙 README가 잘 되어 있어 직접 레포에 확인해보는것이 더 정확하겠지만, 간략한 사용법은 다음과 같다.</p>

<ol>
  <li>
    <p>firebase에서 비공개 키 생성</p>

    <blockquote>
      <p>프로젝트 설정 -&gt; 새 비공개 키 생성
<img width="652" alt="firebase-goto-image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/f4e24a2d-e09d-4608-8633-a68c84b054dc" /> <img width="1031" alt="firebase-admin-sdk-image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/dfc43936-e13c-4cfc-b9df-9601485aa5cd" /></p>
    </blockquote>
  </li>
  <li>
    <p>npm package 설치 및 export</p>
  </li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># sudo로 해야될 수 있음</span>
npm <span class="nb">install</span> <span class="nt">-g</span> node-firestore-import-export

<span class="c"># ..비공개 키 저장된 위치로 이동..</span>
firestore-export <span class="nt">--accountCredentials</span> path/to/credentials/file.json <span class="nt">--backupFile</span> /backups/myDatabase.json
</code></pre></div></div>

<p>그리고 이러한 open-source library를 사용하는 경우 내 credential 이 외부로 노출이 되지는 않을까.. 하는 생각으로 항상 검증 해봐야 된다.</p>

<p>실제로 export 하는 부분을 링크로 남겨둘테니 한번씩은 확인해 보았으면 한다. (내가 봤을때는 문제 없음)</p>

<blockquote>
  <p><a href="https://github.com/jloosli/node-firestore-import-export/blob/master/src/lib/export.ts">firebase-export 링크</a></p>
</blockquote>

<p>아주 깔끔~ 하게 json 으로 export가 된다.</p>

<p><img width="482" alt="firebase-export-image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/ff54d889-63fa-4be0-8858-e9b157ac310e" /></p>

<p>다음엔 아마 oracle 무료 cloud를 받은 기념,, 하루에 한번씩 backup 하도록 자동화 해둘 예정..</p>

<p>총총..</p>]]></content><author><name>071yoon</name></author><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[배경]]></summary></entry><entry><title type="html">크롬 익스텐션을 개발해보자</title><link href="http://localhost:4000/til/2023/09/18/make-chomre-web-extension.html" rel="alternate" type="text/html" title="크롬 익스텐션을 개발해보자" /><published>2023-09-18T00:00:00+09:00</published><updated>2023-09-18T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/09/18/make-chomre-web-extension</id><content type="html" xml:base="http://localhost:4000/til/2023/09/18/make-chomre-web-extension.html"><![CDATA[<h2 id="발단">발단</h2>

<p>요새 메이플이란 게임에 빠져있었다. 그리고 이 게임에는 <code class="language-plaintext highlighter-rouge">재획</code> 이라는 시스템이 존재한다. 일반적으로 사냥을 하는 컨텐츠이지만 이 사냥을 많이 하다보면 게임 화면을 보지 않고도 컨텐츠를 즐길 수 있는 경지에 오르게 된다. 보통 이러한 경지를 <code class="language-plaintext highlighter-rouge">뇌빼기</code>(대충 뇌 빼고도 사냥한다는…) 라고도 하는데, 여기서 메이플의 서브 컨텐츠인 딴거하기를 즐길 수 있다.
보통 이 딴거하기 단계에서는 넷플릭스나 유튜브등 동영상 컨텐츠를 많이 즐기게 된다. 그러던 중 메이플 커뮤니티에서 웹툰을 보는 방법이 올라왔다.
<img width="461" alt="image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/5b668973-8501-4570-98f0-f8adc7100a67" />
사진에 보이듯, f12를 눌러.. 개발자 도구에 들어가.. javascript를 입력해.. 조절을 이렇게… 아마 개발을 하는 나에게는 익숙하지만 일반인에게는 꽤나 복잡하고 이해가 안될거 같다는 생각이 들었다. 그럼 이걸 확장으로 만들면 더 쉽지 않을까? 라고 생각해 바로 개발에 들어갔다.</p>

<h2 id="개발">개발</h2>

<p>매우 간단한 화면이 되겠지만, 그럼에도 불구하고 React를 심어두면 개발이 편하고 추후에 수정하기도 편할 것 같아, 우선 React + Web Extension을 우선으로 개발하기로 결정했다.</p>

<h3 id="react-심기">React 심기</h3>

<p>React를 심는것은 기존에 있는 React boilerplate와 유사하다. 다른점은 extension에서 <code class="language-plaintext highlighter-rouge">popup</code>이란 화면이 메인 화면임이므로 <code class="language-plaintext highlighter-rouge">root</code> 대신 <code class="language-plaintext highlighter-rouge">popup</code>에 render해주면 되는것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">mountNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">popup</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">App</span> <span class="o">/&gt;</span><span class="p">,</span> <span class="nx">mountNode</span><span class="p">);</span>
</code></pre></div></div>

<p>그리고 package.json에 필요한 library등을 삽입하여 <App></App>에서 사용해주면 된다.</p>

<h3 id="mainfest">mainfest</h3>

<p>manifest는 어떻게 확장을 구성할지에 대한 정의라고 할 수 있다. 일반적으로 그냥 chrome확장에서 제시해주는 대로 작성하면 되지만, 중요한점은 <code class="language-plaintext highlighter-rouge">manifest_version</code>과 <code class="language-plaintext highlighter-rouge">permissions</code> 라고 생각한다.</p>

<p>manifest_version은 3이 최신버전이므로 사용하는게 맞지만, 참고 어플들은 2가 많으므로 주의해서 사용하자. 나는 처음에 2로 사용했다가 chrome extension 사이트를 보며 개발하다 outdated가 많아 3으로 올려 버전업을 했다.</p>

<p>permissions는 내 확장에 어떠한 기능들까지 허용해줄지에 대한 정의이다. 나같은 경우에 3가지를 허용해주었는데 하나하나 알아보자.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">activeTab</code>
    <ul>
      <li>확장이 열린 탭(내가 보고 있는 탭)에 대한 정보를 제공해주겠다는 뜻</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">scripting</code>
    <ul>
      <li>확장에서 script를 실행하게 해주겠다는 뜻</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">storage</code>
    <ul>
      <li>chrome web storage를 사용하게 해주겠다는 뜻</li>
    </ul>
  </li>
</ul>

<h3 id="javascript">javascript</h3>

<p>확장에서 javascript를 실행할때 주의할 점은 node환경이 별개로 두개가 된다는 점이다. 하나는 내가 지금 보고 있는 화면의 javascript와 하나는 확장이 돌아가고 있는 화면의 javascript이다. 각각 content.js와 background.js에서 돌아가게 된다.</p>

<p>하지만 개발을 하다보면 background.js -&gt; content.js로 넘어가게 되는 상황이 많이 생기게 된다. 그럴경우 event listener로 넘겨주며 주고받을 수 있지만, 나는 보다 쉽게 개발하기 위해 바로 확장에서 바로 content의 javascript를 실행할 수 있게 <code class="language-plaintext highlighter-rouge">chrome.scripting.executeScript()</code>함수를 활용하였다.</p>

<p>예시는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">onStart</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">queryOptions</span> <span class="o">=</span> <span class="p">{</span> <span class="na">active</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">lastFocusedWindow</span><span class="p">:</span> <span class="kc">true</span> <span class="p">};</span>
    <span class="nx">chrome</span><span class="p">.</span><span class="nx">tabs</span><span class="p">.</span><span class="nx">query</span><span class="p">(</span><span class="nx">queryOptions</span><span class="p">,</span> <span class="p">([</span><span class="nx">tab</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">chrome</span><span class="p">.</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">lastError</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">chrome</span><span class="p">.</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">lastError</span><span class="p">);</span>

      <span class="c1">// @ts-ignore</span>
      <span class="nx">chrome</span><span class="p">.</span><span class="nx">scripting</span><span class="p">.</span><span class="nx">executeScript</span><span class="p">({</span>
        <span class="na">target</span><span class="p">:</span> <span class="p">{</span> <span class="na">tabId</span><span class="p">:</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">id</span> <span class="p">},</span>
        <span class="na">func</span><span class="p">:</span> <span class="p">(</span><span class="na">sv</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span> <span class="na">st</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="c1">// do something with sv, st</span>
        <span class="p">},</span>
        <span class="na">args</span><span class="p">:</span> <span class="p">[</span><span class="nx">scrollValue</span><span class="p">,</span> <span class="nx">scrollTime</span><span class="p">],</span>
      <span class="p">});</span>
    <span class="p">});</span>
  <span class="p">})();</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="실행">실행</h3>

<p>실행은 <code class="language-plaintext highlighter-rouge">build</code>를 통해 나온 dist.zip 파일을 <code class="language-plaintext highlighter-rouge">chrome://extensions</code>에 넣어주고 사용하면 된다. 여기서 조금 불편한점은 매번 update할 때 마다 build를 하고 refresh를 해줘야된다.</p>

<h2 id="배포">배포</h2>

<p>개발보다 배포가 더 오래 걸렸다. 우선 웹 대시보드 콘솔에 들어가 가입도 해야되고 (가입비 5$도 지불해야된다) 어떤 목적으로 개발했는지, 앞서 허용해주었던 permissions들은 왜 허용을 해주었는지, logo는 잘 등록이 됐는지 등 설명을 많이 해줘야된다. 그래도 나름 콘솔이 잘되어 있어 어떤걸 놓쳤고 미숙한지 잘 알려주기 때문에 나름 따라가기가 쉬웠다.</p>

<p>하지만 나는 설명을 충분히 적지 않아 한번 거부를 당했다..
<img width="505" alt="image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/267d5e46-2b4b-4f91-9143-a6697d9c9018" /></p>

<p>그리고 게시가 되면 다시 메일이 올 줄 알았는데, 게시가 잘 되면 메일이 오지 않고 자동으로 등록됨에 주의..!</p>

<h2 id="후기">후기</h2>

<p>개발을 완료한 후 당당하게 메이플 커뮤니티에 올렸다. 다행히 반응도 좋았고 사람들이 많이 좋아해줬다. (이것이 나의 개발의 원동력…)
<img width="210" alt="image" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/06c355ec-e44f-426f-991c-efeaa3e656bb" />
그리고 다른 커뮤니티에서 까지 퍼가서 홍보해주시는 분도 보았다.. 뿌듯..
다른 커뮤니티에 올라온 나의 글..
<img width="439" alt="스크린샷 2023-09-18 오후 12 22 20" src="https://github.com/071yoon/071yoon.github.io/assets/66371206/af8661fa-d558-427c-864f-0dc3378c3924" /></p>]]></content><author><name>071yoon</name></author><category term="TIL" /><category term="web" /><summary type="html"><![CDATA[발단]]></summary></entry><entry><title type="html">걸어서 제주도 한바퀴</title><link href="http://localhost:4000/retrospect/2023/07/12/walk-through-jeju.html" rel="alternate" type="text/html" title="걸어서 제주도 한바퀴" /><published>2023-07-12T00:00:00+09:00</published><updated>2023-07-12T00:00:00+09:00</updated><id>http://localhost:4000/retrospect/2023/07/12/walk-through-jeju</id><content type="html" xml:base="http://localhost:4000/retrospect/2023/07/12/walk-through-jeju.html"><![CDATA[<h1 id="걸어서-제주도-한바퀴">걸어서 제주도 한바퀴</h1>

<h2 id="계획">계획</h2>

<p>처음에는 국토대장정이였다.
인천에서 출발하여 부산까지 걸어서 가는 20박 21일의 여정을 생각했었다. 하지만, 일정상 너무 길고 날씨또한 7월의 무더움을 견뎌내기 힘들것 같아 제주도로 방향을 틀고 계획을 잡았다.</p>

<p>계획은 3월에 비행기를 예매하여 시작되었다. 원래 다니던 회사의 계약기간만료가 6월30일이였기에, 퇴사 후 바로 비행기를 타고 제주도에서 8박9일동안 제주도 한바퀴를 걷기로 친구와 약속을 하고 그 뒤에 일정은 아무것도 고려하지 않았다. (숙소 예약은 그날 컨디션에 따라 조절해야될 것 같아 첫날을 공항근처에서 예약해두고 나머지는 예약도 안하고 출발)</p>

<p>여행을 시작하기전 여러 사람들의 후기를 보니 무조건 가방을 가볍게 가져가야 된다는 이야기가 정말 많았다. 그래서 나도 최대한 압축을 해서 가져갔고 항목들은 다음과 같다.</p>

<ul>
  <li>반팔, 반바지, 속옷 두세트 (그런데 당일날 빨래를 했었어서 사실 한세트만 있었어도 충분했을 것 같다)</li>
  <li>스피커 (필수..!)</li>
  <li>보조배터리 / 충전기</li>
  <li>세면도구 (로션, 칫솔 등)</li>
  <li>우비</li>
  <li>깃발 (낭만 원툴)</li>
</ul>

<p>정말 이정도만 챙겨서 갔었다. 혹시몰라서 긴바지도 준비했었었는데, 2일차에서 조금이라도 가방 무게를 줄여야겠다고 생각이 들어서 숙소에서 버리고 갔다… ㅜ</p>

<p>그렇게 정말 낭만밖에 없는 바보들의 걸어서 제주도 한바퀴가 시작됐다.</p>

<p>위풍당당한 첫날
<img width="523" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/b5f92839-1331-40da-b658-bc124afb999e" /></p>

<h2 id="일정">일정</h2>

<p>일정은 제주도 환상 자전거 종주길을 따라 가기로 했다.</p>

<p><img width="1151" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/aac2fb5c-271c-4b1f-b7e6-0bfa98a33f7f" /></p>

<p>공항근처인 용두암으로 시작해서 다시 용두암으로 돌아오는 7박 8일 코스로 시작했다.</p>

<p>일정을 하루하루 적기에는 양이 너무 많아 재미있었던 에피소드별로 작성해보려고 한다.</p>

<h3 id="올레길의-지옥">올레길의 지옥</h3>

<p>첫날에는 체력이 너무 많아서 잘못된 선택을 해버렸다. 바로 올레길을 따라가버린것. 우선 환상 자전거길을 아래와 같이 파란색 선으로 제주도 한바퀴에 걸쳐 그려져 있어 쭉 따라가기만 하면 된다.</p>

<p><img width="713" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/08144542-5314-4ad7-9084-0a3946db9d72" /></p>

<p>하지만 첫날에 힘이 너무 넘치는 바람에 아스팔트길이 아닌 올레길을 가기로 결정을 해버렸다.</p>

<p>아래 사진에서 빨간색 선이 자전거길이고 파란색 선이 올레길 18번이다. 지도로만 보았을 때는, 돌아가지도 않고 풍경도 훨씬 좋을것이라 예상이 되어 이구간을 올레길로 따라가보았다.
<img width="1059" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/3b6eba39-a3cf-4d39-ac88-b68fc90de3f5" /></p>

<p>풍경자체는 사진처럼 너무 좋았지만 비온다음날이였기에, 곳곳에 웅덩이(함정)가 숨어 있었고, 신발은 진흙탕이 되어 버리고 계단 혹은 언덕이 중간에 너무 많아 다음날 허벅지 및 온 하체가 너무 아팠다. 그 뒤로는 정말 올레길을 쳐다도 보지 않고 환상 자전거길만 따라가게 되었다..</p>

<p><img width="709" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/65afaef4-4f73-49bc-9975-387a6a9d7b18" /></p>

<p>그리고 그날 밤..
<img width="724" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/6395cb19-5ec9-49bd-993b-1e3c09b58f3c" /></p>

<h3 id="뜨거운날">뜨거운날</h3>

<p>우리는 날씨복을 정말 타고났었다. 출발할때만 해도 제주도는 일주일 내내 비가 올 예정에 중간중간에 뇌우까지 껴있어서 정말 비가 많이 온다면 계획을 취소하자는 이야기 까지 나왔었다. 하지만 막상 도착해보니 정말 부슬부슬 오는 비를 제외하고는 제대로 비가온날은 없었고, 오히려 맑은 날이 이틀정도 존재했었다. 처음에는 맑은날에 많이 걷자, 혹은 이때 버닝을 해서 40km를 걸어야 된다. 이런말을 했었는데, 막상 맑은 날은 지옥이였다.</p>

<p><img width="722" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/f1669e7e-83ca-4d90-ae72-5c4779077b5c" /></p>

<p>처음에 제주도 한바퀴를 한다고 했었을때 사람들이 제일 많이한 걱정이긴 했다. <code class="language-plaintext highlighter-rouge">7월에 더우면 어떡해?</code> 질문에 대한 나의 대답은 <code class="language-plaintext highlighter-rouge">바다 옆이니까 시원하겠지</code> 이거였다. 하지만 환상 자전거길은 항상 바다 옆에 있는것도 아니였고 정말 너무너무 더웠다. 해가 너무 강렬해서 목은 두시간에 한번씩 선크림을 발랐음에도 불구하고 빨갛게 익어버렸고 내 친구는 상남자답게 다리에는 선크림을 바르지 않았더니 정말 삼겹살마냥 구워져버렸다. 정말 살면서 이렇게 경계가 뚜렷한 피부는 처음봤다…
<img width="712" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/a005068f-5674-4db8-8024-c12ce26cc9dc" /></p>

<h3 id="바선생-두둥등장">바선생 두둥등장</h3>

<p>3일차에 우리는 지도를 보고 일정에 대한 조율을 생각해보았다. 우리가 걷는 시간으로는 딱 7일인데 이런 페이스로 걷기에는 시간이 너무 촉박한것. 그래서 무조건 35km를 맞추기로 결정을 하고 숙소 예약을 하였더니 어느날 외진곳에서 숙소를 잡아야되는 상황이 발생했다. 외진곳이다 보니 펜션밖에 없었고 가격도 비쌌지만, 일정을 맞추기 위해 어쩔 수 없이 예약하게 되었다. 그렇게 3일차를 끝내고 저녁 7시쯤에 숙소에 도착을 하게 되었다.</p>

<p>펜션 사장님 아주머니께서 안내를 해주시고 에어컨을 딱 키셨는데 거기서 바선생(바퀴벌레)가 툭 하고 떨어졌다..! (진짜 무서웠음) 근데 우리는 다리에 힘도 없고 너무너무 지쳐있는 상태라 말도 제대로 못하고 그저 충격과 공포에 쌓인채로 앉아있었다. 그리고 아주머니가 잡으려고 출동 하시는데…! 바퀴벌레가 어찌나 빠른지 호다다닥 하고 침대 밑 프레임으로 들어가버렸다.. 결국 바퀴벌레를 잡지도 못하고 소동이 끝나버린 후 우리는 나름의 작전으로 이불을 모조리 가져와서 침대의 모든 구석공간을 막은 후 바로 잠에 들었다.</p>

<p>정말 평소같았다면 방을 바꿔달라 혹은 조치를 취했을 텐데, 이미 밤이 늦었고 정말 너무너무 피곤해서 빨리 씻고 자고싶은 마음에 극단의 선택을 했었던 것 같다. (지금 생각하면 진짜 어이없음)</p>

<p><img width="1268" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/d3f07d21-f5a7-4616-a1da-a1cb76570f26" /></p>

<h3 id="응원">응원</h3>

<p>의외로 꽤나 응원을 많이 받았다. 음식점에서 서비스로 응원한다며 사이다를 받은적도 있고, 올레길을 가시던 할머니 혹은 카페에서 만난 할아버지도 응원을 해주셨다. 그리고 나이드신분들은 공통적으로 우리에게 부러움을 많이 표현하셨다. 한가지는 나이에 대한 부러움이였고, 하나는 친구의 존재에 대한 부러움이였다. 이 나이에서 밖에 하지 못할 행동이라고 표현을 해주셨고 요즘 애들은 이런 고생 안하려고 하는데 멋지다고도 많이 해주셨다. 그리고 어떠한 관심사가 있어서 모인게 아닌 (ex. 동아리) 고등학교 친구끼리 마음이 맞아 이렇게 여행을 떠날 수 있다는것에 대해 부러워 해주셨다. 나도 이런말을 듣고 생각을 해보니 정말 이친구가 아니였으면 못했을 것 같다는 생각이 들어 새삼 되게 고마워졌다.</p>

<p><img width="723" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/1ae27911-c9ed-4c19-9011-ac7a6ffef9ff" /></p>

<h2 id="후기">후기</h2>

<p>사실 고생 및 여행을 즐기고 싶었던것도 있지만, 이번 일주일동안 정말 깊은 생각을 해보고 싶었다. 퇴사를 하면서 이런저런 생각들이 많이 들었었는데, 그런 생각 정리를 조금 하고 싶었다. <code class="language-plaintext highlighter-rouge">과연 지금 내가 걷고있는 이 길이 맞는걸까?</code> 같은 방향성에 대한 고민들이 정말 많이 있었다. 그런데 막상 걸어보니 다리 및 종아리는 너무 아프고 발바닥은 첫날에 아프더니 갈수록 감각도 없어지고, 더운날에는 목이 뜨겁고 화상을 입은듯이 팔은 타들어가고 하니 생각할 겨를도 없이 일주일이 지나갔다. 물론 바다도 정말 많이 보고 컴퓨터를 열지 않아서 마음에 부담 혹은 스트레스가 정말 없었지만, 당시에 유일하게 들었던 생각은 <code class="language-plaintext highlighter-rouge">내가 왜 이러고 있지</code> 이것밖에 없었다.</p>

<p>그리고 일정이 너무 빡빡했던것도 큰 패착이였던것 같다. 하루에 35km? 솔직히 쉬울줄 알았다. 인간은 생각보다 나약했구나.. 만약 다음번에 또 제주도 한바퀴를 한다면, 혹은 누군가 내 블로그를 보며 비슷한 여정을 계획한다면 적어도 9박 10일로 일정을 잡길 바란다.</p>

<p><img width="722" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/c86d781e-0314-4201-b4a3-fd3a6537ef99" /></p>

<p>너무 부정적인것들만 나열한것 같지만 사실은 정말 재미있었다. 우선 앞서 말했듯이 컴퓨터를 일주일동안 보지 않았던게 너무 좋았다. 군대 전역 후 정말 일주일동안 컴퓨터 없이 생활을 처음 해봤던것 같다. 입사를 한 이후에는 휴가를 써도 계속 <code class="language-plaintext highlighter-rouge">slack</code>을 확인하게 되고, 계속 걱정하게되어 제대로 휴식을 해본적이 없었을 뿐더러, 집에 가만히 누워 휴식을 취하고 싶어도 계속 <code class="language-plaintext highlighter-rouge">이렇게 쉬어도 되나?</code> 라는 생각에 사로잡혀 공부 혹은 개발을 해야될것 같은 스트레스에 쌓여있었는데, 이번에는 정말 잡생각 하나 없이 <code class="language-plaintext highlighter-rouge">걷기</code>에만 집중할 수 있었고 이렇게 개발이 아닌 딴것에 온전히 100% 집중할 수 있는 환경이 너무 좋았다.</p>

<p>그리고 태원아.. 같이 가줘서 정말 고맙다~
<img width="1006" alt="image" src="https://github.com/071yoon/071yoon/assets/66371206/0b7001be-4979-4492-b9d2-e29469ea78cb" /></p>]]></content><author><name>071yoon</name></author><category term="retrospect" /><category term="retrospect" /><summary type="html"><![CDATA[걸어서 제주도 한바퀴]]></summary></entry><entry><title type="html">마음의 법칙</title><link href="http://localhost:4000/book/2023/01/15/rule-of-mind.html" rel="alternate" type="text/html" title="마음의 법칙" /><published>2023-01-15T00:00:00+09:00</published><updated>2023-01-15T00:00:00+09:00</updated><id>http://localhost:4000/book/2023/01/15/rule-of-mind</id><content type="html" xml:base="http://localhost:4000/book/2023/01/15/rule-of-mind.html"><![CDATA[<h1 id="마음의-법칙">마음의 법칙</h1>

<blockquote>
  <p>사람의 마음은 어떻게 작동하는 것일까?</p>
</blockquote>

<p>책을 읽다보면 공통적으로 언급되는 주제가 있다.</p>

<blockquote>
  <p>자신의 <code class="language-plaintext highlighter-rouge">인생의 통제권</code>을 회복하여야 한다</p>
</blockquote>

<p>여기서 말하는 <code class="language-plaintext highlighter-rouge">인생의 통제권</code>이란 어떤걸 말하는걸까?</p>

<h2 id="overview">Overview</h2>

<p>책은 우리가 평소에 어떠한 문제를 가지고 살아가며 해당 문제를 심리학적으로 분석을 해준다.</p>

<p>그리고 문제에 대한 자세한 해결법을 제시해줄 때도 있고, 문제만 언급하고 다음 주제로 넘어갈 때가 있다.</p>

<p>관련해서 예전에 정형돈이 토크쇼에 나와서 이런 이야기를 한 이야기가 기억이 났다.</p>

<blockquote>
  <p>“대학생이 성공의 기준이 무엇인지에 대해 질문을 한적이 있다. 개그맨을 꿈꾼다면 조언을 해줄 수 있겠지만, 그사람이 가자고 하는 길에 대해 아는것이 하나 없는데 내 얘기에 귀를 귀울여 변한다는것이 무섭고, 다른 사람 인생에 주제넘게 영향을 끼칠까봐 조심스러웠다”</p>
</blockquote>

<p><img width="592" alt="image" src="https://user-images.githubusercontent.com/66371206/212532415-847ae4d9-f02d-4bd2-8a3e-3fc581def0db.png" /></p>

<p>가끔 방송에서 “이렇게 해야된다~” 혹은 “이렇게 하면 안된다~” 라고 직접적으로 조언을 해주는 말을 많이 찾아볼 수 있다. 하지만 이러한 조언들이 항상 모든 사람들에게 적용 되냐는 다른 이야기라 생각한다.</p>

<p>그런 측면에서 책에서 나름 체계적이고 통계적인 분석된 결과를 가지고 문제 상황을 제기하고 해결법을 알려주지 않아, 직접 나의 상황에 맞춰 해답을 찾게 해주는것 같아 흥미롭게 읽을 수 있었다.</p>

<h2 id="인생의-통제권">인생의 통제권</h2>

<p>책을 읽다보면 지속적으로 <code class="language-plaintext highlighter-rouge">인생의 통제권</code>을 회복해야 된다는 이야기가 나오게 된다. 이는 정말 다양한 심리학적 요소들에 개입된다.</p>

<p>그 중 인상깊었던 몇 가지만 이야기해보려 한다.</p>

<h3 id="감정">감정</h3>

<blockquote>
  <p>실제로 우리는 자신의 느낌이 아니라 상대방에게 품은 <code class="language-plaintext highlighter-rouge">생각</code> 곧 주변 사람들을 보는 자신의 <code class="language-plaintext highlighter-rouge">판단</code>을 표현한다.</p>
</blockquote>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">내가 느끼기에 너는 나를 사랑하지 않아</code> 는 <code class="language-plaintext highlighter-rouge">너는 나를 사랑하지않아</code>라는 판단에서 나오게 되는 것이다. 하지만 이러한 <code class="language-plaintext highlighter-rouge">판단</code>에서 나오는 실제 감정은 <code class="language-plaintext highlighter-rouge">슬픔, 무기력함, 우울함</code> 등일 것이다. 그리고 판단이 아닌 감정을 솔직하게 받아들이는 것이 나의 감정에 충실하게 살아갈 수 있는 방법이라 말한다.</p>

<p>감정을 있는 그대로 인정하며 그대로 받아들이며 감정에 충실하게 살아갈 수 있다</p>

<h3 id="귀속-오류">귀속 오류</h3>

<p>사람은 실패나 잘못을 할 때 외부로 돌리고, 잘했을 때 자신의 덕으로 돌린다.</p>

<p>이러한 근본적인 귀속 오류를 범하지 말아야 된다.</p>

<p>특히 외부상황에 따라 어쩔 수 없이 벌어진 일임에도, 성급하게 상대에게 책임을 돌리는 행동을 조심해야 된다. <code class="language-plaintext highlighter-rouge">내부의 원인 찾기</code>로 쏠리는 배경이 무엇인지 제대로 알고 비판적으로 물어보며 자아의 상호 의존적 이해를 실현시켜야 된다.</p>

<h3 id="습관화">습관화</h3>

<p>습관화란 때론 긍정적인 면도 있고 부정적인 면도 있다.</p>

<p>책에서 소개하는 한 실험은 다음과 같다. 여러 맛이 들어있는 사탕을 주며 한 집단에게는 맛별로 구별하며 사탕의 개수를 세게 하고, 다른 집단에는 그냥 전체 사탕의 개수를 먹으면서 세게 만들었다. 그리고 사탕에 대한 만족도를 조사하였을 때 맛별로 구별하며 먹었던 집단에게서 만족도가 더 높게 나왔다.</p>

<p>사탕을 먹는 행위 자체가 습관화가 되어 버려 지루해져 만족도가 떨어지는 것이다. 하지만 맛별로 구별하며 먹게 되면 계속 생각을 하고 지루함을 느끼지 않게 되어 습관화를 예방할 수 있다.</p>

<blockquote>
  <p>즉 구체적인 계획이 지루한 습관화를 예방</p>
</blockquote>

<p>이는 단순히 단순 반복작업이 아닌 우리의 일상에서도 통용되는 말이라 생각된다.</p>

<p>이전에 읽었던 <code class="language-plaintext highlighter-rouge">함께 자라기</code> 라는 책에서 아래와 같은 도표를 언급했을때가 생각났다.</p>

<p><img width="581" alt="image" src="https://user-images.githubusercontent.com/66371206/212532285-60009e0f-d0f9-451e-956d-12a51c84fb62.png" /></p>

<p>우리가 성장을 하기 위해서는 <code class="language-plaintext highlighter-rouge">Flow Channel</code>이란 공간에 속해야 된다는 내용이였다. 만약 너무 어려운 일이라는 짜증나게 되어, 난이도를 낮춰야되고, 너무 쉬워 지루함을 느낀다면 스스로 난이도를 높여야 한다. 그리고 마음의 법칙이란 책에서는 습관화가 된다는 것을 <code class="language-plaintext highlighter-rouge">Boredom</code>이란 공간으로 표시한듯 했다.</p>

<p>하지만 일에 빠르게 적응하거나 경험이 필요할 때는 습관화가 필요할 때가 있다. 이런 때도 마찬가지로 구체적인 상상을 할 수록 습관화를 학습시킬 수 도 있다고 전달한다. 이는 마치 <code class="language-plaintext highlighter-rouge">Anxiety</code>에 속해있던 상황을 <code class="language-plaintext highlighter-rouge">Flow Channel</code>로 옮기는 것과 같다.</p>

<h3 id="소통">소통</h3>

<p>우리는 가끔 상대방의 말을 듣지 않고 말을 하려고 한다. 이는 경청이 곧 찬성이라고 생각하기 때문이다. 하지만 상대방의 말을 듣는것은 완전 무해하며 경청과 찬성이 다른것임을 이해하는것이 중요하다.</p>

<h3 id="인생의-통제권-1">인생의 통제권</h3>

<p>다중의 무지, 방과자 효과, 제노비스 신드롬 등 전부 <code class="language-plaintext highlighter-rouge">conformity</code> 즉 동조에 관련된 단어이다. 남이 하는대로 따라가고 싶어하는 욕구가 있다. 이는 우리가 인생의 통제권을 잃어버린것이다. 그래서 앞서 언급했던 통제권을 연장선으로, 우리는 우리의 감정에 대해 솔직하고 표현할 수 있어야 된다는 말을 계속 언급한다.</p>

<h2 id="후기">후기</h2>

<p>나는 자기계발서를 좋아하는 편은 아니다. 정말 당연한 말을 하며 마치 엄청난 이론인것 마냥 떠드는 책들 접해서 그렇게 됐으리라 생각한다. 이번 책도 어떤 면에서는 당연한 이론을 말하기도 하였지만, 심리학 박사가 근거와 통계를 토대로 말하고 있다는 점에서 신뢰가 갔고, 귀속 오류 등 삶에서 우리가 자주 하는 실수를 언급할 때 마다 <code class="language-plaintext highlighter-rouge">내가 실제로 이랬던가?</code> 라고 반성하는 시간도 가지게 되어 재미있었다.</p>

<p>그리고 주제와 다른 이야기지만, 책에서 마쉬멜로우 실험이 나와서 초등학교 이후로 다시 읽어 보았는데, 공감이 안가는 부분이 있었다. 만약, 참을성이 없어 참지 못하고 먹은 것이 아니라, 아이의 환경에 따라 먹지 못하는것이 아니였을까? 아이의 환경이 그런 선택을 하게끔 만들어주는것이 아닐까? 라는 생각이 들었다. 그래서 이 부분에 대해 요즘 나의 Best Friend 인 Chat GPT에게 물어보았다.</p>

<p><img width="863" alt="image" src="https://user-images.githubusercontent.com/66371206/212532999-2633999b-e991-4e96-8174-1e394b8c89b8.png" /></p>

<p>실제로 결과에 대해서 논란이 존재했고, 이러한 결과는 조심해서 봐야된다고 알려줬다. 역시 나 말고도 비판적으로 보고 있었던 사람이 존재했나보다</p>]]></content><author><name>071yoon</name></author><category term="book" /><category term="book" /><summary type="html"><![CDATA[마음의 법칙]]></summary></entry></feed>